** Prog
#+begin_src f90 :comments org :tangle fcc.irp.f
program fcc

  implicit none

  read_wf = .True.

  !call gen_fci_wf()
  call run_fcc()

end
#+end_src

** Main
#+begin_src f90 :comments org :tangle fcc.irp.f
subroutine run_fcc()

  use bitmasks
  
  implicit none

  double precision, allocatable :: T(:,:), R(:,:), all_err(:,:,:), all_t(:,:,:)
  double precision, allocatable :: C1(:,:), C2(:,:), C3(:,:)
  integer(bit_kind), allocatable :: det_bit_a(:,:),det_bit_b(:,:),det_bit_ab(:,:,:)
  integer, allocatable :: crea_a_beg(:), anni_a_beg(:), anni_a_nb(:)
  integer, allocatable :: crea_a_end(:), anni_a_end(:), crea_a_nb(:)
  integer, allocatable :: crea_b_beg(:), anni_b_beg(:), anni_b_nb(:)
  integer, allocatable :: crea_b_end(:), anni_b_end(:), crea_b_nb(:)
  integer(bit_kind), allocatable :: T_crea_a(:,:),T_anni_a(:,:), T_crea_b(:,:), T_anni_b(:,:)
  integer(bit_kind), allocatable  :: T_a(:,:,:), T_b(:,:,:)
  integer, allocatable :: T_a_beg(:), T_a_end(:)
  integer, allocatable :: T_b_beg(:), T_b_end(:)
  integer :: ndet_ab, ndet_a, ndet_b, nT_a, nT_b, nt_crea, nt_anni
  integer :: nOa, nOb, nVa, nVb, nt_anni_a,nt_crea_a,nt_anni_b,nt_crea_b
  integer :: cc_order, max_k,fact, max_order, max_order_a, max_order_b
  integer :: i,j,k,n,i_order
  logical :: ok, not_converged
  integer :: tb,ta,da,db,degree, nb_iter, degree_a, degree_b
  integer(bit_kind), allocatable :: res1_a(:), res_a(:), res1_b(:), res_b(:), det(:)
  double precision :: H, energy, max_r, phase, delta
  double precision, external :: binom_func
  integer, external          :: factorial
  
  allocate(res1_a(N_int),res_a(N_int),res1_b(N_int),res_b(N_int), det(N_int))

  if (n_del_orb > 0) then
  print*,'n',nT_a
    print*,'Impossible to do yet, remove the deleted the orbitals'
    call abort
  endif

  ! Number of occ/vir MOs after removing core and deleted ones
  nOa = cc_nOa
  nOb = cc_nOb
  nVa = cc_nVa
  nVb = cc_nVb

  ! Order of the method, max alpha/beta excitation
  cc_order = 2 
  !print*,min(nOa,nVa)+min(nOb,nVb)
  max_order_a = min(nOa,nVa)
  max_order_b = min(nOb,nVb)
  max_order = min(cc_order,max_order_a+max_order_b)
  !print*,'max_order',max_order
  max_k = 4

  ! Number of alpha/beta det
  ndet_a = floor(binom_func(nOa+nVa,nOa)+0.5d0)
  ndet_b = floor(binom_func(nOb+nVb,nOb)+0.5d0)
  ! Total number
  ndet_ab = ndet_a * ndet_b

  allocate(det_bit_a(N_int,ndet_a), det_bit_b(N_int,ndet_b), det_bit_ab(N_int,2,ndet_ab))
  
  ! Gen alpha et beta det (list)
  call gen_spin_det(nOa,nVa,ndet_a,det_bit_a,N_int)
  call gen_spin_det(nOb,nVb,ndet_b,det_bit_b,N_int)
  
  ! Gen alpha/beta det
  k = 1
  do j = 1, ndet_b
    do i = 1, ndet_a
      det_bit_ab(:,1,k) = det_bit_a(:,i)
      det_bit_ab(:,2,k) = det_bit_b(:,j)
      k = k + 1
    enddo
  enddo
  
  allocate(crea_a_beg(0:max_order),crea_a_end(0:max_order),crea_a_nb(0:max_order))
  allocate(crea_b_beg(0:max_order),crea_b_end(0:max_order),crea_b_nb(0:max_order))
  allocate(anni_a_beg(0:max_order),anni_a_end(0:max_order),anni_a_nb(0:max_order))
  allocate(anni_b_beg(0:max_order),anni_b_end(0:max_order),anni_b_nb(0:max_order))
  
  ! Number of alpha/beta crea/anni
  call compute_nb_op_spin(nVa,max_order_a,nt_crea_a,crea_a_beg,crea_a_nb,crea_a_end)
  call compute_nb_op_spin(nOa,max_order_a,nt_anni_a,anni_a_beg,anni_a_nb,anni_a_end)
  call compute_nb_op_spin(nVb,max_order_b,nt_crea_b,crea_b_beg,crea_b_nb,crea_b_end)
  call compute_nb_op_spin(nOb,max_order_b,nt_anni_b,anni_b_beg,anni_b_nb,anni_b_end)

  ! Number of T alpha/beta
  nT_a = 0
  nT_b = 0
  do i_order = 0, max_order_a
    nT_a = nT_a + crea_a_nb(i_order) * anni_a_nb(i_order)
  enddo
  do i_order = 0, max_order_b
    nT_b = nT_b + crea_b_nb(i_order) * anni_b_nb(i_order)
  enddo

  allocate(T_crea_a(N_int,nt_crea_a), T_anni_a(N_int,nt_anni_a), T_a(N_int,2,nT_a))
  allocate(T_crea_b(N_int,nt_crea_b), T_anni_b(N_int,nt_anni_b), T_b(N_int,2,nT_b), T(nT_a,nT_b))
  allocate(T_a_beg(0:max_order_a), T_a_end(0:max_order_a))
  allocate(T_b_beg(0:max_order_b), T_b_end(0:max_order_b))

  ! T alpha/beta 
  call gen_spin_T(nOa,nVa,max_order_a,nt_crea_a,nt_anni_a, &
   crea_a_beg,anni_a_beg,crea_a_end,anni_a_end,crea_a_nb,anni_a_nb, &
   nT_a,T_a,T_a_beg,T_a_end,N_int)
  call gen_spin_T(nOb,nVb,max_order_b,nt_crea_b,nt_anni_b, &
   crea_b_beg,anni_b_beg,crea_b_end,anni_b_end,crea_b_nb,anni_b_nb, &
   nT_b,T_b,T_b_beg,T_b_end,N_int)

  ! Init
  T = 0d0
  allocate(C3(ndet_a,ndet_b),R(nT_a,nT_b))
  allocate(all_t(nT_a,nT_b,cc_diis_depth),all_err(nT_a,nT_b,cc_diis_depth))
  
  all_t = 0d0
  all_err = 0d0

  nb_iter = 0
  not_converged = .True.
  max_r = 0d0
  do while (not_converged)

    ! wf exppoentialization
    call exp_wf(max_k,max_order,ndet_a,det_bit_a,ndet_b,det_bit_b, &
         nT_a,T_a,nT_b,T_b,T,C3,N_int)

    !print*,'c',C3
    ! Energy
    call i_H_psi(det_bit_ab(1,1,1),det_bit_ab,C3,N_int,ndet_ab,ndet_ab,1,energy)
    !print*,'E1',energy+nuclear_repulsion,max_r
    
    max_r = 0d0
    
    ! Residual equations
    do tb = 1, nT_b
      ! Annihilation part
      call apply_holes_bitstring(det_bit_b(1,1),T_b(1,1,tb),res1_b,ok,N_int)
      if (.not. ok) cycle
      ! Creation part
      call apply_particles_bitstring(res1_b,T_b(1,2,tb),res_b,ok,N_int)
      if (.not. ok) cycle
      do ta = 1, nT_a
        if (ta == 1 .and. tb == 1) then
           cycle
        endif
        ! Annihilation
        call apply_holes_bitstring(det_bit_a(1,1),T_a(1,1,ta),res1_a,ok,N_int)
        if (.not. ok) cycle
        ! Creation
        call apply_particles_bitstring(res1_a,T_a(1,2,ta),res_a,ok,N_int)
        if (.not. ok) cycle
        ! Resulting det
        det = (/res_a,res_b/)
        !print*,ta,tb
        !call print_det((/res_a,res_b/),N_int)
        !call print_det(T_a(1,1,ta),N_int)

        ! Search for the index of det in the wf
        do da = 1, ndet_a
          call get_excitation_degree_spin(det_bit_a(1,da),res_a,degree,N_int)
          if (degree == 0) exit
        enddo
        !print*,'alpha'
        !call print_det((/res_a,det_bit_a(1,da)/),N_int)
        
        do db = 1, ndet_b
          call get_excitation_degree_spin(det_bit_b(1,db),res_b,degree,N_int)
          if (degree == 0) exit
        enddo
        !print*,'beta'
        !call print_det((/res_b,det_bit_b(1,db)/),N_int)

        ! Check the excitation degree
        call get_excitation_degree_spin(det_bit_a(1,1),res_a,degree_a,N_int)
        call get_excitation_degree_spin(det_bit_b(1,1),res_b,degree_b,N_int)
        if (degree_a + degree_b > cc_order) then
           R(ta,tb) = 0d0
           cycle
        endif

        ! Debug
        !do j = 1, N_det
        !  call get_excitation_degree(det_bit_ab(1,1,da+(db-1)*ndet_a),psi_det(1,1,j),degree,N_int) 
        !  if (degree == 0) exit
        !enddo
        !print*,'check'
        !call print_det((/res_a,res_b/),N_int)
        !call print_det(det_bit_ab(1,1,da+(db-1)*ndet_a),N_int)
        !call print_det(psi_det(1,1,j),N_int)
        !call get_phase(det_bit_ab(1,1,1),det_bit_ab(1,1,da+(db-1)*ndet_a),phase,N_int)
        
        ! Must be replaced
        !call get_phase(det_bit_ab(1,1,1),(/res_a,res_b/),phase,N_int)
        call get_phase_general(det_bit_ab(1,1,1),(/res_a,res_b/),phase,degree,N_int)
        !if (degree_a+degree_b > 2) then
        !   print*,'Need the right subroutine for the phase'
        !   call abort
        !endif

        !call print_det((/res_a,res_b/),N_int)
        call i_H_psi(det,det_bit_ab,C3,N_int,ndet_ab,ndet_ab,1,H)
        !print*,'H',H,energy*C3(da,db),T(ta,tb)
        R(ta,tb) = (H - energy * C3(da,db)) * phase
        ! Max elem
        if (dabs(R(ta,tb)) > max_r) then
           max_r = dabs(R(ta,tb))
        endif
        !T(ta,tb) = T(ta,tb) + r/delta !energy * 0.1d0
        !print*,delta
        !print*,'H',H- energy * C3(da,db) * phase, phase
        !print*,'r',r,r/energy
        !print*,C3(da,db),psi_coef(j,1)*1d0/psi_coef(1,1),R(ta,tb)
  
      enddo
    enddo

    ! Update the amplitudes
    !print*,'R',R
    R(1,1) = 0d0
    do tb = 1, nT_b
      do ta = 1, nT_a
        if (ta == 1 .and. tb == 1) cycle
        ! Delta computed with orbital energies
        call extract_delta(T_a(1,1,ta),T_a(1,2,ta),T_b(1,1,tb),T_b(1,2,tb),delta,N_int)
        R(ta,tb) = R(ta,tb)/delta
      enddo
    enddo
    call update_all_err(R,all_err,nT_a*nT_b,cc_diis_depth,nb_iter+1)
    call update_all_t(T,all_t,nT_a*nT_b,cc_diis_depth,nb_iter+1)
    call diis_cc(all_err,all_t,nT_a*nT_b,cc_diis_depth,nb_iter+1,T)
    
    !do tb = 1, nT_b
    !  do ta = 1, nT_a
    !    if (ta == 1 .and. tb == 1) cycle
    !    ! Delta computed with orbital energies
    !    call extract_delta(T_a(1,1,ta),T_a(1,2,ta),T_b(1,1,tb),T_b(1,2,tb),delta,N_int)
    !    T(ta,tb) = T(ta,tb) + R(ta,tb)/delta
    !  enddo
    !enddo
    ! Energy
    print*,'E',nb_iter,energy+nuclear_repulsion,max_r
    
    if (max_r < cc_thresh_conv .and. nb_iter > 0) then
       not_converged = .False.
    endif
    !if (nb_iter > 2) exit
    !print*,'T',T
    !print*,'C',C3
    nb_iter = nb_iter + 1
  enddo

  deallocate(res1_a,res_a,res1_b,res_b,det)
  deallocate(crea_a_beg,crea_a_end,crea_a_nb)
  deallocate(crea_b_beg,crea_b_end,crea_b_nb)
  deallocate(anni_a_beg,anni_a_end,anni_a_nb)
  deallocate(anni_b_beg,anni_b_end,anni_b_nb)
  deallocate(T_crea_a, T_anni_a, T_a)
  deallocate(T_crea_b, T_anni_b, T_b, T)
  deallocate(T_a_beg, T_a_end)
  deallocate(T_b_beg, T_b_end)
  deallocate(C3,R)
  deallocate(all_t,all_err)
  deallocate(det_bit_a, det_bit_b, det_bit_ab)

  
end
#+end_src

** Apply holes
#+begin_src f90 :comments org :tangle fcc.irp.f
subroutine apply_holes_bitstring(spin_det,h_bitstring,res,ok,Nint)

  use bitmasks
  
  implicit none

  BEGIN_DOC
  ! h_bitstring must be a integer containing some 1 where electrons have to
  ! be annihilate
  END_DOC

  ! Anni
  ! Apply
  !0001010  1110101
  !1111110  1111110
  !         1110100  
  !1110100 (not anni) and det
 
  !test
  !0001010 1110101
  !1110110 1110110
  !
  !0001000 1110111 (not anni) or det
  !        0001000 not((not anni) or det)

  integer, intent(in)            :: Nint
  integer(bit_kind), intent(in)  :: spin_det(Nint), h_bitstring(Nint)
  integer(bit_kind), intent(out) :: res(Nint)
  logical, intent(out)           :: ok

  integer                        :: i

  ok = .True.
  do i = 1, Nint
    res(i) = iand(not(h_bitstring(i)),spin_det(i))
    if (not(ior(not(h_bitstring(i)),spin_det(i))) /= 0) then
      ok = .False.
    endif
  enddo  
  
end
#+end_src

** Apply particles
#+begin_src f90 :comments org :tangle fcc.irp.f
subroutine apply_particles_bitstring(spin_det,p_bitstring,res,ok,Nint)

  use bitmasks
  
  implicit none

  BEGIN_DOC
  ! p_bitstring must be a integer containing some 1 where electrons have to
  ! be annihilate
  END_DOC

  ! Crea
  ! Apply
  ! 0001010
  ! 1100000
  ! 1101010 crea or det
  !
  ! Test
  ! 0001010
  ! 1101000
  ! 0001000 crea and det

  integer, intent(in)            :: Nint
  integer(bit_kind), intent(in)  :: spin_det(Nint), p_bitstring(Nint)
  integer(bit_kind), intent(out) :: res(Nint)
  logical, intent(out)           :: ok

  integer                        :: i

  ok = .True.
  do i = 1, Nint
    res(i) = ior(p_bitstring(i),spin_det(i))
    if (iand(p_bitstring(i),spin_det(i)) /= 0) then
      ok = .False.
    endif
  enddo

end
 #+end_src
 
** Gen spin det
#+begin_src f90 :comments org :tangle fcc.irp.f
subroutine gen_spin_det(nOs,nVs,ndet_s,det_bit_s,Nint)

  use bitmasks
  
  implicit none

  integer, intent(in)            :: nOs,nVs,ndet_s,Nint
  integer(bit_kind), intent(out) :: det_bit_s(Nint,ndet_s)
  integer, allocatable           :: det_s(:,:), tmp(:)

  integer :: i,j,k
  
  allocate(det_s(nOs+nVs,ndet_s))
  allocate(tmp(mo_num))
  
  ! Gen alpha/beta det (list)
  call gen_k_in_n(nOs,nOs+nVs,1,ndet_s,det_s)

  ! List to bistring of alpha/beta det
  do i = 1, ndet_s
    do j = 1, n_core_orb
       tmp(j) = list_core(j)
    enddo
    k = 1 + n_core_orb
    do j = 1, nOs+nVs
       if (det_s(j,i) == 1) then
        tmp(k) = j + n_core_orb
        k = k + 1
      endif
    enddo
    call list_to_bitstring(det_bit_s(1,i),tmp,k-1,Nint)
  enddo

  deallocate(det_s,tmp)
  
end
#+end_src

** Nb op spin
#+begin_src f90 :comments org :tangle fcc.irp.f
subroutine compute_nb_op_spin(nOs,max_order,nt_op_s,op_s_beg,op_s_nb,op_s_end)

  implicit none

  integer, intent(in)        :: nOs, max_order
  integer, intent(out)       :: nt_op_s, op_s_beg(0:max_order), op_s_nb(0:max_order), op_s_end(0:max_order)

  integer                    :: i_order
  double precision, external :: binom_func
  
  nt_op_s  = 0
  op_s_beg = 0
  op_s_nb  = 0
  op_s_end = 0

  do i_order = 0, max_order 
    op_s_beg(i_order) = nt_op_s+1
    op_s_nb(i_order)  = floor(binom_func(nOs,i_order)+0.5d0)
    nt_op_s           = nt_op_s + op_s_nb(i_order)
    op_s_end(i_order) = op_s_beg(i_order) + op_s_nb(i_order) - 1
  enddo
  
end
#+end_src

** Gen spin T
#+begin_src f90 :comments org :tangle fcc.irp.f
subroutine gen_spin_T(nOs,nVs,max_order,nt_crea_s,nt_anni_s, &
   crea_s_beg,anni_s_beg,crea_s_end,anni_s_end,crea_s_nb,anni_s_nb, &
   nT_s,T_s,T_s_beg,T_s_end,Nint)

  use bitmasks
  
  implicit none

  integer, intent(in)            :: nOs, nVs, nT_s, max_order, Nint, nt_crea_s, nt_anni_s
  integer, intent(in)            :: anni_s_beg(0:max_order), crea_s_beg(0:max_order)
  integer, intent(in)            :: anni_s_end(0:max_order), crea_s_end(0:max_order)
  integer, intent(in)            :: anni_s_nb(0:max_order), crea_s_nb(0:max_order)
  integer(bit_kind), intent(out) :: T_s(Nint,2,nT_s)
  integer, intent(out)           :: T_s_beg(0:max_order), T_s_end(0:max_order)

  integer, allocatable           :: det_anni(:,:), det_crea(:,:), tmp(:), t_anni(:,:), t_crea(:,:)
  integer(bit_kind), allocatable :: T_anni_s(:,:), T_crea_s(:,:)
  integer                        :: i,j,k,i_order

  ! Gen the alpha/beta parts of the excitations and convert them to bistring
  allocate(det_anni(nOs,nt_anni_s),det_crea(nVs,nt_crea_s))
  do i_order = 0, max_order
    !print*,'i_order',i_order
    allocate(t_anni(nVs,anni_s_nb(i_order)),t_crea(nOs,anni_s_nb(i_order)))
    call gen_k_in_n(i_order,nOs,anni_s_beg(i_order),nt_anni_s,det_anni)
    call gen_k_in_n(i_order,nVs,crea_s_beg(i_order),nt_crea_s,det_crea)
    deallocate(t_anni,t_crea)
  enddo

  !do i = 1, nt_crea_s
  !  print*,i
  !  print*,det_crea(:,i)
  !  print*,''
  !enddo
  !call abort

  allocate(T_anni_s(Nint,nt_anni_s), T_crea_s(Nint,nt_crea_s))
  allocate(tmp(mo_num))

  ! List of int to bitstrings
  do i = 1, nt_anni_s
    k = 1
    do j = 1, nOs
      if (det_anni(j,i) == 1) then
        tmp(k) = j + n_core_orb
        k = k + 1
      endif
    enddo
    call list_to_bitstring(T_anni_s(1,i),tmp,k-1,N_int)
    ! Debug
    !print*,'anni',i
    !call print_det_one_dimension(T_anni_s(1,i),N_int)
  enddo
  do i = 1, nt_crea_s
    k = 1
    do j = 1, nVs
      if (det_crea(j,i) == 1) then
        tmp(k) = j + n_core_orb + nOs
        k = k + 1
      endif
    enddo
    call list_to_bitstring(T_crea_s(1,i),tmp,k-1,N_int)
    ! Debug
    !print*,'crea',i
    !call print_det_one_dimension(T_crea_s(1,i),N_int)
  enddo

  ! gather anni and crea alpha
  k = 1
  do i_order = 0, max_order
    T_s_beg(i_order) = k
    do j = anni_s_beg(i_order), anni_s_end(i_order)
      do i = crea_s_beg(i_order), crea_s_end(i_order)
        T_s(:,1,k) = T_anni_s(:,j)
        T_s(:,2,k) = T_crea_s(:,i)
        ! Debug
        !print*,i_order
        !call print_det(T_s(1,1,k),N_int)
        k = k + 1
      enddo
    enddo
    T_s_end(i_order) = k-1
  enddo

  deallocate(det_anni,det_crea,T_anni_s,T_crea_s,tmp)
  
end
#+end_src

** Exp wf
#+begin_src f90 :comments org :tangle fcc.irp.f
subroutine exp_wf(max_k,max_order,ndet_a,det_bit_a,ndet_b,det_bit_b, &
     nT_a,T_a,nT_b,T_b,T,C3,Nint)

  use bitmasks
  
  implicit none

  integer, intent(in)            :: max_k,max_order,ndet_a, ndet_b, nT_a, nT_b, Nint
  integer(bit_kind), intent(in)  :: T_a(Nint,2,nT_a), T_b(Nint,2,nT_b)
  integer(bit_kind), intent(in)  :: det_bit_a(Nint,ndet_a), det_bit_b(Nint,ndet_b)
  double precision, intent(in)   :: T(nT_a,nT_b)
  
  double precision, intent(out)  :: C3(ndet_a,ndet_b)
  
  double precision, allocatable  :: C1(:,:), C2(:,:)
  integer(bit_kind), allocatable :: res1_a(:), res_a(:), res1_b(:), res_b(:)
  integer                        :: i,j,k,ta,tb,da,db,fact,exc_a,exc_b,degree,i_order
  integer                        :: degree_a, degree_b
  integer, external              :: factorial
  logical                        :: ok
  double precision               :: phase

  allocate(C1(ndet_a,ndet_b),C2(ndet_a,ndet_b))

  ! Init
  C1 = 0d0
  C3 = 0d0
  C1(1,1) = 1d0
  C3(1,1) = 1d0
  !print*,'c',C3
  !print*,'t',T

  allocate(res1_a(Nint),res_a(Nint),res1_b(Nint),res_b(Nint))

  do k = 1, max_k
    
    ! Init
    C2 = 0d0
    do db = 1, ndet_b
      do da = 1, ndet_a
        do tb = 1, nT_b
          do ta = 1, nT_a
        
            ! Apply exc and check
            ! Annihilation part
            call apply_holes_bitstring(det_bit_b(1,db),T_b(1,1,tb),res1_b,ok,Nint)
            if (.not. ok) cycle
            ! Creation part
            call apply_particles_bitstring(res1_b,T_b(1,2,tb),res_b,ok,Nint)
            if (.not. ok) cycle
            ! Annihilation
            call apply_holes_bitstring(det_bit_a(1,da),T_a(1,1,ta),res1_a,ok,Nint)
            if (.not. ok) cycle
            ! Creation
            call apply_particles_bitstring(res1_a,T_a(1,2,ta),res_a,ok,Nint)
            if (.not. ok) cycle
            
            call get_excitation_degree_spin(det_bit_b(1,db),res_b(1),degree_b,Nint)
            call get_excitation_degree_spin(det_bit_a(1,da),res_a(1),degree_a,Nint)
            !print*,'degree',degree_a,degree_b
            if (degree_a + degree_b > max_order .or. degree_a + degree_b == 0) cycle

            
            ! Search res_a in det_a
            ok = .False.
            do i = 1, ndet_a
              call get_excitation_degree_spin(det_bit_a(1,i),res_a(1),degree,Nint)
              if (degree == 0) then
                exc_a = i
                ok = .True.
                exit
              endif
            enddo
            if (.not. ok) then
              print*,'No 0 degree exc in wf a',ta
              call print_det_one_dimension(res_a,Nint)
              print*,''
              call print_det(T_a(1,1,ta),Nint)
              call abort
            endif
         
            ! Search res_b in det_b
            ok = .False.
            do i = 1, ndet_b
              call get_excitation_degree_spin(det_bit_b(1,i),res_b(1),degree,Nint)
              if (degree == 0) then
                exc_b = i
                ok = .True.
                exit
              endif
            enddo
            if (.not. ok) then
              print*,'No 0 degree exc in wf b'
              call print_det_one_dimension(res_b,Nint)
              print*,''
              call abort
            endif

            ! Phase
            ! TODO: phase for arbitrary degree of exc
            !call get_phase((/det_bit_a(1,da),det_bit_b(1,db)/),(/res_a,res_b/),phase,Nint)
            call get_phase_general((/det_bit_a(1,da),det_bit_b(1,db)/),(/res_a,res_b/),phase,degree,Nint)
            !print*,'phase',phase
            ! Debug
            !print*,i_order,ta,tb
            !print*,exc_a,exc_b,T(ta,tb),C1(da,db)
            !call print_det(T_a(1,1,ta),Nint)
            !call print_det(T_b(1,1,tb),Nint)
            !print*,'det'
            !call print_det((/det_bit_a(1,da),det_bit_b(1,db)/),Nint)
            !call print_det((/res_a,res_b/),Nint)
            !print*,'p',phase
            C2(exc_a,exc_b) = C2(exc_a,exc_b) + C1(da,db) * T(ta,tb) * phase
          enddo
        enddo
      enddo
    enddo

    ! update
    fact = factorial(k)
    !print*,'f',fact
    !print*,'&',c3
    !print*,'2',c2
    C3(:,:) = C3(:,:) + C2(:,:) * 1d0/dble(fact)
    !print*,'&&',c3
    C1 = C2
    !call abort
  enddo
  
  deallocate(C1,C2,res1_a,res_a,res1_b,res_b)

end
#+end_src

** Residue
#+begin_src f90 :comments org :tangle fcc.irp.f
subroutine compute_residue()

  implicit none


  
end
#+end_src

** Extract e orb
#+begin_src f90 :comments org :tangle fcc.irp.f
subroutine extract_delta(anni_a,crea_a,anni_b,crea_b,delta,Nint)

  use bitmasks
  
  implicit none

  BEGIN_DOC
  ! Compute the delta_i...a... based on the annihilation/excitation determinants
  END_DOC

  integer, intent(in) :: Nint
  integer(bit_kind), intent(in) :: anni_a(Nint), crea_a(Nint)
  integer(bit_kind), intent(in) :: anni_b(Nint), crea_b(Nint)
  double precision, intent(out) :: delta
  integer, allocatable :: orb_list(:,:)
  integer :: i,j,idx,nb(2)

  allocate(orb_list(Nint*bit_kind_size,2))

  delta = 0d0

  !call print_det((/anni_a,anni_b/),Nint)
  call bitstring_to_list_ab((/anni_a,anni_b/), orb_list, nb, Nint)
  !print*,'anni a',orb_list(:,1)
  !print*,'anni b',orb_list(:,2)
  
  do j = 1, 2
    do i = 1, nb(j)
      idx = orb_list(i,j)
      if (idx == 0) exit
      !print*,'o',orb_list(i,j)
      delta = delta + fock_matrix_mo(idx,idx)
    enddo
  enddo
  
  call bitstring_to_list_ab((/crea_a,crea_b/), orb_list, nb, Nint)
  !print*,'crea',orb_list
  do j = 1, 2
    do i = 1, nb(j)
      idx = orb_list(i,j)
      if (idx == 0) exit
      !print*,'v',orb_list(i,j)
      delta = delta - fock_matrix_mo(idx,idx)
    enddo
  enddo
  
  deallocate(orb_list) 

end
#+end_src
