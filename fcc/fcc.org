** Prog
#+begin_src f90 :comments org :tangle fcc.irp.f
program fcc

  implicit none

  read_wf = .True.

  !call gen_fci_wf()
  call run_fcc()

end
#+end_src

** Main
#+begin_src f90 :comments org :tangle fcc.irp.f
subroutine run_fcc()

  use bitmasks
  
  implicit none

  double precision, allocatable :: T(:,:)
  double precision, allocatable :: C1(:,:), C2(:,:), C3(:,:)
  integer(bit_kind), allocatable :: det_bit_a(:,:),det_bit_b(:,:),det_bit_ab(:,:,:)
  integer, allocatable :: crea_a_beg(:), anni_a_beg(:), anni_a_nb(:)
  integer, allocatable :: crea_a_end(:), anni_a_end(:), crea_a_nb(:)
  integer, allocatable :: crea_b_beg(:), anni_b_beg(:), anni_b_nb(:)
  integer, allocatable :: crea_b_end(:), anni_b_end(:), crea_b_nb(:)
  integer(bit_kind), allocatable :: T_crea_a(:,:),T_anni_a(:,:), T_crea_b(:,:), T_anni_b(:,:)
  integer(bit_kind), allocatable  :: T_a(:,:,:), T_b(:,:,:)
  integer, allocatable :: T_a_beg(:), T_a_end(:)
  integer, allocatable :: T_b_beg(:), T_b_end(:)
  integer :: ndet_ab, ndet_a, ndet_b, nT_a, nT_b, nt_crea, nt_anni
  integer :: nOa, nOb, nVa, nVb, nt_anni_a,nt_crea_a,nt_anni_b,nt_crea_b
  integer :: cc_order, max_k,fact, max_order
  integer :: i,j,k,n,i_order

  if (n_del_orb > 0) then
  print*,'n',nT_a
    print*,'Impossible to do yet, remove the deleted the orbitals'
    call abort
  endif

  double precision, external :: binom_func
  integer, external          :: factorial

  ! Number of occ/vir MOs after removing core and deleted ones
  nOa = cc_nOa
  nOb = cc_nOb
  nVa = cc_nVa
  nVb = cc_nVb
  
  cc_order = 2
  print*,min(nOa,nVa),min(nOb,nVb)
  max_order = min(cc_order,min(min(nOa,nVa),min(nOb,nVb)))
  max_k = 4

  ! Numer of alpha/beta det
  ndet_a = int(binom_func(nOa+nVa,nOa))
  ndet_b = int(binom_func(nOb+nVb,nOb))
  ndet_ab = ndet_a * ndet_b

  allocate(det_bit_a(N_int,ndet_a), det_bit_b(N_int,ndet_b), det_bit_ab(N_int,2,ndet_ab))
  
  ! Gen alpha et beta det (list)
  call gen_spin_det(nOa,nVa,ndet_a,det_bit_a,N_int)
  call gen_spin_det(nOb,nVb,ndet_b,det_bit_b,N_int)
  
  ! Gen alpha/beta det
  k = 1
  do j = 1, ndet_b
    do i = 1, ndet_a
      det_bit_ab(:,1,k) = det_bit_a(:,i)
      det_bit_ab(:,2,k) = det_bit_b(:,j)
      k = k + 1
    enddo
  enddo
  
  ! Number of alpha/beta crea/anni
  allocate(crea_a_beg(0:max_order),crea_a_end(0:max_order),crea_a_nb(0:max_order))
  allocate(crea_b_beg(0:max_order),crea_b_end(0:max_order),crea_b_nb(0:max_order))
  allocate(anni_a_beg(0:max_order),anni_a_end(0:max_order),anni_a_nb(0:max_order))
  allocate(anni_b_beg(0:max_order),anni_b_end(0:max_order),anni_b_nb(0:max_order))
  
  call compute_nb_op_spin(nVa,max_order,nt_crea_a,crea_a_beg,crea_a_nb,crea_a_end)
  call compute_nb_op_spin(nOa,max_order,nt_anni_a,anni_a_beg,anni_a_nb,anni_a_end)
  call compute_nb_op_spin(nVb,max_order,nt_crea_b,crea_b_beg,crea_b_nb,crea_b_end)
  call compute_nb_op_spin(nOb,max_order,nt_anni_b,anni_b_beg,anni_b_nb,anni_b_end)

  ! Number of T alpha/beta
  nT_a = 0
  nT_b = 0
  do i_order = 0, max_order
    nT_a = nT_a + crea_a_nb(i_order) * anni_a_nb(i_order)
    nT_b = nT_b + crea_b_nb(i_order) * anni_b_nb(i_order)
  enddo

  allocate(T_crea_a(N_int,nt_crea_a), T_anni_a(N_int,nt_anni_a), T_a(N_int,2,nT_a))
  allocate(T_crea_b(N_int,nt_crea_b), T_anni_b(N_int,nt_anni_b), T_b(N_int,2,nT_b), T(nT_a,nT_b))
  allocate(T_a_beg(0:max_order), T_a_end(0:max_order))
  allocate(T_b_beg(0:max_order), T_b_end(0:max_order))

  ! T alpha/beta 
  call gen_spin_T(nOa,nVa,max_order,nt_crea_a,nt_anni_a, &
   crea_a_beg,anni_a_beg,crea_a_end,anni_a_end,crea_a_nb,anni_a_nb, &
   nT_a,T_a,T_a_beg,T_a_end,N_int)
  call gen_spin_T(nOb,nVb,max_order,nt_crea_b,nt_anni_b, &
   crea_b_beg,anni_b_beg,crea_b_end,anni_b_end,crea_b_nb,anni_b_nb, &
   nT_b,T_b,T_b_beg,T_b_end,N_int)

  ! Init
  T = 0d0
  allocate(C3(ndet_a,ndet_b))
  
  !call exp_wf(max_k,max_order,ndet_a,det_bit_a,ndet_b,det_bit_b, &
  !     nT_a,T_a,nT_b,T_b,T,C3,N_int)

  logical :: ok
  integer :: tb,ta
  integer(bit_kind), allocatable :: res1_a(:), res_a(:), res1_b(:), res_b(:)
  allocate(res1_a(N_int),res_a(N_int),res1_b(N_int),res_b(N_int))
 
  ! Residual equations
  do tb = 1, nT_b
    ! Annihilation part
    call apply_holes_bitstring(det_bit_b(1,1),T_b(1,1,tb),res1_b,ok,N_int)
    if (.not. ok) cycle
    ! Creation part
    call apply_particles_bitstring(res1_b,T_b(1,2,tb),res_b,ok,N_int)
    if (.not. ok) cycle
    do ta = 1, nT_a
      ! Annihilation
      call apply_holes_bitstring(det_bit_a(1,1),T_a(1,1,ta),res1_a,ok,N_int)
      if (.not. ok) cycle
      ! Creation
      call apply_particles_bitstring(res1_a,T_a(1,2,ta),res_a,ok,N_int)
      if (.not. ok) cycle
      !call print_det((/res_a,res_b/),N_int)
      !call print_det(T_a(1,1,ta),N_int)
    enddo
  enddo
  
end
#+end_src

** Apply holes
#+begin_src f90 :comments org :tangle fcc.irp.f
subroutine apply_holes_bitstring(spin_det,h_bitstring,res,ok,Nint)

  use bitmasks
  
  implicit none

  BEGIN_DOC
  ! h_bitstring must be a integer containing some 1 where electrons have to
  ! be annihilate
  END_DOC

  ! Anni
  ! Apply
  !0001010  1110101
  !1111110  1111110
  !         1110100  
  !1110100 (not anni) and det
 
  !test
  !0001010 1110101
  !1110110 1110110
  !
  !0001000 1110111 (not anni) or det
  !        0001000 not((not anni) or det)

  integer, intent(in)            :: Nint
  integer(bit_kind), intent(in)  :: spin_det(Nint), h_bitstring(Nint)
  integer(bit_kind), intent(out) :: res(Nint)
  logical, intent(out)           :: ok

  integer                        :: i

  ok = .True.
  do i = 1, Nint
    res(i) = iand(not(h_bitstring(i)),spin_det(i))
    if (not(ior(not(h_bitstring(i)),spin_det(i))) /= 0) then
      ok = .False.
    endif
  enddo  
  
end
#+end_src

** Apply particles
#+begin_src f90 :comments org :tangle fcc.irp.f
subroutine apply_particles_bitstring(spin_det,p_bitstring,res,ok,Nint)

  use bitmasks
  
  implicit none

  BEGIN_DOC
  ! p_bitstring must be a integer containing some 1 where electrons have to
  ! be annihilate
  END_DOC

  ! Crea
  ! Apply
  ! 0001010
  ! 1100000
  ! 1101010 crea or det
  !
  ! Test
  ! 0001010
  ! 1101000
  ! 0001000 crea and det

  integer, intent(in)            :: Nint
  integer(bit_kind), intent(in)  :: spin_det(Nint), p_bitstring(Nint)
  integer(bit_kind), intent(out) :: res(Nint)
  logical, intent(out)           :: ok

  integer                        :: i

  ok = .True.
  do i = 1, Nint
    res(i) = ior(p_bitstring(i),spin_det(i))
    if (iand(p_bitstring(i),spin_det(i)) /= 0) then
      ok = .False.
    endif
  enddo

end
 #+end_src
 
** Gen spin det
#+begin_src f90 :comments org :tangle fcc.irp.f
subroutine gen_spin_det(nOs,nVs,ndet_s,det_bit_s,Nint)

  use bitmasks
  
  implicit none

  integer, intent(in)            :: nOs,nVs,ndet_s,Nint
  integer(bit_kind), intent(out) :: det_bit_s(Nint,ndet_s)
  integer, allocatable           :: det_s(:,:), tmp(:)

  integer :: i,j,k
  
  allocate(det_s(nOs+nVs,ndet_s))
  allocate(tmp(mo_num))
  
  ! Gen alpha/beta det (list)
  call gen_k_in_n(nOs,nOs+nVs,1,ndet_s,det_s)

  ! List to bistring of alpha/beta det
  do i = 1, ndet_s
    do j = 1, n_core_orb
       tmp(j) = list_core(j)
    enddo
    k = 1 + n_core_orb
    do j = 1, nOs+nVs
       if (det_s(j,i) == 1) then
        tmp(k) = j
        k = k + 1
      endif
    enddo
    call list_to_bitstring(det_bit_s(1,i),tmp,k-1,Nint)
  enddo

  deallocate(det_s,tmp)
  
end
#+end_src

** Nb op spin
#+begin_src f90 :comments org :tangle fcc.irp.f
subroutine compute_nb_op_spin(nOs,max_order,nt_op_s,op_s_beg,op_s_nb,op_s_end)

  implicit none

  integer, intent(in)        :: nOs, max_order
  integer, intent(out)       :: nt_op_s, op_s_beg(0:max_order), op_s_nb(0:max_order), op_s_end(0:max_order)

  integer                    :: i_order
  double precision, external :: binom_func
  
  nt_op_s  = 0
  op_s_beg = 0
  op_s_nb  = 0
  op_s_end = 0

  do i_order = 0, max_order 
    op_s_beg(i_order) = nt_op_s+1
    op_s_nb(i_order)  = int(binom_func(nOs,i_order))
    nt_op_s           = nt_op_s + op_s_nb(i_order)
    op_s_end(i_order) = op_s_beg(i_order) + op_s_nb(i_order) - 1
  enddo
  
end
#+end_src

** Gen spin T
#+begin_src f90 :comments org :tangle fcc.irp.f
subroutine gen_spin_T(nOs,nVs,max_order,nt_crea_s,nt_anni_s, &
   crea_s_beg,anni_s_beg,crea_s_end,anni_s_end,crea_s_nb,anni_s_nb, &
   nT_s,T_s,T_s_beg,T_s_end,Nint)

  use bitmasks
  
  implicit none

  integer, intent(in)            :: nOs, nVs, nT_s, max_order, Nint, nt_crea_s, nt_anni_s
  integer, intent(in)            :: anni_s_beg(0:max_order), crea_s_beg(0:max_order)
  integer, intent(in)            :: anni_s_end(0:max_order), crea_s_end(0:max_order)
  integer, intent(in)            :: anni_s_nb(0:max_order), crea_s_nb(0:max_order)
  integer(bit_kind), intent(out) :: T_s(Nint,2,nT_s)
  integer, intent(out)           :: T_s_beg(0:max_order), T_s_end(0:max_order)

  integer, allocatable           :: det_anni(:,:), det_crea(:,:), tmp(:), t_anni(:,:), t_crea(:,:)
  integer(bit_kind), allocatable :: T_anni_s(:,:), T_crea_s(:,:)
  integer                        :: i,j,k,i_order

  ! Gen the alpha/beta parts of the excitations and convert them to bistring
  allocate(det_anni(nOs,nt_anni_s),det_crea(nVs,nt_crea_s))
  do i_order = 1, max_order
    allocate(t_anni(nVs,anni_s_nb(i_order)),t_crea(nOs,anni_s_nb(i_order)))
    call gen_k_in_n(i_order,nOs,anni_s_beg(i_order),nt_anni_s,det_anni)
    call gen_k_in_n(i_order,nVs,crea_s_beg(i_order),nt_crea_s,det_crea)
    deallocate(t_anni,t_crea)
  enddo

  allocate(T_anni_s(Nint,nt_anni_s), T_crea_s(Nint,nt_crea_s))
  allocate(tmp(mo_num))

  ! List of int to bitstrings
  do i = 1, nt_anni_s
    k = 1
    do j = 1, nOs
      if (det_anni(j,i) == 1) then
        tmp(k) = j + n_core_orb
        k = k + 1
      endif
    enddo
    call list_to_bitstring(T_anni_s(1,i),tmp,k-1,N_int)
    ! Debug
    !print*,'anni'
    !call print_det_one_dimension(T_anni_s(1,i),N_int)
  enddo
  do i = 1, nt_crea_s
    k = 1
    do j = 1, nVs
      if (det_crea(j,i) == 1) then
        tmp(k) = j + n_core_orb + nOs
        k = k + 1
      endif
    enddo
    call list_to_bitstring(T_crea_s(1,i),tmp,k-1,N_int)
    ! Debug
    !print*,'crea'
    !call print_det_one_dimension(T_crea_s(1,i),N_int)
  enddo

  ! gather anni and crea alpha
  k = 1
  do i_order = 0, max_order
    T_s_beg(i_order) = k
    do j = anni_s_beg(i_order), anni_s_end(i_order)
      do i = crea_s_beg(i_order), crea_s_end(i_order)
        T_s(:,1,k) = T_anni_s(:,j)
        T_s(:,2,k) = T_crea_s(:,i)
        ! Debug
        !print*,i_order
        !call print_det(T_s(1,1,k),N_int)
        k = k + 1
      enddo
    enddo
    T_s_end(i_order) = k-1
  enddo

  deallocate(det_anni,det_crea,T_anni_s,T_crea_s,tmp)
  
end
#+end_src

** Exp wf
#+begin_src f90 :comments org :tangle fcc.irp.f
subroutine exp_wf(max_k,max_order,ndet_a,det_bit_a,ndet_b,det_bit_b, &
     nT_a,T_a,nT_b,T_b,T,C3,Nint)

  use bitmasks
  
  implicit none

  integer, intent(in)            :: max_k,max_order,ndet_a, ndet_b, nT_a, nT_b, Nint
  integer(bit_kind), intent(in)  :: T_a(Nint,2,nT_a), T_b(Nint,2,nT_b)
  integer(bit_kind), intent(in)  :: det_bit_a(Nint,ndet_a), det_bit_b(Nint,ndet_b)
  double precision, intent(in)   :: T(nT_a,nT_b)
  
  double precision, intent(out)  :: C3(ndet_a,ndet_b)
  
  double precision, allocatable  :: C1(:,:), C2(:,:)
  integer(bit_kind), allocatable :: res1_a(:), res_a(:), res1_b(:), res_b(:)
  integer                        :: i,j,k,ta,tb,da,db,fact,exc_a,exc_b,degree,i_order
  integer, external              :: factorial
  logical                        :: ok
  double precision               :: phase

  allocate(C1(ndet_a,ndet_b),C2(ndet_a,ndet_b))

  ! Init
  C1 = 0d0
  C3 = 0d0
  C1(1,1) = 1d0
  C3(1,1) = 1d0

  allocate(res1_a(Nint),res_a(Nint),res1_b(Nint),res_b(Nint))

  do k = 1, max_k
    !print*,'k',k
    ! Init
    C2 = 0d0
    do db = 1, ndet_b
      do da = 1, ndet_a
        do tb = 1, nT_b
          do ta = 1, nT_a
        
            ! Annihilation part
            call apply_holes_bitstring(det_bit_b(1,db),T_b(1,1,tb),res1_b,ok,Nint)
            if (.not. ok) cycle
            
            ! Creation part
            call apply_particles_bitstring(res1_b,T_b(1,2,tb),res_b,ok,Nint)
            if (.not. ok) cycle
            
            ! Search res_b in det_b
            do i = 1, ndet_b
              call get_excitation_degree_spin(det_bit_b(1,i),res_b(1),degree,Nint)
              if (degree == 0) then
                exc_b = i
                exit
              endif
            enddo

            ! Apply exc and check
            ! Annihilation
            call apply_holes_bitstring(det_bit_a(1,da),T_a(1,1,ta),res1_a,ok,Nint)
            if (.not. ok) cycle
            ! Creation
            call apply_particles_bitstring(res1_a,T_a(1,2,ta),res_a,ok,Nint)
            if (.not. ok) cycle
        
            ! Search res_a in det_a
            do i = 1, ndet_a
              call get_excitation_degree_spin(det_bit_a(1,i),res_a(1),degree,Nint)
              if (degree == 0) then
                exc_a = i
                exit
              endif
            enddo
         
            ! Search res_b in det_b
            do i = 1, ndet_b
              call get_excitation_degree_spin(det_bit_b(1,i),res_b(1),degree,Nint)
              if (degree == 0) then
                exc_b = i
                exit
              endif
            enddo

            call get_phase((/det_bit_a(1,da),det_bit_b(1,db)/),(/res_a,res_b/),phase,Nint)
            ! Debug
            !print*,i_order,ta,tb
            !call print_det(T_a(1,1,ta),Nint)
            !call print_det(T_b(1,1,tb),Nint)
            !print*,''
            !call print_det((/det_bit_a(1,da),det_bit_b(1,db)/),Nint)
            !call print_det((/res_a,res_b/),Nint)
         
            C2(exc_a,exc_b) = C2(exc_a,exc_b) + C1(da,db) * T(ta,tb) * phase
          enddo
        enddo
      enddo
    enddo
    
    ! update
    fact = factorial(k)
    C3(:,:) = C3(:,:) + C2(:,:) * 1d0/dble(fact)
    C1 = C2
    
  enddo

  deallocate(C1,C2,res1_a,res_a,res1_b,res_b)

end
#+end_src

** Residue
#+begin_src f90 :comments org :tangle fcc.irp.f
subroutine compute_residue()

  implicit none


  
end
#+end_src
