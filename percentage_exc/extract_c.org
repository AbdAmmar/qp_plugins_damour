#+begin_src f90 :org comments :tangle extract_c.irp.f
program extract_c

  implicit none

  read_wf = .True.
  TOUCH read_wf

  call run_extract_c
  
end
#+end_src

#+begin_src f90 :org comments :tangle extract_c.irp.f
subroutine run_extract_c

  implicit none

  double precision, allocatable :: t1(:,:), t2(:,:,:,:)
  double precision, allocatable :: c1(:,:), c2(:,:,:,:), c3_bc(:,:,:,:), c4_abcd(:,:,:,:)
  double precision, allocatable :: tmp_coef(:), l_coef(:), abs_coef(:)
  integer :: nO,nV,nOa,nOb,nVa,nVb,nO_m,nV_m,nO_S(2),nV_S(2)
  integer, allocatable :: list_occ(:,:),list_vir(:,:),list_spin_occ(:,:), list_spin_vir(:,:), key(:)
  integer :: i,j,k,l,a,b,c,d,tmp_i,tmp_j,tmp_k,tmp_l,tmp_a,tmp_b,tmp_c,tmp_d,s1,s2,s3,s4
  integer :: idx_i,idx_j,idx_a,idx_b,idx_coef,nb_coef,up_bd,p1,p2,p3,p4,h1,h2,h3,h4, degree
  double precision :: thresh_coef, factor, norm, phase,s2_val
  integer(bit_kind) :: res1(N_int,2), res2(N_int,2), res3(N_int,2), res4(N_int,2), res5(N_int,2), res6(N_int,2), res7(N_int,2), exc(0:2,2,2)
  integer(bit_kind), allocatable :: det(:,:), tmp_det(:,:,:), l_det(:,:,:)
  logical :: ok

  PROVIDE s2_values
  
  allocate(det(N_int,2))

  det = psi_det(:,:,cc_ref)
  print*,'Reference determinant:'
  call print_det(det,N_int)
  
  thresh_coef = thresh_extract_c

  ! Total number of occ/vir spin orb
  nO = cc_nOab
  nV = cc_nVab
  !print*,nO,nV

  ! Number of occ/vir spin orb per spin
  nO_S = cc_nO_S
  nV_S = cc_nV_S
  !print*,nO_S,nV_S

  ! Maximal number of occ/vir 
  nO_m = cc_nO_m
  nV_m = cc_nV_m

  allocate(list_occ(nO_m,2), list_vir(nV_m,2))
  call extract_list_orb_spin(det,nO_m,nV_m,list_occ,list_vir)
  !print*,'occ a',list_occ(:,1)
  !print*,'occ b',list_occ(:,2)
  !print*,'vir a',list_vir(:,1)
  !print*,'vir b',list_vir(:,2)
  !print*,'nO_S',nO_s
  !print*,'nV_S',nV_s
  
  allocate(list_spin_occ(nO_m,2), list_spin_vir(nV_m,2))

  list_spin_occ = cc_list_occ_spin
  list_spin_vir = cc_list_vir_spin

  allocate(t1(nO,nV), t2(nO,nO,nV,nV))
  allocate(c1(nO,nV), c2(nO,nO,nV,nV), c3_bc(nO,nO,nO,nV), c4_abcd(nO,nO,nO,nO))

  print*, 'T1 and T2 read from disk'
  call read_t1(nO,nV,t1)
  call read_t2(nO,nV,t2)
  
  c1 = t1
  call extract_c2(nO,nV,t1,t2,c2)

  ! Count the number of coefficients s.t. |c| > thresh
  nb_coef = 1 ! Ref
  ! c1
  do s1 = 1, 2
    do tmp_a = 1, nV_S(s1)
      a = list_spin_vir(tmp_a,s1)
      do tmp_i = 1, nO_S(s1)
        i = list_spin_occ(tmp_i,s1)
        
        if (dabs(c1(i,a)) > thresh_coef) then
          nb_coef = nb_coef + 1
        endif
        
      enddo
    enddo
  enddo

  print*,'Nb C1 computed'  
  
  !c2
  do s1 = 1, 2
    do s2 = s1, 2
      do tmp_b = 1, nV_S(s2)
        b = list_spin_vir(tmp_b,s2)
        do tmp_a = 1, nV_S(s1)
          a = list_spin_vir(tmp_a,s1)
          if (s1 == s2 .and. a <= b) cycle
          do tmp_j = 1, nO_S(s2)
            j = list_spin_occ(tmp_j,s2)
            do tmp_i = 1, nO_S(s1)
              i = list_spin_occ(tmp_i,s1)
              if (s1 == s2 .and. i <= j) cycle
              
              if (dabs(c2(i,j,a,b)) > thresh_coef) then
                nb_coef = nb_coef + 1
              endif
              
            enddo
          enddo
        enddo
      enddo
    enddo
  enddo
  
  print*,'Nb C2 computed'  

  !c3
  if (extract_c3) then
    do s1 = 1, 2
      do s2 = s1, 2
        do s3 = s2, 2
          do tmp_c = 1, nV_S(s3)
            c = list_spin_vir(tmp_c,s3)
            do tmp_b = 1, nV_S(s2)
              b = list_spin_vir(tmp_b,s2)
              if (s2 == s3 .and. b <= c) cycle
              ! C3 for b and c fixed
              call extract_c3_bc(nO,nV,t1,t2,b,c,c3_bc)
              do tmp_a = 1, nV_S(s1)
                a = list_spin_vir(tmp_a,s1)
                if (s1 == s2 .and. a <= b) cycle
                do tmp_k = 1, nO_S(s3)
                  k = list_spin_occ(tmp_k,s3)
                  do tmp_j = 1, nO_S(s2)
                    j = list_spin_occ(tmp_j,s2)
                    if (s2 == s3 .and. j <= k) cycle
                    do tmp_i = 1, nO_S(s1)
                      i = list_spin_occ(tmp_i,s1)
                      if (s1 == s2 .and. i <= j) cycle
                      
                      if (dabs(c3_bc(i,j,k,a)) > thresh_coef) then
                        nb_coef = nb_coef + 1
                      endif
                      
                    enddo
                  enddo
                enddo
              enddo
            enddo
          enddo
        enddo
      enddo
    enddo
    print*,'Nb C3 computed'  
  endif
  
  !c4
  if (extract_c4) then
    do s1 = 1, 2
      do s2 = s1, 2
        do s3 = s2, 2
          do s4 = s3, 2
            do tmp_d = 1, nV_S(s4)
              d = list_spin_vir(tmp_d,s4)
              do tmp_c = 1, nV_S(s3)
                c = list_spin_vir(tmp_c,s3)
                if (s3 == s4 .and. c <= d) cycle
                do tmp_b = 1, nV_S(s2)
                  b = list_spin_vir(tmp_b,s2)
                  if (s2 == s3 .and. b <= c) cycle
                  do tmp_a = 1, nV_S(s1)
                    a = list_spin_vir(tmp_a,s1)
                    if (s1 == s2 .and. a <= b) cycle
                    ! C4 for a,b,c and d fixed
                    call extract_c4_abcd(nO,nV,t1,t2,a,b,c,d,c4_abcd)
                    do tmp_l = 1, nO_S(s4)
                      l = list_spin_occ(tmp_l,s4)
                      do tmp_k = 1, nO_S(s3)
                        k = list_spin_occ(tmp_k,s3)
                        if (s3 == s4 .and. k <= l) cycle
                        do tmp_j = 1, nO_S(s2)
                          j = list_spin_occ(tmp_j,s2)
                          if (s2 == s3 .and. j <= k) cycle
                          do tmp_i = 1, nO_S(s1)
                            i = list_spin_occ(tmp_i,s1)
                            if (s1 == s2 .and. i <= j) cycle
                            
                            if (dabs(c4_abcd(i,j,k,l)) > thresh_coef) then
                              nb_coef = nb_coef + 1
                            endif
                            
                          enddo
                        enddo
                      enddo
                    enddo
                  enddo
                enddo
              enddo
            enddo
          enddo
        enddo
      enddo
    enddo
    print*,'Nb C4 computed'  
  endif

  print*,''
  print*,'Nb of coef', nb_coef

  ! Allocate and fill 
  allocate(tmp_coef(nb_coef), abs_coef(nb_coef), tmp_det(N_int,2,nb_coef))

  ! Ref
  tmp_coef(1) = 1d0
  tmp_det(:,:,1) = det
  
  idx_coef = 2
  ! c1
  do s1 = 1, 2
    do tmp_a = 1, nV_S(s1)
      a = list_spin_vir(tmp_a,s1)
      p1 = list_vir(tmp_a,s1)
      do tmp_i = 1, nO_S(s1)
        i = list_spin_occ(tmp_i,s1)
        h1 = list_occ(tmp_i,s1)
        
        if (dabs(c1(i,a)) > thresh_coef) then
          call apply_hole(det, s1, h1, res1, ok, N_int)
          call apply_particle(res1, s1, p1, tmp_det(1,1,idx_coef), ok, N_int)
          call get_excitation(det,tmp_det(1,1,idx_coef),exc,degree,phase,N_int)
          tmp_coef(idx_coef) = c1(i,a) * phase
          idx_coef = idx_coef + 1
        endif
        
      enddo
    enddo
  enddo

  print*,'C1: Done'
  
  !c2
  do s1 = 1, 2
    do s2 = s1, 2
      do tmp_b = 1, nV_S(s2)
        b = list_spin_vir(tmp_b,s2)
        p2 = list_vir(tmp_b,s2)
        do tmp_a = 1, nV_S(s1)
          a = list_spin_vir(tmp_a,s1)
          p1 = list_vir(tmp_a,s1)
          if (s1 == s2 .and. a <= b) cycle
          do tmp_j = 1, nO_S(s2)
            j = list_spin_occ(tmp_j,s2)
            h2 = list_occ(tmp_j,s2)
            do tmp_i = 1, nO_S(s1)
              i = list_spin_occ(tmp_i,s1)
              h1 = list_occ(tmp_i,s1)
              if (s1 == s2 .and. i <= j) cycle
              
              if (dabs(c2(i,j,a,b)) > thresh_coef) then
                call apply_hole(det, s1, h1, res1, ok, N_int)
                call apply_hole(res1, s2, h2, res2, ok, N_int)
                call apply_particle(res2, s1, p1, res3, ok, N_int)
                call apply_particle(res3, s2, p2, tmp_det(1,1,idx_coef), ok, N_int)
                call get_excitation(det,tmp_det(1,1,idx_coef),exc,degree,phase,N_int)
                tmp_coef(idx_coef) = c2(i,j,a,b) * phase
                idx_coef = idx_coef + 1
              endif
              
            enddo
          enddo
        enddo
      enddo
    enddo
  enddo

  print*,'C2: Done'
  
  !c3
  if (extract_c3) then
    do s1 = 1, 2
      do s2 = s1, 2
        do s3 = s2, 2
          do tmp_c = 1, nV_S(s3)
            c = list_spin_vir(tmp_c,s3)
            p3 = list_vir(tmp_c,s3)
            do tmp_b = 1, nV_S(s2)
              b = list_spin_vir(tmp_b,s2)
              p2 = list_vir(tmp_b,s2)
              if (s2 == s3 .and. b <= c) cycle
              ! C3 for b and c fixed
              call extract_c3_bc(nO,nV,t1,t2,b,c,c3_bc)
              do tmp_a = 1, nV_S(s1)
                a = list_spin_vir(tmp_a,s1)
                p1 = list_vir(tmp_a,s1)
                if (s1 == s2 .and. a <= b) cycle
                do tmp_k = 1, nO_S(s3)
                   k = list_spin_occ(tmp_k,s3)
                   h3 = list_occ(tmp_k,s3)
                  do tmp_j = 1, nO_S(s2)
                    j = list_spin_occ(tmp_j,s2)
                    h2 = list_occ(tmp_j,s2)
                    if (s2 == s3 .and. j <= k) cycle
                    do tmp_i = 1, nO_S(s1)
                      i = list_spin_occ(tmp_i,s1)
                      h1 = list_occ(tmp_i,s1)
                      if (s1 == s2 .and. i <= j) cycle
                      
                      if (dabs(c3_bc(i,j,k,a)) > thresh_coef) then
                        call apply_hole(det, s1, h1, res1, ok, N_int)
                        call apply_hole(res1, s2, h2, res2, ok, N_int)
                        call apply_hole(res2, s3, h3, res3, ok, N_int)
                        call apply_particle(res3, s1, p1, res4, ok, N_int)
                        call apply_particle(res4, s2, p2, res5, ok, N_int)
                        call apply_particle(res5, s3, p3, tmp_det(1,1,idx_coef), ok, N_int)
                        !call get_excitation(psi_det(1,1,1),tmp_det(1,1,idx_coef),exc,degree,phase,N_int)
                        call get_phase_general(det,tmp_det(1,1,idx_coef),phase,degree,N_int)
                        tmp_coef(idx_coef) = c3_bc(i,j,k,a) * phase
                        idx_coef = idx_coef + 1
                      endif
                      
                    enddo
                  enddo
                enddo
              enddo
            enddo
          enddo
        enddo
      enddo
    enddo
    print*,'C3: Done'
  endif
  
  !c4
  if (extract_c4) then
    do s1 = 1, 2
      do s2 = s1, 2
        do s3 = s2, 2
          do s4 = s3, 2
            do tmp_d = 1, nV_S(s4)
              d = list_spin_vir(tmp_d,s4)
              p4 = list_vir(tmp_d,s4)
              do tmp_c = 1, nV_S(s3)
                c = list_spin_vir(tmp_c,s3)
                p3 = list_vir(tmp_c,s3)
                if (s3 == s4 .and. c <= d) cycle
                do tmp_b = 1, nV_S(s2)
                  b = list_spin_vir(tmp_b,s2)
                  p2 = list_vir(tmp_b,s2)
                  if (s2 == s3 .and. b <= c) cycle
                  do tmp_a = 1, nV_S(s1)
                    a = list_spin_vir(tmp_a,s1)
                    p1 = list_vir(tmp_a,s1)
                    if (s1 == s2 .and. a <= b) cycle
                    ! C4 for a,b,c and d fixed
                    call extract_c4_abcd(nO,nV,t1,t2,a,b,c,d,c4_abcd)
                    do tmp_l = 1, nO_S(s4)
                      l = list_spin_occ(tmp_l,s4)
                      h4 = list_occ(tmp_l,s4)
                      do tmp_k = 1, nO_S(s3)
                         k = list_spin_occ(tmp_k,s3)
                         h3 = list_occ(tmp_k,s3)
                         if (s3 == s4 .and. k <= l) cycle
                        do tmp_j = 1, nO_S(s2)
                          j = list_spin_occ(tmp_j,s2)
                          h2 = list_occ(tmp_j,s2)
                          if (s2 == s3 .and. j <= k) cycle
                          do tmp_i = 1, nO_S(s1)
                            i = list_spin_occ(tmp_i,s1)
                            h1 = list_occ(tmp_i,s1)
                            if (s1 == s2 .and. i <= j) cycle
                            
                            if (dabs(c4_abcd(i,j,k,l)) > thresh_coef) then
                              call apply_hole(det, s1, h1, res1, ok, N_int)
                              call apply_hole(res1, s2, h2, res2, ok, N_int)
                              call apply_hole(res2, s3, h3, res3, ok, N_int)
                              call apply_hole(res3, s4, h4, res4, ok, N_int)
                              call apply_particle(res4, s1, p1, res5, ok, N_int)
                              call apply_particle(res5, s2, p2, res6, ok, N_int)
                              call apply_particle(res6, s3, p3, res7, ok, N_int)
                              call apply_particle(res7, s4, p4, tmp_det(1,1,idx_coef), ok, N_int)
                              !call get_excitation(psi_det(1,1,1),tmp_det(1,1,idx_coef),exc,degree,phase,N_int)
                              call get_phase_general(det,tmp_det(1,1,idx_coef),phase,degree,N_int)
                              tmp_coef(idx_coef) = c4_abcd(i,j,k,l) * phase
                              idx_coef = idx_coef + 1
                            endif
                            
                          enddo
                        enddo
                      enddo
                    enddo
                  enddo
                enddo
              enddo
            enddo
          enddo
        enddo
      enddo
    enddo
    print*,'C4: Done'
  endif

  deallocate(t1,c1,t2,c2,c3_bc,c4_abcd)

  ! Sort the det wrt their coef
  allocate(l_coef(nb_coef), l_det(N_int,2,nb_coef))
  abs_coef = dabs(tmp_coef)
  allocate(key(nb_coef))
  do i = 1, nb_coef
    key(i) = i
  enddo
  call dsort(-abs_coef, key, nb_coef)
  do i = 1, nb_coef
    l_coef(i)    = tmp_coef(key(i))
    l_det(:,:,i) = tmp_det(:,:,key(i))
  enddo
  deallocate(key,tmp_coef,abs_coef,tmp_det)

  ! Normalization
  norm = 0d0
  do i = 1, nb_coef
    norm = norm + l_coef(i)**2
  enddo
  norm = dsqrt(norm)
  factor = 1d0 / norm

  l_coef = l_coef * factor

  ! print
  print*,'N_det', nb_coef
  !do i = 1, nb_coef
  !  print*,l_coef(i)
  !  call print_det(l_det(1,1,i),N_int)
  !  print*,''
  !enddo

  call overlap_wf(nb_coef,l_det,l_coef)

  if (write_cc_wf) then
    ! Save the wave function
    print*,'Save the wave function...'
    ! Save a one det wf
    call save_det_cc(1, N_states, l_det, l_coef)
    ! Just to have a large enough psi_det vector...
    if (nb_coef > N_det) then
      call fill_H_apply_buffer_no_selection(nb_coef-N_det,l_det,N_int,0)
      call copy_H_apply_buffer_to_wf
      SOFT_TOUCH psi_det psi_coef N_det !N_det_beta_unique N_det_alpha_unique psi_det_alpha_unique psi_det_beta_unique
    endif
    ! Save the wave function
    call save_det_cc(nb_coef, N_states, l_det, l_coef)
    print*,'Done'
  endif

  call u_0_S2_u_0(s2_val,l_coef,nb_coef,l_det,N_int,1,nb_coef)
  print*,''
  print*,'S^2 =', s2_val
  print*,''

  deallocate(l_coef,l_det)

end
#+end_src

#+begin_src f90 :org comments :tangle extract_c.irp.f
subroutine extract_c2(nO,nV,t1,t2,c2)

  implicit none

  integer, intent(in)           :: nO,nV
  double precision, intent(in)  :: t1(nO,nV), t2(nO,nO,nV,nV)
  double precision, intent(out) :: c2(nO,nO,nV,nV)
  integer                       :: i,j,a,b

  do b = 1, nV
    do a = 1, nV
      do j = 1, nO
        do i = 1, nO
          c2(i,j,a,b) = t2(i,j,a,b) + t1(i,a) * t1(j,b) - t1(i,b) * t1(j,a)
        enddo
      enddo
    enddo
  enddo
  
end
#+end_src

#+begin_src f90 :org comments :tangle extract_c.irp.f
subroutine extract_c3(nO,nV,t1,t2,c3)

  implicit none

  integer, intent(in)           :: nO,nV
  double precision, intent(in)  :: t1(nO,nV), t2(nO,nO,nV,nV)
  double precision, intent(out) :: c3(nO,nO,nO,nV,nV,nV)
  integer                       :: i,j,k,a,b,c

  do c = 1, nV
    do b = 1, nV
      do a = 1, nV
        do k = 1, nO
          do j = 1, nO
            do i = 1, nO
              c3(i,j,k,a,b,c) = - ( &
               t1(i,c) * t1(j,b) * t1(k,a) - t1(i,b) * t1(j,c) * t1(k,a) - & 
               t1(i,c) * t1(j,a) * t1(k,b) + t1(i,a) * t1(j,c) * t1(k,b) + &
               t1(i,b) * t1(j,a) * t1(k,c) - t1(i,a) * t1(j,b) * t1(k,c) - &
               t1(k,c) * t2(i,j,a,b) + t1(k,b) * t2(i,j,a,c) - &
               t1(k,a) * t2(i,j,b,c) + t1(j,c) * t2(i,k,a,b) - &
               t1(j,b) * t2(i,k,a,c) + t1(j,a) * t2(i,k,b,c) - &
               t1(i,c) * t2(j,k,a,b) + t1(i,b) * t2(j,k,a,c) - &
               t1(i,a) * t2(j,k,b,c))
            enddo
          enddo
        enddo
      enddo
    enddo
  enddo

  
end
#+end_src

#+begin_src f90 :org comments :tangle extract_c.irp.f
subroutine extract_c3_bc(nO,nV,t1,t2,b,c,c3_bc)

  implicit none

  integer, intent(in) :: nO,nV,b,c
  double precision, intent(in) :: t1(nO,nV), t2(nO,nO,nV,nV)
  
  double precision, intent(out) :: c3_bc(nO,nO,nO,nV)

  integer :: i,j,k,a

  do a = 1, nV
    do k = 1, nO
      do j = 1, nO
        do i = 1, nO             
          c3_bc(i,j,k,a) = - t1(i, c) * t1(j, b) * t1(k, a) &
          + t1(i, b) * t1(j, c) * t1(k, a) + t1(i, c) * t1(j, a) * t1(k, b) &
          - t1(i, a) * t1(j, c) * t1(k, b) - t1(i, b) * t1(j, a) * t1(k, c) &
          + t1(i, a) * t1(j, b) * t1(k, c) + t1(k, c) * t2(i, j, a, b) &
          - t1(k, b) * t2(i, j, a, c) + t1(k, a) * t2(i, j, b, c) &
          - t1(j, c) * t2(i, k, a, b) + t1(j, b) * t2(i, k, a, c) &
          - t1(j, a) * t2(i, k, b, c) + t1(i, c) * t2(j, k, a, b) &
          - t1(i, b) * t2(j, k, a, c) + t1(i, a) * t2(j, k, b, c)
        enddo
      enddo
    enddo
  enddo

end
#+end_src

#+begin_src f90 :org comments :tangle extract_c.irp.f
subroutine extract_c4_abcd(nO,nV,t1,t2,a,b,c,d,c4_abcd)

  implicit none

  integer, intent(in) :: nO,nV,a,b,c,d
  double precision, intent(in) :: t1(nO,nV), t2(nO,nO,nV,nV)
  
  double precision, intent(out) :: c4_abcd(nO,nO,nO,nO)

  integer :: i,j,k,l

  do l = 1, nO
    do k = 1, nO
      do j = 1, nO
        do i = 1, nO             
          c4_abcd(i,j,k,l) = &
            t1(i, d) * t1(j, c) * t1(k, b) * t1(l, a) - & 
            t1(i, c) * t1(j, d) * t1(k, b) * t1(l, a) - & 
            t1(i, d) * t1(j, b) * t1(k, c) * t1(l, a) + & 
            t1(i, b) * t1(j, d) * t1(k, c) * t1(l, a) + & 
            t1(i, c) * t1(j, b) * t1(k, d) * t1(l, a) - & 
            t1(i, b) * t1(j, c) * t1(k, d) * t1(l, a) - & 
            t1(i, d) * t1(j, c) * t1(k, a) * t1(l, b) + & 
            t1(i, c) * t1(j, d) * t1(k, a) * t1(l, b) + & 
            t1(i, d) * t1(j, a) * t1(k, c) * t1(l, b) - & 
            t1(i, a) * t1(j, d) * t1(k, c) * t1(l, b) - & 
            t1(i, c) * t1(j, a) * t1(k, d) * t1(l, b) + & 
            t1(i, a) * t1(j, c) * t1(k, d) * t1(l, b) + & 
            t1(i, d) * t1(j, b) * t1(k, a) * t1(l, c) - & 
            t1(i, b) * t1(j, d) * t1(k, a) * t1(l, c) - & 
            t1(i, d) * t1(j, a) * t1(k, b) * t1(l, c) + & 
            t1(i, a) * t1(j, d) * t1(k, b) * t1(l, c) + & 
            t1(i, b) * t1(j, a) * t1(k, d) * t1(l, c) - & 
            t1(i, a) * t1(j, b) * t1(k, d) * t1(l, c) - & 
            t1(i, c) * t1(j, b) * t1(k, a) * t1(l, d) + & 
            t1(i, b) * t1(j, c) * t1(k, a) * t1(l, d) + & 
            t1(i, c) * t1(j, a) * t1(k, b) * t1(l, d) - & 
            t1(i, a) * t1(j, c) * t1(k, b) * t1(l, d) - & 
            t1(i, b) * t1(j, a) * t1(k, c) * t1(l, d) + & 
            t1(i, a) * t1(j, b) * t1(k, c) * t1(l, d) - & 
            t1(k, d) * t1(l, c) * t2(i, j, a, b) + & 
            t1(k, c) * t1(l, d) * t2(i, j, a, b) + & 
            t1(k, d) * t1(l, b) * t2(i, j, a, c) - & 
            t1(k, b) * t1(l, d) * t2(i, j, a, c) - & 
            t1(k, c) * t1(l, b) * t2(i, j, a, d) + & 
            t1(k, b) * t1(l, c) * t2(i, j, a, d) - & 
            t1(k, d) * t1(l, a) * t2(i, j, b, c) + & 
            t1(k, a) * t1(l, d) * t2(i, j, b, c) + & 
            t1(k, c) * t1(l, a) * t2(i, j, b, d) - & 
            t1(k, a) * t1(l, c) * t2(i, j, b, d) - & 
            t1(k, b) * t1(l, a) * t2(i, j, c, d) + & 
            t1(k, a) * t1(l, b) * t2(i, j, c, d) + & 
            t1(j, d) * t1(l, c) * t2(i, k, a, b) - & 
            t1(j, c) * t1(l, d) * t2(i, k, a, b) - & 
            t1(j, d) * t1(l, b) * t2(i, k, a, c) + & 
            t1(j, b) * t1(l, d) * t2(i, k, a, c) + & 
            t1(j, c) * t1(l, b) * t2(i, k, a, d) - & 
            t1(j, b) * t1(l, c) * t2(i, k, a, d) + & 
            t1(j, d) * t1(l, a) * t2(i, k, b, c) - & 
            t1(j, a) * t1(l, d) * t2(i, k, b, c) - & 
            t1(j, c) * t1(l, a) * t2(i, k, b, d) + & 
            t1(j, a) * t1(l, c) * t2(i, k, b, d) + & 
            t1(j, b) * t1(l, a) * t2(i, k, c, d) - & 
            t1(j, a) * t1(l, b) * t2(i, k, c, d) - & 
            t1(j, d) * t1(k, c) * t2(i, l, a, b) + & 
            t1(j, c) * t1(k, d) * t2(i, l, a, b) + & 
            t1(j, d) * t1(k, b) * t2(i, l, a, c) - & 
            t1(j, b) * t1(k, d) * t2(i, l, a, c) - & 
            t1(j, c) * t1(k, b) * t2(i, l, a, d) + & 
            t1(j, b) * t1(k, c) * t2(i, l, a, d) - & 
            t1(j, d) * t1(k, a) * t2(i, l, b, c) + & 
            t1(j, a) * t1(k, d) * t2(i, l, b, c) + & 
            t1(j, c) * t1(k, a) * t2(i, l, b, d) - & 
            t1(j, a) * t1(k, c) * t2(i, l, b, d) - & 
            t1(j, b) * t1(k, a) * t2(i, l, c, d) + & 
            t1(j, a) * t1(k, b) * t2(i, l, c, d) - & 
            t1(i, d) * t1(l, c) * t2(j, k, a, b) + & 
            t1(i, c) * t1(l, d) * t2(j, k, a, b) + & 
            t2(i, l, c, d) * t2(j, k, a, b) +      & 
            t1(i, d) * t1(l, b) * t2(j, k, a, c) - & 
            t1(i, b) * t1(l, d) * t2(j, k, a, c) - &
            t2(i, l, b, d) * t2(j, k, a, c) -      &
            t1(i, c) * t1(l, b) * t2(j, k, a, d) + & 
            t1(i, b) * t1(l, c) * t2(j, k, a, d) + &
            t2(i, l, b, c) * t2(j, k, a, d) -      &
            t1(i, d) * t1(l, a) * t2(j, k, b, c) + & 
            t1(i, a) * t1(l, d) * t2(j, k, b, c) + &
            t2(i, l, a, d) * t2(j, k, b, c) +      &
            t1(i, c) * t1(l, a) * t2(j, k, b, d) - & 
            t1(i, a) * t1(l, c) * t2(j, k, b, d) - &
            t2(i, l, a, c) * t2(j, k, b, d) -      &
            t1(i, b) * t1(l, a) * t2(j, k, c, d) + & 
            t1(i, a) * t1(l, b) * t2(j, k, c, d) + &
            t2(i, l, a, b) * t2(j, k, c, d) +      &
            t1(i, d) * t1(k, c) * t2(j, l, a, b) - & 
            t1(i, c) * t1(k, d) * t2(j, l, a, b) - &
            t2(i, k, c, d) * t2(j, l, a, b) -      &
            t1(i, d) * t1(k, b) * t2(j, l, a, c) + & 
            t1(i, b) * t1(k, d) * t2(j, l, a, c) + &
            t2(i, k, b, d) * t2(j, l, a, c) +      &
            t1(i, c) * t1(k, b) * t2(j, l, a, d) - & 
            t1(i, b) * t1(k, c) * t2(j, l, a, d) - &
            t2(i, k, b, c) * t2(j, l, a, d) +      &
            t1(i, d) * t1(k, a) * t2(j, l, b, c) - & 
            t1(i, a) * t1(k, d) * t2(j, l, b, c) - &
            t2(i, k, a, d) * t2(j, l, b, c) -      &
            t1(i, c) * t1(k, a) * t2(j, l, b, d) + & 
            t1(i, a) * t1(k, c) * t2(j, l, b, d) + &
            t2(i, k, a, c) * t2(j, l, b, d) +      &
            t1(i, b) * t1(k, a) * t2(j, l, c, d) - & 
            t1(i, a) * t1(k, b) * t2(j, l, c, d) - &
            t2(i, k, a, b) * t2(j, l, c, d) -      &
            t1(i, d) * t1(j, c) * t2(k, l, a, b) + &
            t1(i, c) * t1(j, d) * t2(k, l, a, b) + &
            t2(i, j, c, d) * t2(k, l, a, b) +      &
            t1(i, d) * t1(j, b) * t2(k, l, a, c) - & 
            t1(i, b) * t1(j, d) * t2(k, l, a, c) - &
            t2(i, j, b, d) * t2(k, l, a, c) -      &
            t1(i, c) * t1(j, b) * t2(k, l, a, d) + &
            t1(i, b) * t1(j, c) * t2(k, l, a, d) + &
            t2(i, j, b, c) * t2(k, l, a, d) -      &
            t1(i, d) * t1(j, a) * t2(k, l, b, c) + & 
            t1(i, a) * t1(j, d) * t2(k, l, b, c) + &
            t2(i, j, a, d) * t2(k, l, b, c) +      &
            t1(i, c) * t1(j, a) * t2(k, l, b, d) - &
            t1(i, a) * t1(j, c) * t2(k, l, b, d) - &
            t2(i, j, a, c) * t2(k, l, b, d) -      &
            t1(i, b) * t1(j, a) * t2(k, l, c, d) + & 
            t1(i, a) * t1(j, b) * t2(k, l, c, d) + &
            t2(i, j, a, b) * t2(k, l, c, d)
        enddo
      enddo
    enddo
  enddo

end
#+end_src

#+begin_src
c1(i,a) = t1(i, a)

c2(i,j,a,b) = -t1(i, b) * t1(j, a) + t1(i, a) * t1(j, b) + 
  t2(i, j, a, b)

c3(i,j,k,a,b,c) = -t1(i, c) * t1(j, b) * t1(k, a) + 
  t1(i, b) * t1(j, c) * t1(k, a) + t1(i, c) * t1(j, a) * t1(k, b) - 
  t1(i, a) * t1(j, c) * t1(k, b) - t1(i, b) * t1(j, a) * t1(k, c) + 
  t1(i, a) * t1(j, b) * t1(k, c) + t1(k, c) * t2(i, j, a, b) - 
  t1(k, b) * t2(i, j, a, c) + t1(k, a) * t2(i, j, b, c) - 
  t1(j, c) * t2(i, k, a, b) + t1(j, b) * t2(i, k, a, c) - 
  t1(j, a) * t2(i, k, b, c) + t1(i, c) * t2(j, k, a, b) - 
  t1(i, b) * t2(j, k, a, c) + t1(i, a) * t2(j, k, b, c) + 
  t3(i, j, k, a, b, c)

c4(i,j,k,l,a,b,c,d) =
  t1(i, d) * t1(j, c) * t1(k, b) * t1(l, a) - 
  t1(i, c) * t1(j, d) * t1(k, b) * t1(l, a) - 
  t1(i, d) * t1(j, b) * t1(k, c) * t1(l, a) + 
  t1(i, b) * t1(j, d) * t1(k, c) * t1(l, a) + 
  t1(i, c) * t1(j, b) * t1(k, d) * t1(l, a) - 
  t1(i, b) * t1(j, c) * t1(k, d) * t1(l, a) - 
  t1(i, d) * t1(j, c) * t1(k, a) * t1(l, b) + 
  t1(i, c) * t1(j, d) * t1(k, a) * t1(l, b) + 
  t1(i, d) * t1(j, a) * t1(k, c) * t1(l, b) - 
  t1(i, a) * t1(j, d) * t1(k, c) * t1(l, b) - 
  t1(i, c) * t1(j, a) * t1(k, d) * t1(l, b) + 
  t1(i, a) * t1(j, c) * t1(k, d) * t1(l, b) + 
  t1(i, d) * t1(j, b) * t1(k, a) * t1(l, c) - 
  t1(i, b) * t1(j, d) * t1(k, a) * t1(l, c) - 
  t1(i, d) * t1(j, a) * t1(k, b) * t1(l, c) + 
  t1(i, a) * t1(j, d) * t1(k, b) * t1(l, c) + 
  t1(i, b) * t1(j, a) * t1(k, d) * t1(l, c) - 
  t1(i, a) * t1(j, b) * t1(k, d) * t1(l, c) - 
  t1(i, c) * t1(j, b) * t1(k, a) * t1(l, d) + 
  t1(i, b) * t1(j, c) * t1(k, a) * t1(l, d) + 
  t1(i, c) * t1(j, a) * t1(k, b) * t1(l, d) - 
  t1(i, a) * t1(j, c) * t1(k, b) * t1(l, d) - 
  t1(i, b) * t1(j, a) * t1(k, c) * t1(l, d) + 
  t1(i, a) * t1(j, b) * t1(k, c) * t1(l, d) - 
  t1(k, d) * t1(l, c) * t2(i, j, a, b) + 
  t1(k, c) * t1(l, d) * t2(i, j, a, b) + 
  t1(k, d) * t1(l, b) * t2(i, j, a, c) - 
  t1(k, b) * t1(l, d) * t2(i, j, a, c) - 
  t1(k, c) * t1(l, b) * t2(i, j, a, d) + 
  t1(k, b) * t1(l, c) * t2(i, j, a, d) - 
  t1(k, d) * t1(l, a) * t2(i, j, b, c) + 
  t1(k, a) * t1(l, d) * t2(i, j, b, c) + 
  t1(k, c) * t1(l, a) * t2(i, j, b, d) - 
  t1(k, a) * t1(l, c) * t2(i, j, b, d) - 
  t1(k, b) * t1(l, a) * t2(i, j, c, d) + 
  t1(k, a) * t1(l, b) * t2(i, j, c, d) + 
  t1(j, d) * t1(l, c) * t2(i, k, a, b) - 
  t1(j, c) * t1(l, d) * t2(i, k, a, b) - 
  t1(j, d) * t1(l, b) * t2(i, k, a, c) + 
  t1(j, b) * t1(l, d) * t2(i, k, a, c) + 
  t1(j, c) * t1(l, b) * t2(i, k, a, d) - 
  t1(j, b) * t1(l, c) * t2(i, k, a, d) + 
  t1(j, d) * t1(l, a) * t2(i, k, b, c) - 
  t1(j, a) * t1(l, d) * t2(i, k, b, c) - 
  t1(j, c) * t1(l, a) * t2(i, k, b, d) + 
  t1(j, a) * t1(l, c) * t2(i, k, b, d) + 
  t1(j, b) * t1(l, a) * t2(i, k, c, d) - 
  t1(j, a) * t1(l, b) * t2(i, k, c, d) - 
  t1(j, d) * t1(k, c) * t2(i, l, a, b) + 
  t1(j, c) * t1(k, d) * t2(i, l, a, b) + 
  t1(j, d) * t1(k, b) * t2(i, l, a, c) - 
  t1(j, b) * t1(k, d) * t2(i, l, a, c) - 
  t1(j, c) * t1(k, b) * t2(i, l, a, d) + 
  t1(j, b) * t1(k, c) * t2(i, l, a, d) - 
  t1(j, d) * t1(k, a) * t2(i, l, b, c) + 
  t1(j, a) * t1(k, d) * t2(i, l, b, c) + 
  t1(j, c) * t1(k, a) * t2(i, l, b, d) - 
  t1(j, a) * t1(k, c) * t2(i, l, b, d) - 
  t1(j, b) * t1(k, a) * t2(i, l, c, d) + 
  t1(j, a) * t1(k, b) * t2(i, l, c, d) - 
  t1(i, d) * t1(l, c) * t2(j, k, a, b) + 
  t1(i, c) * t1(l, d) * t2(j, k, a, b) + t2(i, l, c, d) * t2(j, k, a, b) + 
  t1(i, d) * t1(l, b) * t2(j, k, a, c) - 
  t1(i, b) * t1(l, d) * t2(j, k, a, c) - t2(i, l, b, d) * t2(j, k, a, c) - 
  t1(i, c) * t1(l, b) * t2(j, k, a, d) + 
  t1(i, b) * t1(l, c) * t2(j, k, a, d) + t2(i, l, b, c) * t2(j, k, a, d) - 
  t1(i, d) * t1(l, a) * t2(j, k, b, c) + 
  t1(i, a) * t1(l, d) * t2(j, k, b, c) + t2(i, l, a, d) * t2(j, k, b, c) + 
  t1(i, c) * t1(l, a) * t2(j, k, b, d) - 
  t1(i, a) * t1(l, c) * t2(j, k, b, d) - t2(i, l, a, c) * t2(j, k, b, d) - 
  t1(i, b) * t1(l, a) * t2(j, k, c, d) + 
  t1(i, a) * t1(l, b) * t2(j, k, c, d) + t2(i, l, a, b) * t2(j, k, c, d) + 
  t1(i, d) * t1(k, c) * t2(j, l, a, b) - 
  t1(i, c) * t1(k, d) * t2(j, l, a, b) - t2(i, k, c, d) * t2(j, l, a, b) - 
  t1(i, d) * t1(k, b) * t2(j, l, a, c) + 
  t1(i, b) * t1(k, d) * t2(j, l, a, c) + t2(i, k, b, d) * t2(j, l, a, c) + 
  t1(i, c) * t1(k, b) * t2(j, l, a, d) - 
  t1(i, b) * t1(k, c) * t2(j, l, a, d) - t2(i, k, b, c) * t2(j, l, a, d) + 
  t1(i, d) * t1(k, a) * t2(j, l, b, c) - 
  t1(i, a) * t1(k, d) * t2(j, l, b, c) - t2(i, k, a, d) * t2(j, l, b, c) - 
  t1(i, c) * t1(k, a) * t2(j, l, b, d) + 
  t1(i, a) * t1(k, c) * t2(j, l, b, d) + t2(i, k, a, c) * t2(j, l, b, d) + 
  t1(i, b) * t1(k, a) * t2(j, l, c, d) - 
  t1(i, a) * t1(k, b) * t2(j, l, c, d) - t2(i, k, a, b) * t2(j, l, c, d) - 
  t1(i, d) * t1(j, c) * t2(k, l, a, b) + 
  t1(i, c) * t1(j, d) * t2(k, l, a, b) + t2(i, j, c, d) * t2(k, l, a, b) + 
  t1(i, d) * t1(j, b) * t2(k, l, a, c) - 
  t1(i, b) * t1(j, d) * t2(k, l, a, c) - t2(i, j, b, d) * t2(k, l, a, c) - 
  t1(i, c) * t1(j, b) * t2(k, l, a, d) + 
  t1(i, b) * t1(j, c) * t2(k, l, a, d) + t2(i, j, b, c) * t2(k, l, a, d) - 
  t1(i, d) * t1(j, a) * t2(k, l, b, c) + 
  t1(i, a) * t1(j, d) * t2(k, l, b, c) + t2(i, j, a, d) * t2(k, l, b, c) + 
  t1(i, c) * t1(j, a) * t2(k, l, b, d) - 
  t1(i, a) * t1(j, c) * t2(k, l, b, d) - t2(i, j, a, c) * t2(k, l, b, d) - 
  t1(i, b) * t1(j, a) * t2(k, l, c, d) + 
  t1(i, a) * t1(j, b) * t2(k, l, c, d) + t2(i, j, a, b) * t2(k, l, c, d) + 
  t1(l, d) * t3(i, j, k, a, b, c) - t1(l, c) * t3(i, j, k, a, b, d) + 
  t1(l, b) * t3(i, j, k, a, c, d) - t1(l, a) * t3(i, j, k, b, c, d) - 
  t1(k, d) * t3(i, j, l, a, b, c) + t1(k, c) * t3(i, j, l, a, b, d) - 
  t1(k, b) * t3(i, j, l, a, c, d) + t1(k, a) * t3(i, j, l, b, c, d) + 
  t1(j, d) * t3(i, k, l, a, b, c) - t1(j, c) * t3(i, k, l, a, b, d) + 
  t1(j, b) * t3(i, k, l, a, c, d) - t1(j, a) * t3(i, k, l, b, c, d) - 
  t1(i, d) * t3(j, k, l, a, b, c) + t1(i, c) * t3(j, k, l, a, b, d) - 
  t1(i, b) * t3(j, k, l, a, c, d) + t1(i, a) * t3(j, k, l, b, c, d) + 
  t4(i, j, k, l, a, b, c, d)

#+end_src

#+begin_src f90 :comments org :tangle extract_c.irp.f
subroutine save_det_cc(new_ndet, Nstates, list_det_sorted, list_coef_sorted)

  implicit none

  BEGIN_DOC
  ! Save the cc wf by putting the computed ci coefficients in the first state
  ! and 0 in the other states
  END_DOC
  
  integer, intent(in) :: new_ndet, Nstates
  integer(bit_kind), intent(in) :: list_det_sorted(new_ndet)
  double precision, intent(in) :: list_coef_sorted(new_ndet)
  
  integer(bit_kind), allocatable :: psi_det_tmp(:,:,:)
  double precision, allocatable :: psi_coef_tmp(:,:)
  integer :: i,j
  double precision :: accu(Nstates)
  
  allocate(psi_det_tmp(N_int,2,new_ndet),psi_coef_tmp(new_ndet, Nstates))
 
  accu = 0.d0
  do i = 1, new_ndet
    psi_coef_tmp(i,1) = list_coef_sorted(i)
    accu(1) += psi_coef_tmp(i,1) **2
    do j = 2, N_states
      psi_coef_tmp(i,j) = 0d0
      accu(j) += psi_coef_tmp(i,j) **2
   enddo
  enddo
  accu(1) = 1d0/sqrt(accu(1))
  do j = 2, Nstates
   accu(j) = 1.d0
  enddo
  do j = 1, Nstates
   do i = 1, new_ndet
    psi_coef_tmp(i,j) = psi_coef_tmp(i,j) * accu(j)
   enddo
  enddo
 
  call save_wavefunction_general(new_ndet,Nstates,list_det_sorted,size(psi_coef_tmp,1),psi_coef_tmp)
  
end
#+end_src

#+begin_src f90 :comments org :tangle extract_c.irp.f
subroutine overlap_wf(Ndet, list_det, list_coef)

  use omp_lib
  
  implicit none

  integer, intent(in)            :: Ndet
  integer(bit_kind), intent(in)  :: list_det(N_int,2,Ndet)
  double precision, intent(in)   :: list_coef(Ndet)

  double precision               :: accu, overlap
  integer                        :: n_threads, num
  integer                        :: i,j,s,degree, count, tot_count, max_exc
  integer, allocatable           :: idx(:),idx_start(:)
  integer(bit_kind), allocatable :: f_psi_det(:,:,:), tmp_psi_det(:,:,:,:)
  double precision, allocatable  :: f_psi_coef(:,:), tmp_psi_coef(:,:)

  PROVIDE psi_det psi_coef

  !$omp parallel &
  !$omp shared(n_threads)
  n_threads = omp_get_num_threads()
  !$omp end parallel
  
  allocate(idx(0:n_threads-1),idx_start(0:n_threads-1))
  
  ! TODO: add filter in psi_det on the excitation degree / cc_ref
  ! Filter
  max_exc = 2
  count = 0
  tot_count = 0
  !$omp parallel &
  !$omp private(i,degree) &
  !$omp shared(tot_count,count,psi_det,N_int,max_exc,cc_ref) &
  !$omp default(none)
  !$omp do
  do i = 1, size(psi_det,3)
    call get_excitation_degree(psi_det(1,1,i),psi_det(1,1,cc_ref),degree,N_int)
    if (degree <= max_exc) then
       count = count + 1
    endif
  enddo
  !$omp end do
  !$omp critical
  tot_count = tot_count + count
  !$omp end critical
  !$omp end parallel

  allocate(f_psi_det(N_int,2,tot_count),f_psi_coef(tot_count,N_states))

  ! Allocate buffers
  allocate(tmp_psi_det(N_int,2,tot_count/n_threads*4,0:n_threads-1))
  allocate(tmp_psi_coef(tot_count/n_threads*4,0:n_threads-1))
  !$omp parallel &
  !$omp private(s,i,degree,num) &
  !$omp shared(idx,idx_start,n_threads,count,tmp_psi_det,tmp_psi_coef, &
  !$omp f_psi_coef,psi_det,psi_coef,N_int,max_exc,N_states, &
  !$omp cc_ref,f_psi_det) &
  !$omp default(none)
  num = omp_get_thread_num()
  idx(num) = 1

  ! Fill the buffer
  !$omp do
  do i = 1, size(psi_det,3)
    call get_excitation_degree(psi_det(1,1,i),psi_det(1,1,cc_ref),degree,N_int)
    if (degree <= max_exc) then
       tmp_psi_det(:,:,idx(num),num) = psi_det(:,:,i)
       idx(num) = idx(num) + 1
    endif
  enddo
  !$omp end do

  ! Compute the indexes
  !$omp master
  idx_start(0) = 0
  do i = 1, n_threads-1
    idx_start(i) = idx_start(i-1) + idx(i-1)
  enddo
  !$omp end master
  !$omp barrier

  ! Fill the final array
  !$omp do
  do j = 0, n_threads-1
    do i = 1, idx(j)
      f_psi_det(:,:,idx_start(j)+i) = tmp_psi_det(:,:,i,j)
    enddo
  enddo
  !$omp end do

  do s = 1, N_states
    ! Fill the buffer
    idx(num) = 1
    !$omp do
    do i = 1, size(psi_det,3)
      call get_excitation_degree(psi_det(1,1,i),psi_det(1,1,cc_ref),degree,N_int)
      if (degree <= max_exc) then
         tmp_psi_coef(idx(num),num) = psi_coef(i,s)
         idx(num) = idx(num) + 1
      endif
    enddo
    !$omp end do

    ! Compute the indexes
    !$omp master
    idx_start(0) = 0
    do i = 1, n_threads-1
      idx_start(i) = idx_start(i-1) + idx(i-1)
    enddo
    !$omp end master
    !$omp barrier
       
    ! Fill the final array
    !$omp do
    do j = 0, n_threads-1
      do i = 1, idx(j)
        f_psi_coef(idx_start(j)+i,s) = tmp_psi_coef(i,j)
      enddo
    enddo
    !$omp end do

  enddo
  !$omp end parallel

  deallocate(tmp_psi_coef,tmp_psi_det)
  
  !$omp parallel &
  !$omp private(s,i,j,degree,accu) &
  !$omp shared(N_states,f_psi_det,list_det,N_int,f_psi_coef,list_coef, &
  !$omp overlap,Ndet) &
  !$omp default(none)
  do s = 1, N_states
    accu = 0d0
    overlap = 0d0
    !$omp do
    do i = 1, size(f_psi_coef,1)
      do j = 1, Ndet
       call get_excitation_degree(f_psi_det(1,1,i),list_det(1,1,j),degree,N_int)
       if (degree == 0) then
         accu = accu + f_psi_coef(i,s) * list_coef(j)
       endif
      enddo
    enddo
    !$omp end do
    !$omp critical
    overlap = overlap + accu
    !$omp end critical
    !$omp barrier
    !$omp single
    write(*,'(A19,I2,A3,F12.6)') 'Overlap with state ', s,' = ', dabs(overlap)
    !$omp end single
    !$omp barrier
  enddo
  !$omp end parallel

  deallocate(f_psi_det)
  
end

subroutine overlap_wf_safe(Ndet, list_det, list_coef)

  implicit none

  integer, intent(in)           :: Ndet
  integer(bit_kind), intent(in) :: list_det(N_int,2,Ndet)
  double precision, intent(in)  :: list_coef(Ndet)

  double precision              :: accu, overlap
  integer                       :: i,j,s,degree

  ! TODO: add filter in psi_det on the excitation degree / cc_ref

  !$omp parallel &
  !$omp private(s,i,j,degree,accu) &
  !$omp shared(N_states,psi_det,list_det,N_int,psi_coef,list_coef, &
  !$omp overlap,Ndet) &
  !$omp default(none)
  do s = 1, N_states
    accu = 0d0
    overlap = 0d0
    !$omp do
    do i = 1, size(psi_coef,1)
      do j = 1, Ndet
       call get_excitation_degree(psi_det(1,1,i),list_det(1,1,j),degree,N_int)
       if (degree == 0) then
         accu = accu + psi_coef(i,s) * list_coef(j)
       endif
      enddo
    enddo
    !$omp end do
    !$omp critical
    overlap = overlap + accu
    !$omp end critical
    !$omp barrier
    !$omp single
    write(*,'(A19,I2,A3,F12.6)') 'Overlap with state ', s,' = ', dabs(overlap)
    !$omp end single
    !$omp barrier
  enddo
  !$omp end parallel

end
#+end_src
