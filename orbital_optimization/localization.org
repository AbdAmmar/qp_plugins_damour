* Orbital localization

Test localization with pairwise rotations

#+BEGIN_SRC f90 :comments org :tangle localization.irp.f
program localization
 call run_localization
end

subroutine run_localization

  implicit none

  ! Variables
  double precision, allocatable :: m_theta(:,:), pre_rot(:,:), R(:,:), R2(:,:), m_x(:,:), m_x2(:,:), x(:)
  double precision, allocatable :: prev_mos(:,:), spatial_extent(:), tmp_R(:,:)
  double precision :: criterion, angle_pre_rot
  double precision :: theta_max
  integer          :: i_theta_max, j_theta_max
  integer          :: i,j,k,l,p
  integer          :: mo_beg, mo_end
  integer          :: n_occ
  integer          :: info
  integer          :: n, tmp_n, tmp_size
  double precision, allocatable :: v_grad(:), H(:,:), tmp_m_x(:,:)
  double precision :: max_elem, t1, t2, t3, t4, t5, t6
  double precision :: pi

  !restore_symm = .False.
  !SOFT_TOUCH restore_symm
 
  n = mo_num*(mo_num-1)/2

  ! Allocation
  !allocate(v_grad(n), H(n,n), x(n))
  allocate(spatial_extent(mo_num), R2(mo_num,mo_num))
  allocate(m_theta(mo_num, mo_num), pre_rot(mo_num, mo_num), R(mo_num, mo_num))
  allocate(prev_mos(ao_num, mo_num), m_x(mo_num,mo_num), m_x2(mo_num, mo_num))

  pi = 3.1415926535897932d0
  
  call nb_occ_om(n_occ)

  call compute_spatial_extent(spatial_extent)

  print*, 'elec_num:', elec_num
  print*, 'core:', n_core_orb
  print*, 'occ:', n_occ
  print*, 'vir:', mo_num - n_occ
  print*, 'mo_num:', mo_num

  call compute_criterion(criterion)
  print*,'### Before pre rotation :'
  print*,'HF', HF_energy
  print*,'Criterion:', criterion

  ! Initialization
  pre_rot = 0d0

  ! Angle for the pre rotation
  angle_pre_rot = 1d-1

  ! Pre rotation for core MOs
  if (n_core_orb >= 2) then
    do i = 1, n_core_orb
      do j = 1, n_core_orb
        if (i > j) then
          pre_rot(i,j) = angle_pre_rot
        elseif (i < j) then
          pre_rot(i,j) = - angle_pre_rot
        else
          pre_rot(i,j) = 0d0
        endif
      enddo
    enddo
  endif
  
  ! Pre rotation for occ MOs
  do i = n_core_orb + 1, n_occ
    do j = n_core_orb + 1, n_occ
      if (i > j) then
        pre_rot(i,j) = angle_pre_rot
      elseif (i < j) then
        pre_rot(i,j) = - angle_pre_rot
      else
        pre_rot(i,j) = 0d0
      endif
    enddo
  enddo

  ! Pre rotation for vir MOs
  do i = n_occ + 1, mo_num
    do j = n_occ + 1, mo_num
      if (i > j) then
        pre_rot(i,j) = angle_pre_rot
      elseif (i < j) then
        pre_rot(i,j) = - angle_pre_rot
      else
        pre_rot(i,j) = 0d0
      endif
    enddo
  enddo

  call org_rotation_matrix(pre_rot,mo_num,R,mo_num,mo_num,info)
  !call apply_mo_rotation(R,mo_coef,new_mos)
  call org_apply_mo_rotation(R,prev_mos)

  TOUCH mo_coef

  call compute_criterion(criterion)
  print*,'### After pre rotation :'
  print*,'HF', HF_energy
  print*,'Criterion:', criterion

  print*,''
  print*,'========================'
  print*,'  Orbital localization'
  print*,'========================'
  print*,'' 
    
  print*,'core MOs:', 1, n_core_orb
  print*,'occ MOs:', n_core_orb, n_occ
  print*,'vir MOs:', n_occ+1, mo_num

!  do k = 1, 100
!     
!    call compute_theta(m_theta)
!    !
!    !  ! Test pair wise rotation
!    call research_max_theta(mo_beg, mo_end, m_theta, i_theta_max, j_theta_max, theta_max)
!    print*,'i_theta_max:', i_theta_max
!    print*,'j_theta_max:', j_theta_max
!    print*,' theta_max:', theta_max
!    !
!    !  ! Pair wise rotation
!    !  !call apply_pairwise_rotation(i_theta_max, j_theta_max, theta_max)
!    !
!    !  m_x = 0d0
!    !  x = 0d0
!    !
!    !  do j = mo_beg, mo_end
!    !    do i = mo_beg, mo_end
!    !      m_x(i,j) = m_theta(i,j) * 0.1d0
!    !    enddo
!    !  enddo
!    !
!    !  call org_rotation_matrix(m_x,mo_num,R,mo_num,mo_num,info)
!    !  call apply_mo_rotation(R,mo_coef,new_mos)
!    !
!    !  call compute_criterion(criterion)
!    !  print*,'Criterion:', criterion
!    
!    !!!!! Newton method's !!!!
!    mo_beg = n_occ+1
!    mo_end = mo_num
!    
!    call H_orb_loc(n, mo_beg, mo_end,H)
!    
!    call gradient_orb_loc(n, mo_beg, mo_end, v_grad, max_elem)
!    print*, 'Max element in gradient:', mo_beg, mo_end, max_elem
!    call x_orb_loc(n, v_grad, H, m_x)
!    
!    call org_rotation_matrix(m_x,mo_num,R,mo_num,mo_num,info)
!    call apply_mo_rotation(R,mo_coef,new_mos)
!    
!    call compute_criterion(criterion)
!    print*,'Criterion:', mo_beg, mo_end, criterion
!    
!    TOUCH mo_coef 
!  enddo

  logical :: not_converged, not_core_converged, not_occ_converged, not_vir_converged
  
  ! Initialization
  not_converged = .TRUE.
  if (n_core_orb < 2) then
    not_core_converged = .FALSE.
  else 
    not_core_converged = .TRUE.
  endif
  not_occ_converged = .TRUE.
  not_vir_converged = .TRUE.

do l = 1, 3
  
  if (l==1) then ! core
    not_converged = not_core_converged
    mo_beg = 1
    mo_end = n_core_orb
  elseif (l==2) then !  occ
    not_converged = not_occ_converged
     mo_beg = n_core_orb + 1
    mo_end = n_occ
  else ! vir
    not_converged = not_vir_converged
    mo_beg = n_occ + 1
    mo_end = mo_num
  endif

  tmp_size = mo_end - mo_beg + 1
  tmp_n = tmp_size * (tmp_size - 1)/2
  
  ! Allocation of tmp gradient and hessian
  allocate(v_grad(tmp_n), H(tmp_n, tmp_n), tmp_m_x(tmp_size, tmp_size), tmp_R(tmp_size, tmp_size))

  k = 1
  do while (not_converged .and. k <= 100)

    call wall_time(t4)
    call wall_time(t1)
    !call H_diag_orb_loc(n, mo_beg, mo_end,H)
    call H_diag_tmp_orb_loc(tmp_n, tmp_size, mo_beg, mo_end, H)
    call wall_time(t2)
    t3 = t2 - t1
    print*, 'H time', t3

    call wall_time(t1)
    !call gradient_orb_loc(n, mo_beg, mo_end, v_grad, max_elem)
    call gradient_tmp_orb_loc(tmp_n, mo_beg, mo_end, v_grad, max_elem)
    call wall_time(t2)
    t3 = t2 - t1
    print*, 'g time', t3
    print*, 'Max element in gradient:', mo_beg, mo_end, max_elem

    call wall_time(t1)
    !call x_orb_loc(n, v_grad, H, m_x) 
    call x_tmp_orb_loc(tmp_n, tmp_size, mo_beg, mo_end, v_grad, H, tmp_m_x)
    call tmp_to_full(tmp_m_x, tmp_size, mo_beg, mo_end, m_x)
    call wall_time(t2)
    t3 = t2 - t1
    print*, 'x time', t3
  
    !call wall_time(t1)
    !call org_rotation_matrix(m_x,mo_num,R,mo_num,mo_num,info)
    !call wall_time(t2)
    !t3 = t2 - t1
    !print*, 'R time', t3
    
    call wall_time(t1)
    call org_rotation_matrix(tmp_m_x,tmp_size,tmp_R,tmp_size,tmp_size,info)
    call tmp_to_full(tmp_R, tmp_size, mo_beg, mo_end, R2)
    ! 1 sur les elements diag sans rotation !!!!
    if (mo_beg > 1) then 
      do i = 1, mo_beg - 1
        R2(i,i) = 1d0    
      enddo
    endif
    if (mo_end < mo_num) then
      do i = mo_end + 1, mo_num
        R2(i,i) = 1d0  
      enddo
    endif
    call wall_time(t2)
    t3 = t2 - t1
    print*, 'R2 time', t3

    call wall_time(t1)
    call org_apply_mo_rotation(R2, prev_mos)
    call wall_time(t2)
    t3 = t2 - t1
    print*, 'apply R time', t3
    
    call wall_time(t1)
    call compute_criterion(criterion)
    print*,'Criterion:', mo_beg, mo_end, criterion
    call wall_time(t2)
    t3 = t2 - t1
    print*, 'Crit time', t3
  
    call wall_time(t1)  
    !call ao_to_mo_no_sym(ao_dipole_x, ao_num, mo_dipole_x, mo_num)
    !call ao_to_mo_no_sym(ao_dipole_y, ao_num, mo_dipole_y, mo_num)
    !call ao_to_mo_no_sym(ao_dipole_z, ao_num, mo_dipole_z, mo_num)
    call ao_to_mo_no_sym_tmp(tmp_size, mo_beg ,ao_dipole_x,ao_num,mo_dipole_x,mo_num)
    call ao_to_mo_no_sym_tmp(tmp_size, mo_beg ,ao_dipole_y,ao_num,mo_dipole_y,mo_num)
    call ao_to_mo_no_sym_tmp(tmp_size, mo_beg ,ao_dipole_z,ao_num,mo_dipole_z,mo_num)

    !SOFT_TOUCH mo_coef
    !PROVIDE mo_dipole_x mo_dipole_y mo_dipole_z
    call wall_time(t2)
    t3 = t2 - t1
    print*, 'update dipole time', t3

    if (ABS(max_elem) < 1d-6) then
      not_converged = .FALSE.
    endif
    k = k+1

    call wall_time(t5)
    t6 = t5 - t4
    print*, 'One cycle time', t6

  enddo

  if (.not. (n_core_orb < 2 .and. l==1)) then
     call wall_time(t1)
     SOFT_TOUCH mo_coef
     PROVIDE mo_dipole_x mo_dipole_y mo_dipole_z
     call save_mos()
     call wall_time(t2)
     t3 = t2 - t1
     print*, 'touch mo_coef', t3
  endif

  deallocate(v_grad, H, tmp_m_x, tmp_R)
  
enddo

  TOUCH mo_coef 
  print*,'HF', HF_energy

  call compute_spatial_extent(spatial_extent)

end program  
#+END_SRC

$A_{12} = \langle 1 | r| 2 \rangle \langle 1 | r | 2 \rangle -
\frac{1}{4} (\langle 1 | r | 1 \rangle - \langle 2 | r | 2 \rangle)
(\langle 1 | r | 1 \rangle - \langle 2 | r | 2 \rangle)$

$B_{12} = (\langle 1 | r | 1 \rangle - \langle 2 | r | 2 \rangle)
\langle 1 | r| 2 \rangle$

#+BEGIN_SRC  f90 :comments org :tangle localization.irp.f
subroutine gradient_orb_loc(n, mo_beg, mo_end, v_grad, max_elem)
  
  implicit none
  
  integer, intent(in) :: n, mo_beg, mo_end
  double precision, intent(out) :: v_grad(n), max_elem
  double precision, allocatable :: m_grad(:,:)
  integer :: i,j,k,l
  double precision :: pi

  pi = 3.1415926535897932
  
  ! Allocation
  allocate(m_grad(mo_num, mo_num))
 
  ! Calculation
  m_grad = 0d0

  do j = mo_beg, mo_end
    do i = mo_beg, mo_end
      m_grad(i,j) = 4d0 * mo_dipole_x(i,j) * (mo_dipole_x(i,i) - mo_dipole_x(j,j)) &
                  +4d0 * mo_dipole_y(i,j) * (mo_dipole_y(i,i) - mo_dipole_y(j,j)) &
                  +4d0 * mo_dipole_z(i,j) * (mo_dipole_z(i,i) - mo_dipole_z(j,j))
    enddo
  enddo

  !m_grad = - m_grad ! A cause de la transposition de m**** dans la matrice de rotation que je n'ai toujours pas enlevÃ©
  
  ! 2D -> 1D
  do k = 1, n
    call vec_to_mat_index(k,i,j)
    v_grad(k) = m_grad(i,j) 
  enddo

  ! Maximum element in the gradient
  max_elem = 0d0
  do k = 1, n
    if (ABS(v_grad(k)) > max_elem) then
      max_elem = ABS(v_grad(k))
    endif
  enddo 

  ! Deallocation
  deallocate(m_grad)

end subroutine

subroutine gradient_tmp_orb_loc(tmp_n, mo_beg, mo_end, v_grad, max_elem)
  
  implicit none
  
  integer, intent(in) :: tmp_n, mo_beg, mo_end
  double precision, intent(out) :: v_grad(tmp_n), max_elem
  double precision, allocatable :: m_grad(:,:)
  integer :: i,j,k,tmp_i,tmp_j,tmp_k, tmp_size
  double precision :: pi

  pi = 3.1415926535897932
  tmp_size = mo_end - mo_beg + 1 !size of the tmp array from mo_beg to mo_end
  
  ! Allocation
  allocate(m_grad(tmp_size, tmp_size))
 
  ! Calculation
  do tmp_j = 1, tmp_size
    call tmp_to_full_index(tmp_j,mo_beg,j)
    !q = j + mo_beg - 1
    do tmp_i = 1, tmp_size
      call tmp_to_full_index(tmp_i,mo_beg,i)
      !p = i + mo_beg - 1
      m_grad(tmp_i,tmp_j) = 4d0 * mo_dipole_x(i,j) * (mo_dipole_x(i,i) - mo_dipole_x(j,j)) &
                  +4d0 * mo_dipole_y(i,j) * (mo_dipole_y(i,i) - mo_dipole_y(j,j)) &
                  +4d0 * mo_dipole_z(i,j) * (mo_dipole_z(i,i) - mo_dipole_z(j,j))
    enddo
  enddo
  ! Peut Ãªtre mis directement dans le vecteur de taille tmp_n

  !m_grad = - m_grad ! A cause de la transposition de m**** dans l'applicationde la matrice de rotation que je n'ai toujours pas enlevÃ©
  
  ! 2D -> 1D
  do tmp_k = 1, tmp_n
    call vec_to_mat_index(tmp_k,tmp_i,tmp_j)
    v_grad(tmp_k) = m_grad(tmp_i,tmp_j) 
  enddo

  ! Maximum element in the gradient
  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (ABS(v_grad(tmp_k)) > max_elem) then
      max_elem = ABS(v_grad(tmp_k))
    endif
  enddo 

  ! Deallocation
  deallocate(m_grad)

end subroutine

subroutine H_orb_loc(n, mo_beg, mo_end, H)

  implicit none

  integer, intent(in) :: n, mo_beg, mo_end
  double precision, intent(out) :: H(n,n)
  double precision, allocatable :: H_4D(:,:,:,:), beta(:,:)
  integer :: i,j,k,l,pq,p,q,rs,r,s
  double precision :: max_elem

  ! Allocation
  allocate(H_4D(mo_num,mo_num,mo_num,mo_num), beta(mo_num,mo_num))
  
  ! Calculation
  beta = 0d0
  do j = mo_beg, mo_end
    do i = mo_beg, mo_end
      beta(i,j) = (mo_dipole_x(i,i) - mo_dipole_x(j,j))**2 - 4d0 * mo_dipole_x(i,j)**2 &
                 +(mo_dipole_y(i,i) - mo_dipole_y(j,j))**2 - 4d0 * mo_dipole_y(i,j)**2 &
                 +(mo_dipole_z(i,i) - mo_dipole_z(j,j))**2 - 4d0 * mo_dipole_z(i,j)**2
    enddo
  enddo

  H_4D = 0d0
  do j = mo_beg, mo_end 
    do i = mo_beg, mo_end
      H_4D(i,j,i,j) = 4d0 * beta(i,j)
    enddo
  enddo
  
  ! 4D -> 2D
  do rs = 1, n
    call vec_to_mat_index(rs,r,s)
    do pq = 1, n
      call vec_to_mat_index(pq,p,q)
      H(pq,rs) = H_4D(p,q,r,s)   
    enddo
  enddo

  max_elem = 0d0
  do i = 1, n
    if (H(i,i) < max_elem) then
      max_elem = H(i,i)
    endif
  enddo
  print*, 'Min elem H:', max_elem

  max_elem = 0d0
  do i = 1, n
    if (H(i,i) > max_elem) then
      max_elem = H(i,i)
    endif
  enddo
  print*, 'Max elem H:', max_elem
  
  max_elem = 1d10
  do i = 1, n
    if (ABS(H(i,i)) < ABS(max_elem)) then
      max_elem = H(i,i)
    endif
  enddo
  print*, 'Near 0 elem H:', max_elem

  ! Deallocation
  deallocate(H_4D, beta)

end subroutine

subroutine H_diag_tmp_orb_loc(tmp_n, tmp_size, mo_beg, mo_end, H)

  implicit none

  integer, intent(in) :: tmp_n, mo_beg, mo_end
  double precision, intent(out) :: H(tmp_n, tmp_n)
  double precision, allocatable :: beta(:,:)
  integer :: i,j,tmp_k,tmp_i, tmp_j, tmp_size
  double precision :: max_elem
    
  ! Allocation
  allocate(beta(tmp_size,tmp_size))
  
  ! Calculation
  do tmp_j = 1, tmp_size
    call tmp_to_full_index(tmp_j,mo_beg,j)
    !j = tmp_j + mo_beg - 1
    do tmp_i = 1, tmp_size
      call tmp_to_full_index(tmp_i,mo_beg,i)
      !i = tmp_i + mo_beg - 1
      beta(tmp_i,tmp_j) = (mo_dipole_x(i,i) - mo_dipole_x(j,j))**2 - 4d0 * mo_dipole_x(i,j)**2 &
                         +(mo_dipole_y(i,i) - mo_dipole_y(j,j))**2 - 4d0 * mo_dipole_y(i,j)**2 &
                         +(mo_dipole_z(i,i) - mo_dipole_z(j,j))**2 - 4d0 * mo_dipole_z(i,j)**2
    enddo
  enddo

  do tmp_k = 1, tmp_n
    call vec_to_mat_index(tmp_k,tmp_i,tmp_j)
    H(tmp_k,tmp_k) = 4d0 * beta(tmp_i, tmp_j)
  enddo
  
  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (H(tmp_k,tmp_k) < max_elem) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Min elem H:', max_elem

  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (H(tmp_k,tmp_k) > max_elem) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Max elem H:', max_elem
  
  max_elem = 1d10
  do tmp_k = 1, tmp_n
    if (ABS(H(tmp_k,tmp_k)) < ABS(max_elem)) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Near 0 elem H:', max_elem

  ! Deallocation
  deallocate(beta)

end subroutine

subroutine x_orb_loc(n, v_grad, H, m_x)

  implicit none

  integer, intent(in) :: n
  double precision, intent(in) :: v_grad(n)
  double precision, intent(in) :: H(n,n)
  double precision, intent(out) :: m_x(mo_num, mo_num)
  double precision, allocatable :: x(:)
  double precision :: lambda , accu, max_elem
  integer :: i,j,k, mo_beg, mo_end

  ! Allocation
  allocate(x(n))

  ! Level shifted hessian
  lambda = 0d0
  do i = 1, n
    if (H(i,i) < lambda) then
      lambda = H(i,i)
    endif
  enddo

  ! min element in the hessian
  if (lambda < 0d0) then
    lambda = -lambda + 1d-6
  endif  
  
  print*, 'lambda', lambda
 
  x = 0d0
  ! Good
  do i = 1, n
    if (ABS(H(i,i)) > 1d-6) then
      x(i) = - 1d0/(ABS(H(i,i))+lambda) * (-v_grad(i)) 
    endif
  enddo
  
  ! 1D -> 2D
  m_x = 0d0
  do j = 1, mo_num
    do i = 1, mo_num
      if (i>j) then
        call mat_to_vec_index(i,j,k)
        m_x(i,j) = x(k)
      else
        m_x(i,j) = 0d0
      endif
    enddo
  enddo

  do j = 1, mo_num
    do i = 1, mo_num
      if (i<j) then
        m_x(i,j) = - m_x(j,i)
      endif
    enddo
  enddo

  ! Deallocation
  deallocate(x)

end subroutine

subroutine x_tmp_orb_loc(tmp_n, tmp_size, mo_beg, mo_end, v_grad, H, tmp_m_x)

  implicit none

  integer, intent(in) :: tmp_n, mo_beg, mo_end, tmp_size
  double precision, intent(in) :: v_grad(tmp_n)
  double precision, intent(in) :: H(tmp_n, tmp_n)
  double precision, intent(out) :: tmp_m_x(tmp_size, tmp_size)
  double precision, allocatable :: x(:)
  double precision :: lambda , accu, max_elem
  integer :: i,j,tmp_i,tmp_j,tmp_k

  ! Allocation
  allocate(x(tmp_n))

  ! Level shifted hessian
  lambda = 0d0
  do tmp_k = 1, tmp_n
    if (H(tmp_k,tmp_k) < lambda) then
      lambda = H(tmp_k,tmp_k)
    endif
  enddo

  ! min element in the hessian
  if (lambda < 0d0) then
    lambda = -lambda + 1d-6
  endif  
  
  print*, 'lambda', lambda
 
  ! Good
  do tmp_k = 1, tmp_n
    if (ABS(H(tmp_k,tmp_k)) > 1d-6) then
      x(tmp_k) = - 1d0/(ABS(H(tmp_k,tmp_k))+lambda) * (-v_grad(tmp_k)) 
    endif
  enddo

  ! 1D tmp -> 2D tmp 
  tmp_m_x = 0d0
  do tmp_j = 1, tmp_size - 1
    do tmp_i = tmp_j + 1, tmp_size
      call mat_to_vec_index(tmp_i,tmp_j,tmp_k)
      tmp_m_x(tmp_i, tmp_j) = x(tmp_k)
    enddo
  enddo

  ! Antisym, pourrait Ãªtre mieux avec m_x - m_x^T ?
  do tmp_i = 1, tmp_size - 1
    do tmp_j = tmp_i + 1, tmp_size
      tmp_m_x(tmp_i,tmp_j) = - tmp_m_x(tmp_j,tmp_i) 
    enddo
  enddo

  ! Deallocation
  deallocate(x)

end subroutine

subroutine compute_gradient(mo_beg, mo_end, m_x)

  implicit none
  
  integer, intent(in) :: mo_beg, mo_end
  double precision, intent(out) :: m_x(mo_num, mo_num)
  double precision, allocatable :: gradient(:), hessian(:,:), x(:)
  double precision, allocatable :: m_gradient(:,:), beta(:,:), gamma(:,:), H(:,:,:,:)
  double precision :: accu, max_elem
  integer :: i,j,k,p,q,pq,r,s,rs,n

  n = mo_num*(mo_num-1)/2

  allocate(m_gradient(mo_num, mo_num))
  allocate(beta(mo_num, mo_num), gamma(mo_num, mo_num), H(mo_num,mo_num,mo_num,mo_num))
  allocate(hessian(n,n), x(n), gradient(n))

  beta = 0d0
  do j = 1, mo_num
    do i = 1, mo_num
      beta(i,j) = (mo_dipole_x(i,i) - mo_dipole_x(j,j))**2 - 4d0 *  mo_dipole_x(i,j)**2 &
                 +(mo_dipole_y(i,i) - mo_dipole_y(j,j))**2 - 4d0 *  mo_dipole_y(i,j)**2 &
                 +(mo_dipole_z(i,i) - mo_dipole_z(j,j))**2 - 4d0 *  mo_dipole_z(i,j)**2
    enddo
  enddo

  gamma = 0d0
  do j = 1, mo_num
    do i = 1, mo_num
      gamma(i,j) = 4d0 * mo_dipole_x(i,j) * (mo_dipole_x(i,i) - mo_dipole_x(j,j)) &
                  +4d0 * mo_dipole_y(i,j) * (mo_dipole_y(i,i) - mo_dipole_y(j,j)) &
                  +4d0 * mo_dipole_z(i,j) * (mo_dipole_z(i,i) - mo_dipole_z(j,j))
    enddo
  enddo

  m_gradient = 0d0
  do j = 1, mo_num
    do i = 1, mo_num
      m_gradient(i,j) = beta(i,j) * dsin(0d0) + gamma(i,j) * dcos(0d0) 
    enddo
  enddo

  do k = 1, n
    call vec_to_mat_index(k,i,j)
    gradient(k) = m_gradient(i,j)
  enddo 

  do k = 1, n
    call vec_to_mat_index(k,i,j)
  enddo

  max_elem = 0d0
  do k = 1, n
    if (ABS(gradient(k)) > max_elem) then
      max_elem = ABS(gradient(k))
    endif
  enddo 
  print*, "Max element in the gradient:", max_elem

  H = 0d0
  do j = 1, mo_num
    do i = 1, mo_num
      H(i,j,i,j) = 4d0 * beta(i,j) * dcos(0d0) - 4d0 * gamma(i,j) * dsin(0d0)
    enddo
  enddo
  
  do rs = 1, n
    call vec_to_mat_index(rs,r,s)
    do pq = 1, n
      call vec_to_mat_index(pq,p,q)
      hessian(pq,rs) = H(p,q,r,s)   
    enddo
  enddo

  accu = 0d0
  do i = 1, n
    if (hessian(i,i) < accu) then
      accu = hessian(i,i)
    endif
  enddo
  accu = accu - 1d-6

  do i = 1, n
    hessian(i,i) = hessian(i,i) - accu
  enddo

  x = 0d0
  do i = 1, n 
    if (ABS(hessian(i,i)) > 1d-6) then
      x(i) = - 1d0/hessian(i,i) * (-gradient(i))
    else
      x(i) = 0d0
    endif
  enddo

  print*,'norm_grad', sum(gradient(:)**2)

  m_x = 0d0
  do j = mo_beg, mo_end
    do i = mo_beg, mo_end
      if (i>j) then
        call mat_to_vec_index(i,j,k)
        m_x(i,j) = x(k)
      else
        m_x(i,j) = 0d0
      endif
    enddo
  enddo

  do j = mo_beg, mo_end
    do i = mo_beg, mo_end
      if (i<j) then
        m_x(i,j) = - m_x(j,i)
      endif
    enddo
  enddo

  !print*,'hessian:'
  !do i = 1, n
  !  write(*,'(100(E12.5))') hessian(i,:)
  !enddo

  !print*,'gradient:'
  !do i = 1, n
  !  write(*,'(100(E12.5))') m_gradient(i,:)
  !enddo
end subroutine

subroutine compute_theta(m_theta)

  implicit none
  
  integer :: i,j
  double precision, intent(out) :: m_theta(mo_num, mo_num)

  double precision, allocatable :: A12(:,:), B12(:,:)
  double precision :: pi

  pi = 3.1415926535897932

  allocate(A12(mo_num, mo_num), B12(mo_num, mo_num))
  
  !A12
  do j = 1, mo_num
    do i = 1, mo_num
      A12(i,j) = mo_dipole_x(i,j) * mo_dipole_x(i,j) &
                 - 0.25d0 * (mo_dipole_x(i,i) - mo_dipole_x(j,j)) * &
                 (mo_dipole_x(i,i) - mo_dipole_x(j,j)) &
                + &
                mo_dipole_y(i,j) * mo_dipole_y(i,j) &
                 - 0.25d0 * (mo_dipole_y(i,i) - mo_dipole_y(j,j)) * &
                 (mo_dipole_y(i,i) - mo_dipole_y(j,j)) &
                + &
                mo_dipole_z(i,j) * mo_dipole_z(i,j) &
                 - 0.25d0 * (mo_dipole_z(i,i) - mo_dipole_z(j,j)) * &
                 (mo_dipole_z(i,i) - mo_dipole_z(j,j))
    enddo
  enddo

  ! B12
  do j = 1, mo_num
    do i = 1, mo_num
      B12(i,j) = (mo_dipole_x(i,i) - mo_dipole_x(j,j)) * mo_dipole_x(i,j) &
                 + &
                 (mo_dipole_y(i,i) - mo_dipole_y(j,j)) * mo_dipole_y(i,j) &
                 + &
                 (mo_dipole_z(i,i) - mo_dipole_z(j,j)) * mo_dipole_z(i,j)
    enddo
  enddo

  ! m_theta
  do j = 1, mo_num
    do i = 1, mo_num
      if (i == j) then
        m_theta(i,j) = 0d0     !(-B12(i,j), A12(i,j)) ?? pourquoi j'avais mis le - ici ????
      elseif (0.25d0 * atan2(B12(i,j), -A12(i,j)) >= 0d0) then
        m_theta(i,j) =  0d0 * pi * 0.25d0 + 0.25d0 * atan2(B12(i,j), -A12(i,j))
      else
        m_theta(i,j) = - 0d0 *pi * 0.25d0 + 0.25d0 * atan2(B12(i,j), -A12(i,j))
      endif
    enddo
  enddo

end subroutine

subroutine compute_criterion(criterion)

  implicit none

  double precision, intent(out) :: criterion
  integer :: i

  ! Criterion (= \sum_i <i|r|i>^2 )
  criterion = 0d0
  do i = 1, mo_num
    criterion = criterion + mo_dipole_x(i,i)**2 + mo_dipole_y(i,i)**2 + mo_dipole_z(i,i)**2
  enddo
  criterion = - criterion

end subroutine

subroutine compute_spatial_extent(spatial_extent)

  implicit none
 
  double precision, intent(out) :: spatial_extent(mo_num)
  double precision :: average_core, average_occ, average_vir
  double precision :: std_var_core, std_var_occ, std_var_vir
  integer :: i,j,k,l, n_occ
   

  spatial_extent = 0d0
  
  do i = 1, mo_num
    spatial_extent(i) = mo_spread_x(i,i) - mo_dipole_x(i,i)**2
  enddo
  do i = 1, mo_num
    spatial_extent(i) = spatial_extent(i) + mo_spread_y(i,i) - mo_dipole_y(i,i)**2
  enddo
  do i = 1, mo_num
    spatial_extent(i) = spatial_extent(i) + mo_spread_z(i,i) - mo_dipole_z(i,i)**2
  enddo

  do i = 1, mo_num
    spatial_extent(i) = dsqrt(spatial_extent(i))
  enddo

  call nb_occ_om(n_occ)

  average_core = 0d0
  std_var_core = 0d0
  if (n_core_orb >= 2) then
    call compute_average_sp_ext(spatial_extent, 1, n_core_orb, average_core)
    call compute_std_var_sp_ext(spatial_extent, 1, n_core_orb, average_core, std_var_core)
  endif
  
  call compute_average_sp_ext(spatial_extent, n_core_orb + 1, n_occ, average_occ)
  call compute_std_var_sp_ext(spatial_extent, n_core_orb + 1, n_occ, average_occ, std_var_occ)
  
  call compute_average_sp_ext(spatial_extent, n_occ + 1, mo_num, average_vir)
  call compute_std_var_sp_ext(spatial_extent, n_occ + 1, mo_num, average_vir, std_var_vir)

  print*,''
  print*,'============================='
  print*,'  Spatial extent of the MOs'
  print*,'============================='
  print*,''

  print*, 'elec_num:', elec_num
  print*, 'core:', n_core_orb
  print*, 'occ:', n_occ
  print*, 'vir:', mo_num - n_occ
  print*, 'mo_num:', mo_num
  print*,''
   
  print*,'-- Core MOs --'
  print*,'Average:', average_core
  print*,'Std var:', std_var_core
  print*,''
  
  print*,'-- Occupied MOs --'
  print*,'Average:', average_occ
  print*,'Std var:', std_var_occ
  print*,''

  print*,'-- Virtual MOs --'
  print*,'Average:', average_vir
  print*,'Std var:', std_var_vir
  print*,''

  print*,'Spatial extent:'
  do i = 1, mo_num
    print*, i, spatial_extent(i)
  enddo

end

subroutine compute_average_sp_ext(spatial_extent, mo_beg, mo_end, average)

  implicit none

  integer, intent(in) :: mo_beg, mo_end
  double precision, intent(in) :: spatial_extent(mo_num)
  double precision, intent(out) :: average
  integer :: i,j, size

  size = mo_end - mo_beg + 1
  
  average = 0d0
  do i = mo_beg, mo_end
    average = average + spatial_extent(i)
  enddo

  average = average / DBLE(size)

end

subroutine compute_std_var_sp_ext(spatial_extent, mo_beg, mo_end, average, std_var)

  implicit none

  integer, intent(in) :: mo_beg, mo_end
  double precision, intent(in) :: spatial_extent(mo_num)
  double precision, intent(in) :: average
  double precision, intent(out) :: std_var
  integer :: i,j, size

  size = mo_end - mo_beg + 1
 
  std_var = 0d0

  do i = mo_beg, mo_end
    std_var = std_var + (spatial_extent(i) - average)**2
  enddo
  
  std_var = dsqrt(1d0/DBLE(size) * std_var)

end

subroutine research_max_theta(mo_beg, mo_end, m_theta, i_theta_max, j_theta_max, theta_max)

  implicit none

  integer, intent(in) :: mo_beg, mo_end
  double precision, intent(in) :: m_theta(mo_num, mo_num)
  integer, intent(out) :: i_theta_max, j_theta_max
  double precision, intent(out) :: theta_max
  integer :: i,j
  
  ! research the max theta for the MOs between mo_beg and mo_end

  theta_max = 0d0
  do j = mo_beg, mo_end
    do i = mo_beg, mo_end
      if (ABS(theta_max) <= ABS(m_theta(i,j))) then
        i_theta_max = i 
        j_theta_max = j 
        theta_max =  m_theta(i,j)
      endif
    enddo
  enddo

end subroutine

subroutine apply_pairwise_rotation(i_theta_max, j_theta_max, theta_max)

  implicit none

  integer, intent(in) :: i_theta_max, j_theta_max
  double precision, intent(in) :: theta_max
  double precision, allocatable :: new_mos(:,:)
  integer :: k

  allocate(new_mos(ao_num, mo_num))

  ! Rotation
  new_mos = mo_coef

  do k = 1, ao_num
    new_mos(k, i_theta_max) = mo_coef(k, i_theta_max) * cos(theta_max) &
                            + mo_coef(k, j_theta_max) * sin(theta_max)
    new_mos(k, j_theta_max) = - mo_coef(k, i_theta_max) * sin(theta_max) &
                            + mo_coef(k, j_theta_max) * cos(theta_max)
  enddo

  mo_coef = new_mos
  call save_mos()
  
  !call clear_mo_map
  !TOUCH mo_coef

end subroutine

! It works but it needs the four index integrals... => bad
!subroutine compute_hf_energy()
!
!  implicit none
!
!  double precision :: energy, mo_two_e_integral
!  integer :: i,j,k,l
!
!  energy = 0d0
!  do j = 1, mo_num
!    do i = 1, mo_num
!      energy = energy + mo_one_e_integrals(i,j) * one_e_dm_mo(i,j)
!    enddo
!  enddo
!
!  do l = 1, mo_num
!    do k = 1, mo_num
!      do j = 1, mo_num
!        do i = 1, mo_num
!          energy = energy +0.5d0 * mo_two_e_integral(i,j,k,l) * two_e_dm_mo(i,j,k,l)
!        enddo
!      enddo
!    enddo
!  enddo
!
!  energy = energy + nuclear_repulsion
!
!  print*,'energy scf', energy
!
!end subroutine
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle localization.irp.f
subroutine nb_occ_om(n_occ)
  
  implicit none
  
  integer, intent(out) :: n_occ ! number of occupied orbitals
  
  if (mod(elec_num,2) == 0) then
    n_occ = elec_num/2
  else
    n_occ = elec_num/2 + 1
  endif
  
end

subroutine tmp_to_full_index(tmp_i,mo_beg,i)

  implicit none
  
  ! For a square matrix M,m by m, we define a smaller square matrix T (=tmp) (mo_end - mo_beg + 1 by mo_end - mo_beg + 1)
  ! which contains the elements between mo_beg,mo_beg and mo_end,mo_end
  ! index i in T matrix corresponds to index p in M
  ! index j in T matrix corresponds to index q in M 

  integer, intent(in) :: tmp_i
  integer, intent(in) :: mo_beg
  integer, intent(out) :: i

  i = tmp_i + mo_beg - 1

end

subroutine full_to_tmp_index(i,mo_beg,tmp_i)

  implicit none
  
  ! For a square matrix M,m by m, we define a smaller square matrix T (=tmp) (mo_end - mo_beg + 1 by mo_end - mo_beg + 1)
  ! which contains the elements between mo_beg,mo_beg and mo_end,mo_end
  ! index tmp_i in T matrix corresponds to index i in M
  ! index tmp_j in T matrix corresponds to index i in M 

  integer, intent(in) :: i
  integer, intent(in) :: mo_beg
  integer, intent(out) :: tmp_i

  tmp_i = i - mo_beg + 1

end

subroutine tmp_to_full(tmp_m_x, tmp_size, mo_beg, mo_end, m_x)

  implicit none

  integer, intent(in) :: tmp_size, mo_beg, mo_end
  double precision, intent(in) :: tmp_m_x(tmp_size,tmp_size)
  double precision, intent(out) :: m_x(mo_num,mo_num) 
  integer :: i,j, tmp_i, tmp_j

  m_x = 0d0
  do j = mo_beg, mo_end
    call full_to_tmp_index(j, mo_beg, tmp_j)
    do i = mo_beg, mo_end
       call full_to_tmp_index(i, mo_beg, tmp_i)
       m_x(i,j) = tmp_m_x(tmp_i,tmp_j)
    enddo
  enddo

end


subroutine ao_to_mo_no_sym(A_ao,LDA_ao,A_mo,LDA_mo)
  implicit none
  BEGIN_DOC
  ! Transform A from the |AO| basis to the |MO| basis
  !
  ! $C^\dagger.A_{ao}.C$
  END_DOC
  integer, intent(in)            :: LDA_ao,LDA_mo
  double precision, intent(in)   :: A_ao(LDA_ao,ao_num)
  double precision, intent(out)  :: A_mo(LDA_mo,mo_num)
  double precision, allocatable  :: T(:,:)

  allocate ( T(ao_num,mo_num) )
  !DIR$ ATTRIBUTES ALIGN : $IRP_ALIGN :: T

  call dgemm('N','N', ao_num, mo_num, ao_num,                    &
      1.d0, A_ao,LDA_ao,                                             &
      mo_coef, size(mo_coef,1),                                      &
      0.d0, T, size(T,1))

  call dgemm('T','N', mo_num, mo_num, ao_num,                &
      1.d0, mo_coef,size(mo_coef,1),                                 &
      T, ao_num,                                                     &
      0.d0, A_mo, size(A_mo,1))

  deallocate(T)
end

subroutine ao_to_mo_no_sym_tmp(tmp_size, mo_beg ,A_ao,LDA_ao,A_mo,LDA_mo)
  implicit none
  BEGIN_DOC
  ! Transform A from the |AO| basis to the |MO| basis
  !
  ! $C^\dagger.A_{ao}.C$
  END_DOC
  integer, intent(in)            :: LDA_ao,LDA_mo,tmp_size, mo_beg
  double precision, intent(in)   :: A_ao(LDA_ao,ao_num)
  double precision, intent(out)  :: A_mo(LDA_mo,mo_num)
  double precision, allocatable  :: T(:,:)

  allocate ( T(ao_num,tmp_size) )
  !DIR$ ATTRIBUTES ALIGN : $IRP_ALIGN :: T

  call dgemm('N','N', ao_num, tmp_size, ao_num,                    &
      1.d0, A_ao,LDA_ao,                                             &
      mo_coef(1,mo_beg), size(mo_coef,1),                                      &
      0.d0, T, size(T,1))

  call dgemm('T','N', tmp_size, tmp_size, ao_num,                &
      1.d0, mo_coef(1,mo_beg),size(mo_coef,1),                                 &
      T, ao_num,                                                     &
      0.d0, A_mo(mo_beg,mo_beg), size(A_mo,1))

  deallocate(T)
end
#+END_SRC
