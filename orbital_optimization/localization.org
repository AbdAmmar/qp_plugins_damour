* Orbital localization

Test localization with pairwise rotations

Boys localization
TODO:
doc
** Doc

The program localizes the orbitals in function of their mo_class:
- core MOs
- inactive MOs
- active MOs
- virtual MOs
- deleted MOs -> no orbital localization

Core MOs are localized with core MOs, inactives MOs are localized with
inactives MOs and so on. But deleted orbitals are not localized.

WARNING: 
- The user MUST SPECIFY THE MO CLASSES, otherwise the localization will be
done for all the orbitals between them, so the occupied and virtual
MOs will be combined together which is clearly not what we want to
do. 
- The mo class is not important (except "deleted") because it is not
link to the kind of MOs for CASSCF or CIPSI. It is just a way to
separate the MOs in order to localize them separetely, for example to
separate the core MOs, the occupied MOs and the virtuals MOs.
- The user MUST CHANGE THE MO CLASSES AFTER THE LOCALIZATION in order to
have the right mo class for his next calculation...

For more information on the mo classes:
qp set_mo_class -h

Foster-Boys localization:
- cite Foster
- cite Kleir 
- cite Hoyvik
- cite le papier des physiciens

The Foster-Boys localization is a method to generate localized MOs
(LMOs) by minimizing the Foster-Boys criterion:
$$ C_{FB} = \sum_{i=1}^N \left[ < \phi_i | r^2 | \phi_i > - < \phi_i | r |
\phi_i >^2 \right] $$.
In fact it is equivalent to maximise
$$ C_2 = \sum_{i>j, \ i=1}^N \left[  < \phi_i | r | \phi_i > -  <
\phi_j | r | \phi_j > \left]^2$$ 
or
$$ C_3 = \sum_{i=1}^N \left[ < \phi_i | r | \phi_i > \right]^2.$$

Where $\phi_i$ is an MO and $N$ the number of MOs,
\begin{align*}
< \phi_i | r^2 | \phi_i > &= < \phi_i | x^2 | \phi_i >  \\
&+ < \phi_i | y^2 | \phi_i > \\
&+ < \phi_i | z^2 | \phi_i >
\end{align*}
and
\begin{align*}
< \phi_i | r | \phi_i >^2 &= < \phi_i | x | \phi_i >^2  \\
&+ < \phi_i | y | \phi_i >^2 \\
&+ < \phi_i | z | \phi_i >^2
\end{align*}

 
Starting with a set of MOs $\left\{\phi_i\right\}_{i=1}^N$ and we
are looking for a new set of MOs $\left\{\tilde{\phi}_i\right\}_{i=1}^N$ which
minimizes the Foster-Boys criterion. This new set of MOs can be found
by applying a unitary transformation $\textbf{R}$ s.t. $\textbf{R} \cdot
\textbf{R}^T = \textbf{R}^T \cdot \textbf{R} = \textbf{I}$ on the
coefficients of the MOs. The unitary transformation matrix or rotation
matrix is obtained by exponentiating an antihermithian matrix
$\textbf{X}$, the elements $\textbf{X}_{ij}$ correspond to the
rotation angle between the MO i and the MO j. 
In the case where two MOs ($\phi_p$,$\phi_q$) are combined between them at each iteration it
is the Jacobi sweep method and the related rotation matrix is trivial:
\begin{align*}
\textbf{R}=
\begin{pmatrix}
\cos(\theta_{pq}) & \sin(\theta_{pq}) \\
- \sin(\theta_{pq}) & \cos(\theta_{pq})
\end{pmatrix}
\end{align*}

The application of $\textbf{R}$ on $\phi_p$ and $\phi_q$ leads to:
\begin{align*}
\tilde{\phi}_p &=  \phi_p \cos(\theta_{pq}) + \phi_q \sin(\theta_{pq}) \\
\tilde{\phi}_q &= -\phi_p \sin(\theta_{pq}) + \phi_q \cos(\theta_{pq})
\end{align*}

Consequently, the criterion becomes

\begin{align*}
C_{FB} &= \sum_{i=1}^N \left[ < \phi_i | r^2 | \phi_i > 
- < \phi_i | r | \phi_i >^2 \right] \\ 
&- \left[ < \phi_{p}| r^2 | \phi_{p} > - < \phi_{p} | r |
\phi_{p} >^2 +  < \phi_{q} | r^2 | \phi_{q}
> - < \phi_{q} | r | \phi_{q} >^2 \right] \\
&+ \left[ < \tilde{\phi}_p| r^2 | \tilde{\phi}_p > - < \tilde{\phi}_p | r |
\tilde{\phi}_p >^2 +  < \tilde{\phi}_q | r^2 | \tilde{\phi}_q
> - < \tilde{\phi}_q | r | \tilde{\phi}_q >^2 \right] 
\end{align*}

Noting 
$$A_{ii} = < \phi_i | r^2 | \phi_i > $$
$$B_{ii} = < \phi_i | r | \phi_i > $$
$$\tilde{\phi_p} = \tilde{p} $$ 

\begin{align*}
C_{FB}(\theta) &= \sum_{i=1}^N \left[ A_{ii} - A_{jj} \right] \\ 
&- \left[  A_{pp} - B_{pp}^2 +  A_{qq} - B_{qq}^2 \right] \\
&+ \left[ < \tilde{p}| r^2 | \tilde{p} > - < \tilde{p} | r |
\tilde{p} >^2 +  < \tilde{q} | r^2 | \phi_{\tilde{q}}
> - < \tilde{q} | r | \tilde{q} >^2 \right] 
\end{align*}

From that we have
\begin{align*}
< \tilde{p}| r^2 | \tilde{p} > &= <  p \cos(\theta) + q \sin(\theta) | r^2 | p \cos(\theta) + q \sin(\theta) > \\
&= \cos^2(\theta) A_{pp} + \sin^2(\theta) A_{qq} + 2 \sin(2 \theta) A_{pq}
\end{align*}

and 
\begin{align*}
< \tilde{q}| r^2 | \tilde{q} > &= <  -p \sin(\theta) + q \cos(\theta) | r^2 | -p \sin(\theta) + q \cos(\theta) > \\
&= \sin^2(\theta) A_{pp} + \cos^2(\theta) A_{qq} - 2 \sin(2 \theta) A_{pq}
\end{align*}

which leads to
\begin{align*}
< \tilde{p}| r^2 | \tilde{p} > + < \tilde{q}| r^2 | \tilde{q} > =
A_{pp} + A_{qq}.
\end{align*}

Clearly, these two terms do not depend of the rotation angle
$\theta_{pq}$. For that reason the derivatives with respect to $\textbf{X}$ of $C_{FB}$ is the same
that $-C_3$.

And for the two other terms
\begin{align*}
< \tilde{p}| r | \tilde{p} >^2 &= <  p \cos(\theta) + q \sin(\theta) | r | p \cos(\theta) + q \sin(\theta) >^2 \\
&= (\cos^2(\theta) B_{pp} + \sin^2(\theta) B_{qq} + 2 \sin(2 \theta) B_{pq})^2
\end{align*}

\begin{align*}
< \tilde{q}| r | \tilde{q} >^2 &= <  -p \sin(\theta) + q \cos(\theta) | r | -p \sin(\theta) + q \cos(\theta) >^2 \\
&= (\sin^2(\theta) B_{pp} + \cos^2(\theta) B_{qq} - 2 \sin(2 \theta) B_{pq})^2
\end{align*}

So we have
\begin{align*}
< \tilde{p}| r | \tilde{p} >^2 + < \tilde{q}| r | \tilde{q} >^2 &= (\cos^4(\theta) + \sin^4(\theta)) B_{pp}^2 \\
&+ (\cos^4(\theta) + \sin^4(\theta)) B_{qq}^2 \\
&+ (2 \cos^2(\theta)\sin(2 \theta) - 2 \sin^2(\theta)\sin(2 \theta)) B_{qq} B_{pq} \\
&+ (2 \sin^2(\theta)\sin(2 \theta) - 2 \cos^2(\theta)\sin(2 \theta)) B_{pp} B_{pq} \\
&+ 4 \cos^2(\theta) \sin^2(\theta) B_{pp} B_{qq} \\
&+ 2 \sin^2(2 \theta) B_{pq}^2.
\end{align*}

Since:
$$\cos^2(\theta) - \sin^2(\theta) = \cos(2 \theta) $$
$$\sin(\theta) \cos(\theta) = \frac{1}{2} \sin(2 \theta) $$
$$\sin^2(\theta) = \frac{1 - \cos(2 \theta)}{2}  $$
It becomes
\begin{align*}
< \tilde{p}| r | \tilde{p} >^2 + < \tilde{q}| r | \tilde{q} >^2 &= (\cos^4(\theta) + \sin^4(\theta)) (B_{pp}^2 + B_{pp}^2) \\
&+ \sin(4\theta) B_{pq} (-B_{pp} + B_{qq}) \\
&+ \sin^2(2\theta) B_{pp} B_{qq} \\
&+ 2 \sin^2(2\theta) B_{pq}^2
\end{align*}

And with
$$ \cos^4(\theta) + \sin^4(\theta) = \frac{1}{4} (3 + \cos(4\theta))$$

we have
\begin{align*}
< \tilde{p}| r | \tilde{p} >^2 + < \tilde{q}| r | \tilde{q} >^2 
&= B_{pp}^2 + B_{qq}^2 -\frac{1}{4} [(1-\cos(4\theta) \beta + \sin(4\theta) \gamma].
\end{align*}

with
$$ \beta = (B_{pp} - B_{qq})^2 - 4 B_{pq}^2 $$ 
$$ \gamma = 4 B_{pq} (B_{pp} - B_{qq}) $$

Consequently:
\begin{align*}
C_1(\theta) &= \sum_{i=1}^N \left[ A_{ii} - B_{ii}^2 \right] \\ 
&- \left[  A_{pp} - B_{pp}^2 +  A_{qq} - B_{qq}^2 \right] \\
&+ \left[  A_{pp} +  A_{qq} - B_{pp}^2 - B_{qq}^2
+ \frac{1}{4} [(1-\cos(4\theta) \beta + \sin(4\theta) \gamma] \right] \\
&= C_1(\theta=0) + \frac{1}{4} [(1-\cos(4\theta)) \beta + \sin(4\theta) \gamma]
\end{align*}

The derivatives are:
\begin{align*}
\frac{\partial C_1(\theta)}{\partial \theta} = \beta \sin(4\theta) + \gamma \sin(4 \theta)
\end{align*}

\begin{align*}
\frac{\partial^2 C_1(\theta)}{\partial \theta^2} = 4 \beta \cos(4\theta) - 4 \gamma \cos(4 \theta)
\end{align*}

Similarly:
\begin{align*}
C_3(\theta) &= \sum_{i=1}^N [B_{ii}^2] \\
&- B_{pp}^2 - B_{qq}^2 \\
&+ B_{pp}^2 + B_{qq}^2 - \frac{1}{4} [(1-\cos(4\theta) \beta + \sin(4\theta) \gamma] \\
&= C_3(\theta=0) - \frac{1}{4} [(1-\cos(4\theta)) \beta + \sin(4\theta) \gamma]
\end{align*}

The derivatives are:
\begin{align*}
\frac{\partial C_3(\theta)}{\partial \theta} = - \beta \sin(4\theta) - \gamma \sin(4 \theta)
\end{align*}

\begin{align*}
\frac{\partial^2 C_3(\theta)}{\partial \theta^2} = - 4 \beta \cos(4\theta) + 4 \gamma \cos(4 \theta)
\end{align*}


Locality of the orbitals:
- cite Hoyvik
As the Foster-Boys method tries to minimize the sum of the second
moment MO spread, the locality of each MO can be expressed as the
second moment of the MO spread. For the MO i, the locality criterion is
\begin{align*}
\sigma_i &= \sqrt{ <i|r^2|i> - <i|r|i>^2} \\
&= \sqrt{ <i|x^2|i> - <i|x|i>^2 + <i|y^2|i> - <i|y|i>^2 + <i|z^2|i> - <i|z|i>^2}
\end{align*} 

Localization procedure:

To do the localization we have compute the gradient and the
diagonal hessian of the Foster-Boys criterion with respect to the MO
rotations and we minimize it with the Newton method.
Since we already have compute the first and second derivatives of the
FB with respect to the MO rotations we have the analytical gradient
and diagonal hessian. Hovik uses an other method in her algorithm and
it seems to work very for big systems.

TODO: add trust region

In order to avoid the problem of starting on a saddle point, the
localization procedure starts by giving a little kick in the MOs in
order to break the symmetry and escape from a possible saddle point.

In order to speed up the iteration we compute the gradient, the
diagonal hessian and the step in temporary matrices of the size
(number MOs in mo_class by number MOs in mo_class)

** IDK

Variables:

NB: The indexes i and j refere to the positions of the elements in
the "full space", i.e., the arrays containing elements for all the MOs,
but the indexes tmp_i and tmp_j to the positions of the elements in
the "reduced space/subspace", i.e., the arrays containing elements for
a restricted number of MOs. 
Example:
The gradient for the localization of the core MOs can be expressed 
as a vector of length mo_num*(mo_num-1)/2 with only
n_core_orb*(n_core_orb-1)/2 non zero elements, so it is more relevant
to use a vector of size n_core_orb*(n_core_orb-1)/2.
So here the gradient is a vector of size
tmp_list_size*(tmp_list_size)/2 where tmp_list_size is the number of
MOs is the corresponding mo class.
The same thing happened for the hessian, the matrix containing the
step and the rotation matrix, which are tmp_list_size by tmp_list_size
matrices. 

TODO: improve the previous paragraph

The dipoles are updated using the ao_to_mo subroutine without the
restore_symmetry which is actually in N^4 but can be rewrite in N^2
log(N^2).
The bottleneck of the program is normally N^3 with the matrix
multiplications/diagonalizations. The use of the full hessian can be
an improvement but it will scale in N^4...  

#+BEGIN_SRC f90 :comments org :tangle localization.irp.f
program localization
 call run_localization
end

subroutine run_localization

  include 'constants.h'

  implicit none

  ! Variables
  double precision, allocatable :: m_theta(:,:), pre_rot(:,:), R(:,:), R2(:,:), m_x(:,:), m_x2(:,:), x(:)
  double precision, allocatable :: prev_mos(:,:), spatial_extent(:), tmp_R(:,:)
  double precision :: criterion, angle_pre_rot
  double precision :: theta_max
  integer          :: i_theta_max, j_theta_max
  integer          :: i,j,k,l,p, tmp_i, tmp_j, tmp_k
  integer          :: mo_beg, mo_end
  integer          :: n_occ
  integer          :: info
  integer          :: n, tmp_n, tmp_list_size
  double precision, allocatable :: v_grad(:), H(:,:), tmp_m_x(:,:), tmp_x(:), e_val(:), W(:,:)
  double precision :: max_elem, t1, t2, t3, t4, t5, t6
  integer, allocatable :: tmp_list(:)
  double precision :: prev_criterion, rho, delta, criterion_model
  integer ::  nb_iter

  !restore_symm = .False.
  !SOFT_TOUCH restore_symm
 
  n = mo_num*(mo_num-1)/2

  ! Allocation
  !allocate(v_grad(n), H(n,n), x(n))
  allocate(spatial_extent(mo_num), R2(mo_num,mo_num))
  allocate(m_theta(mo_num, mo_num), pre_rot(mo_num, mo_num), R(mo_num, mo_num))
  allocate(prev_mos(ao_num, mo_num), m_x(mo_num,mo_num), m_x2(mo_num, mo_num))

  call nb_occ_om(n_occ)

  ! Locality before the localization
  call compute_spatial_extent(spatial_extent)

  print*, 'elec_num:', elec_num
  print*, 'mo_num:', mo_num

  call compute_criterion(criterion)
  print*,'HF', HF_energy
  print*,'Criterion:', criterion
#+END_SRC

** Pre rotation
In order to give a little kick in the system
#+BEGIN_SRC f90 :comments org :tangle localization.irp.f
  ! Initialization
  pre_rot = 0d0

  ! Angle for the pre rotation
  angle_pre_rot = 1d-1

  ! Pre rotation for core MOs
  if (dim_list_core_orb >= 2) then
    do tmp_j = 1, dim_list_core_orb
      j = list_core(tmp_j)
      do tmp_i = 1, dim_list_core_orb
        i = list_core(tmp_i)
        if (i > j) then
          pre_rot(i,j) = angle_pre_rot
        elseif (i < j) then
          pre_rot(i,j) = - angle_pre_rot
        else
          pre_rot(i,j) = 0d0
        endif
      enddo
    enddo
  endif

!  ! Pre rotation for core MOs
!  if (n_core_orb >= 2) then
!    do i = 1, n_core_orb
!      do j = 1, n_core_orb
!        if (i > j) then
!          pre_rot(i,j) = angle_pre_rot
!        elseif (i < j) then
!          pre_rot(i,j) = - angle_pre_rot
!        else
!          pre_rot(i,j) = 0d0
!        endif
!      enddo
!    enddo
!  endif
  
  ! Pre rotation for active MOs
  if (dim_list_act_orb >= 2) then
    do tmp_j = 1, dim_list_act_orb
      j = list_act(tmp_j)
      do tmp_i = 1, dim_list_act_orb
        i = list_act(tmp_i)
        if (i > j) then
          pre_rot(i,j) = angle_pre_rot
        elseif (i < j) then
          pre_rot(i,j) = - angle_pre_rot
        else
          pre_rot(i,j) = 0d0
        endif
      enddo
    enddo
  endif

  ! Pre rotation for inactive MOs
  if (dim_list_inact_orb >= 2) then
    do tmp_j = 1, dim_list_inact_orb
      j = list_inact(tmp_j)
      do tmp_i = 1, dim_list_inact_orb
        i = list_inact(tmp_i)
        if (i > j) then
          pre_rot(i,j) = angle_pre_rot
        elseif (i < j) then
          pre_rot(i,j) = - angle_pre_rot
        else
          pre_rot(i,j) = 0d0
        endif
      enddo
    enddo
  endif

!  ! Pre rotation for occ MOs
!  do i = n_core_orb + 1, n_occ
!    do j = n_core_orb + 1, n_occ
!      if (i > j) then
!        pre_rot(i,j) = angle_pre_rot
!      elseif (i < j) then
!        pre_rot(i,j) = - angle_pre_rot
!      else
!        pre_rot(i,j) = 0d0
!      endif
!    enddo
!  enddo

  ! Pre rotation for virtual MOs
  if (dim_list_virt_orb >= 2) then
    do tmp_j = 1, dim_list_virt_orb
      j = list_virt(tmp_j)
      do tmp_i = 1, dim_list_virt_orb
        i = list_virt(tmp_i)
        if (i > j) then
          pre_rot(i,j) = angle_pre_rot
        elseif (i < j) then
          pre_rot(i,j) = - angle_pre_rot
        else
          pre_rot(i,j) = 0d0
        endif
      enddo
    enddo
  endif

!  ! Pre rotation for vir MOs
!  do i = n_occ + 1, mo_num
!    do j = n_occ + 1, mo_num
!      if (i > j) then
!        pre_rot(i,j) = angle_pre_rot
!      elseif (i < j) then
!        pre_rot(i,j) = - angle_pre_rot
!      else
!        pre_rot(i,j) = 0d0
!      endif
!    enddo
!  enddo

  ! Nothing for deleted ones

  call org_rotation_matrix(pre_rot,mo_num,R,mo_num,mo_num,info)
  !call apply_mo_rotation(R,mo_coef,new_mos)
  call org_apply_mo_rotation(R,prev_mos)

  TOUCH mo_coef
#+END_SRC

** Loc
#+BEGIN_SRC f90 :comments org :tangle localization.irp.f
  call compute_criterion(criterion)
  print*,'### After pre rotation :'
  print*,'HF', HF_energy
  print*,'Criterion:', criterion

  print*,''
  print*,'========================'
  print*,'  Orbital localization'
  print*,'========================'
  print*,'' 
    
!  do k = 1, 100
!     
!    call compute_theta(m_theta)
!    !
!    !  ! Test pair wise rotation
!    call research_max_theta(mo_beg, mo_end, m_theta, i_theta_max, j_theta_max, theta_max)
!    print*,'i_theta_max:', i_theta_max
!    print*,'j_theta_max:', j_theta_max
!    print*,' theta_max:', theta_max
!    !
!    !  ! Pair wise rotation
!    !  !call apply_pairwise_rotation(i_theta_max, j_theta_max, theta_max)
!    !
!    !  m_x = 0d0
!    !  x = 0d0
!    !
!    !  do j = mo_beg, mo_end
!    !    do i = mo_beg, mo_end
!    !      m_x(i,j) = m_theta(i,j) * 0.1d0
!    !    enddo
!    !  enddo
!    !
!    !  call org_rotation_matrix(m_x,mo_num,R,mo_num,mo_num,info)
!    !  call apply_mo_rotation(R,mo_coef,new_mos)
!    !
!    !  call compute_criterion(criterion)
!    !  print*,'Criterion:', criterion
!    
!    !!!!! Newton method's !!!!
!    mo_beg = n_occ+1
!    mo_end = mo_num
!    
!    call H_orb_loc(n, mo_beg, mo_end,H)
!    
!    call gradient_orb_loc(n, mo_beg, mo_end, v_grad, max_elem)
!    print*, 'Max element in gradient:', mo_beg, mo_end, max_elem
!    call x_orb_loc(n, v_grad, H, m_x)
!    
!    call org_rotation_matrix(m_x,mo_num,R,mo_num,mo_num,info)
!    call apply_mo_rotation(R,mo_coef,new_mos)
!    
!    call compute_criterion(criterion)
!    print*,'Criterion:', mo_beg, mo_end, criterion
!    
!    TOUCH mo_coef 
!  enddo

  logical :: not_converged, not_core_converged, not_occ_converged, not_vir_converged
  logical :: not_act_converged, not_inact_converged, not_virt_converged
  logical :: use_trust_region, must_exit, cancel_step

  !Initialization
  not_converged = .TRUE.
  use_trust_region = .TRUE. !.FALSE.

  if (dim_list_core_orb >= 2) then
    not_core_converged = .TRUE.
  else
    not_core_converged = .FALSE. 
  endif
  
  if (dim_list_act_orb >= 2) then
    not_act_converged = .TRUE.
  else
    not_act_converged = .FALSE.
  endif

  if (dim_list_inact_orb >= 2) then
    not_inact_converged = .TRUE.
  else
    not_inact_converged = .FALSE.
  endif

  if (dim_list_virt_orb >= 2) then
    not_virt_converged = .TRUE.
  else
    not_virt_converged = .FALSE.
  endif
 
  do l = 1, 4

    if (l==1) then ! core
      not_converged = not_core_converged
      tmp_list_size = dim_list_core_orb
    elseif (l==2) then ! act
      not_converged = not_act_converged
      tmp_list_size = dim_list_act_orb
    elseif (l==3) then ! inact
      not_converged = not_inact_converged
      tmp_list_size = dim_list_inact_orb
    else ! virt
      not_converged = not_virt_converged
      tmp_list_size = dim_list_virt_orb
    endif
   
    allocate(tmp_list(tmp_list_size))

    if (l==1) then ! core
      tmp_list = list_core
    elseif (l==2) then
      tmp_list = list_act
    elseif (l==3) then
      tmp_list = list_inact
    else
      tmp_list = list_virt
    endif
   
    tmp_n = tmp_list_size * (tmp_list_size - 1)/2
  
    ! Allocation of tmp gradient and hessian
    allocate(v_grad(tmp_n), H(tmp_n, tmp_n), tmp_m_x(tmp_list_size, tmp_list_size), tmp_R(tmp_list_size, tmp_list_size))
    allocate(tmp_x(tmp_n), e_val(tmp_n), W(tmp_n,tmp_n))

    ! Initialization for trust region
    delta = 0d0
    rho = 0.5d0
    nb_iter = 0 
    call compute_criterion(prev_criterion)
    print*,'prev_criterion', prev_criterion

    print*,'l:',l 

      !!!!!Test
      !### Initialization ###
      nb_iter = 0 ! Must start at 0 !!!
      rho = 0.5d0
      !not_converged = .True.

      ! ### TODO ###
      ! Compute the criterion before the loop
      call compute_criterion(prev_criterion) 

      do while (not_converged)
        ! ### TODO ## 
        ! Call your gradient
        ! Call you hessian

        call gradient_tmp_orb_loc_v2(tmp_n, tmp_list_size, tmp_list, v_grad, max_elem)
        print*, 'Max element in gradient:', tmp_list(1), tmp_list(tmp_list_size), max_elem
        ! Diagonal hessian
        call H_diag_tmp_orb_loc_v2(tmp_n, tmp_list_size, tmp_list, H)

        cancel_step = .True. ! To enter in the loop just after 
        ! Loop to Reduce the trust radius until the criterion decreases and rho >= thresh_rho
        do while (cancel_step)
          ! Hessian,gradient,Criterion -> x 
          call step_in_trust_region(tmp_n,tmp_list_size,H,v_grad,prev_criterion,rho,nb_iter,delta,criterion_model,tmp_x,must_exit) 
          if (must_exit) then
            ! ### Message ###
            ! if step_in_trust_region sets must_exit on true for numerical reasons
            print*,'algo_trust1 sends the message : Exit'
            exit
          endif
          !### TODO ###  
          ! Compute x -> m_x
          ! Compute m_x -> R
          ! Apply R and keep the previous MOs...
          ! Update/touch 
          ! Compute the new criterion/energy -> criterion

          ! 1D tmp -> 2D tmp 
          tmp_m_x = 0d0
          do tmp_j = 1, tmp_list_size - 1
            do tmp_i = tmp_j + 1, tmp_list_size
              call mat_to_vec_index(tmp_i,tmp_j,tmp_k)
              tmp_m_x(tmp_i, tmp_j) = tmp_x(tmp_k)
            enddo
          enddo
        
          ! Antisym
          do tmp_i = 1, tmp_list_size - 1
            do tmp_j = tmp_i + 1, tmp_list_size
              tmp_m_x(tmp_i,tmp_j) = - tmp_m_x(tmp_j,tmp_i) 
            enddo
          enddo

          call org_rotation_matrix(tmp_m_x,tmp_list_size,tmp_R,tmp_list_size,tmp_list_size,info)
          ! tmp_R to R, subspace to full space
          R = 0d0
          do i = 1, mo_num
            R(i,i) = 1d0 ! 1 on the diagonal because it is a rotation matrix, 1 = nothing change for the corresponding orbital
          enddo
          do tmp_j = 1, tmp_list_size
            j = tmp_list(tmp_j)
            do tmp_i = 1, tmp_list_size
              i = tmp_list(tmp_i)
              R(i,j) = tmp_R(tmp_i,tmp_j)
            enddo
          enddo
          call org_apply_mo_rotation(R, prev_mos)   
          call ao_to_mo_no_sym(ao_dipole_x, ao_num, mo_dipole_x, mo_num)
          call ao_to_mo_no_sym(ao_dipole_y, ao_num, mo_dipole_y, mo_num)
          call ao_to_mo_no_sym(ao_dipole_z, ao_num, mo_dipole_z, mo_num)
          call compute_criterion(criterion)
          print*,'Criterion:', nb_iter, criterion

          ! Criterion -> step accepted or rejected 
          call is_step_cancel_trust_region(nb_iter,prev_criterion, criterion, criterion_model,rho,cancel_step)
          ! ### TODO ###
          !if (cancel_step) then
          ! Cancel the previous step (mo_coef = prev_mos if you keep them...)
          !endif

          if (cancel_step) then
            mo_coef = prev_mos
            ! pas besoind e recalculer vu qu'on garde le gradient et le hessien
          endif
        enddo
        !call save_mos() !### depend of the time for 1 iteration
        ! To exit the external loop if must_exti = .True.
        if (must_exit) then
          exit
        endif 
        ! Step accepted, nb iteration + 1
        nb_iter = nb_iter + 1
        ! ### TODO ###
        !if (###Conditions###) then
        ! no_converged = .False.
        !endif
        if (DABS(max_elem) < 1d-6) then
          not_converged = .False.
        endif
      enddo

      !!!!!!!!! END TEST !!!!!!!!!!!!!!!!!!!!!!!!!

!#      call wall_time(t1)
!#      ! Gradient
!#      call gradient_tmp_orb_loc_v2(tmp_n, tmp_list_size, tmp_list, v_grad, max_elem)
!#      print*, 'Max element in gradient:', tmp_list(1), tmp_list(tmp_list_size), max_elem
!#      ! Diagonal hessian
!#      call H_diag_tmp_orb_loc_v2(tmp_n, tmp_list_size, tmp_list, H)
!#      
!#      ! Without trust region
!#      if (.not. use_trust_region) then
!#        ! Step in the subspace
!#        call x_tmp_orb_loc_v2(tmp_n, tmp_list_size, tmp_list, v_grad, H,tmp_x, tmp_m_x)
!#      endif
!#
!#      ! With trust region
!#      if (use_trust_region) then
!#        ! Diagonalization of the hessian
!#        call org_diagonalization_hessian(tmp_n,H,e_val,w)
!#        e_val = ABS(e_val)
!#        call org_trust_region(tmp_n,tmp_list_size,nb_iter,thresh_eig,H,v_grad,rho,e_val,w,tmp_x,tmp_m_x,delta)
!#      endif
!#
!#      ! tmp_m_x to m_x, subspace to full space
!#      !m_x = 0d0
!#      !do tmp_j = 1, tmp_list_size
!#      !  j = tmp_list(tmp_j)
!#      !  do tmp_i = 1, tmp_list_size
!#      !    i = tmp_list(tmp_i)
!#      !    m_x(i,j) = tmp_m_x(tmp_i, tmp_j)
!#      !  enddo
!#      !enddo
!#
!#      ! Rotation matrix 
!#      !call org_rotation_matrix(m_x,mo_num,R,mo_num,mo_num,info)
!#      call org_rotation_matrix(tmp_m_x,tmp_list_size,tmp_R,tmp_list_size,tmp_list_size,info)
!#
!#!      if (use_trust_region) then
!#!        ! Estimation of the energy after the rotation
!#!        call org_trust_e_model(tmp_n,v_grad,H,tmp_x,prev_criterion,criterion_model)
!#!      endif
!#
!#      ! tmp_R to R, subspace to full space
!#      R = 0d0
!#      do i = 1, mo_num
!#        R(i,i) = 1d0 ! 1 on the diagonal because it is a rotation matrix, 1 = nothing change for the corresponding orbital
!#      enddo
!#      do tmp_j = 1, tmp_list_size
!#        j = tmp_list(tmp_j)
!#        do tmp_i = 1, tmp_list_size
!#          i = tmp_list(tmp_i)
!#          R(i,j) = tmp_R(tmp_i,tmp_j)
!#        enddo
!#      enddo
!#       
!#      ! Application to the mo_coef
!#      call org_apply_mo_rotation(R, prev_mos)   
!#  
!#      ! Update the dipoles
!#      call ao_to_mo_no_sym(ao_dipole_x, ao_num, mo_dipole_x, mo_num)
!#      call ao_to_mo_no_sym(ao_dipole_y, ao_num, mo_dipole_y, mo_num)
!#      call ao_to_mo_no_sym(ao_dipole_z, ao_num, mo_dipole_z, mo_num)
!#  
!#      ! New criterion after rotation + update dipoles
!#      call compute_criterion(criterion)
!#      print*,'Criterion:', k, criterion
!#     
!#      if (use_trust_region) then
!#        ! Calculation of rho 
!#        call org_rho_model(prev_criterion, criterion,criterion_model,thresh_rho, rho)
!#        !prev_criterion = criterion
!#
!#        if (nb_iter == 0) then
!#            nb_iter = 1 ! in order to enable the change of delta if the first iteration is cancelled  
!#        endif
!#
!#        if (rho >= thresh_rho) then !0.1d0) then
!#           ! exit, the step is accepted
!#           !cancel_step = .False.
!#        else
!#           ! Cancellation of the previous rotation
!#           mo_coef = prev_mos ! previous MOs 
!#           
!#           ! Update the dipoles
!#           call ao_to_mo_no_sym(ao_dipole_x, ao_num, mo_dipole_x, mo_num)
!#           call ao_to_mo_no_sym(ao_dipole_y, ao_num, mo_dipole_y, mo_num)
!#           call ao_to_mo_no_sym(ao_dipole_z, ao_num, mo_dipole_z, mo_num)
!#
!#           print*, '***********************'
!#           print*, 'Step cancel : rho < 0.1'
!#           print*, '***********************'
!#        endif
!#      endif 
!#      
!#      call wall_time(t2)
!#      t3 = t2 - t1
!#      print*, 'Time for one iteration:', t3
!#
!#      if (ABS(max_elem) < 1d-6) then
!#        not_converged = .FALSE.
!#      endif
!#
!#      ! tmp to stop algorithm when when the diff is too small and avoid some problems
!#      if (ABS(prev_criterion - criterion_model) < 1d-12) then
!#        not_converged = .FALSE.
!#        print*,''
!#        print*,'####################################################' 
!#        print*,'(ABS(prev_criterion - criterion_model) < 1d-12, exit'
!#        print*,'####################################################'
!#        print*,''
!#      endif
!#  
!#      k = k+1 
!#    enddo

    ! Deallocation
    deallocate(v_grad, H, tmp_m_x, tmp_R, tmp_list,tmp_x,e_val,W)
    
    call save_mos()
    TOUCH mo_coef 
    print*,'HF', HF_energy
    
  enddo

!do l = 1, 3
!  
!  if (l==1) then ! core
!    not_converged = not_core_converged
!    mo_beg = 1
!    mo_end = n_core_orb
!  elseif (l==2) then !  occ
!    not_converged = not_occ_converged
!     mo_beg = n_core_orb + 1
!    mo_end = n_occ
!  else ! vir
!    not_converged = not_vir_converged
!    mo_beg = n_occ + 1
!    mo_end = mo_num
!  endif
!
!  tmp_size = mo_end - mo_beg + 1
!  tmp_n = tmp_size * (tmp_size - 1)/2
!  
!  ! Allocation of tmp gradient and hessian
!  allocate(v_grad(tmp_n), H(tmp_n, tmp_n), tmp_m_x(tmp_size, tmp_size), tmp_R(tmp_size, tmp_size))
!
!  k = 1
!  do while (not_converged .and. k <= 100)
!
!    call wall_time(t4)
!    call wall_time(t1)
!    !call H_diag_orb_loc(n, mo_beg, mo_end,H)
!    call H_diag_tmp_orb_loc(tmp_n, tmp_size, mo_beg, mo_end, H)
!    call wall_time(t2)
!    t3 = t2 - t1
!    print*, 'H time', t3
!
!    call wall_time(t1)
!    !call gradient_orb_loc(n, mo_beg, mo_end, v_grad, max_elem)
!    call gradient_tmp_orb_loc(tmp_n, mo_beg, mo_end, v_grad, max_elem)
!    call wall_time(t2)
!    t3 = t2 - t1
!    print*, 'g time', t3
!    print*, 'Max element in gradient:', mo_beg, mo_end, max_elem
!
!    call wall_time(t1)
!    !call x_orb_loc(n, v_grad, H, m_x) 
!    call x_tmp_orb_loc(tmp_n, tmp_size, mo_beg, mo_end, v_grad, H, tmp_m_x)
!    call tmp_to_full(tmp_m_x, tmp_size, mo_beg, mo_end, m_x)
!    call wall_time(t2)
!    t3 = t2 - t1
!    print*, 'x time', t3
!  
!    !call wall_time(t1)
!    !call org_rotation_matrix(m_x,mo_num,R,mo_num,mo_num,info)
!    !call wall_time(t2)
!    !t3 = t2 - t1
!    !print*, 'R time', t3
!    
!    call wall_time(t1)
!    call org_rotation_matrix(tmp_m_x,tmp_size,tmp_R,tmp_size,tmp_size,info)
!    call tmp_to_full(tmp_R, tmp_size, mo_beg, mo_end, R2)
!    ! 1 sur les elements diag sans rotation !!!!
!    if (mo_beg > 1) then 
!      do i = 1, mo_beg - 1
!        R2(i,i) = 1d0    
!      enddo
!    endif
!    if (mo_end < mo_num) then
!      do i = mo_end + 1, mo_num
!        R2(i,i) = 1d0  
!      enddo
!    endif
!    call wall_time(t2)
!    t3 = t2 - t1
!    print*, 'R2 time', t3
!
!    call wall_time(t1)
!    call org_apply_mo_rotation(R2, prev_mos)
!    call wall_time(t2)
!    t3 = t2 - t1
!    print*, 'apply R time', t3
!    
!    call wall_time(t1)
!    call compute_criterion(criterion)
!    print*,'Criterion:', mo_beg, mo_end, criterion
!    call wall_time(t2)
!    t3 = t2 - t1
!    print*, 'Crit time', t3
!  
!    call wall_time(t1)  
!    !call ao_to_mo_no_sym(ao_dipole_x, ao_num, mo_dipole_x, mo_num)
!    !call ao_to_mo_no_sym(ao_dipole_y, ao_num, mo_dipole_y, mo_num)
!    !call ao_to_mo_no_sym(ao_dipole_z, ao_num, mo_dipole_z, mo_num)
!    call ao_to_mo_no_sym_tmp(tmp_size, mo_beg ,ao_dipole_x,ao_num,mo_dipole_x,mo_num)
!    call ao_to_mo_no_sym_tmp(tmp_size, mo_beg ,ao_dipole_y,ao_num,mo_dipole_y,mo_num)
!    call ao_to_mo_no_sym_tmp(tmp_size, mo_beg ,ao_dipole_z,ao_num,mo_dipole_z,mo_num)
!
!    !SOFT_TOUCH mo_coef
!    !PROVIDE mo_dipole_x mo_dipole_y mo_dipole_z
!    call wall_time(t2)
!    t3 = t2 - t1
!    print*, 'update dipole time', t3
!
!    if (ABS(max_elem) < 1d-6) then
!      not_converged = .FALSE.
!    endif
!    k = k+1
!
!    call wall_time(t5)
!    t6 = t5 - t4
!    print*, 'One cycle time', t6
!
!  enddo
!
!  if (.not. (n_core_orb < 2 .and. l==1)) then
!     call wall_time(t1)
!     SOFT_TOUCH mo_coef
!     PROVIDE mo_dipole_x mo_dipole_y mo_dipole_z
!     call save_mos()
!     call wall_time(t2)
!     t3 = t2 - t1
!     print*, 'touch mo_coef', t3
!  endif
!
!  deallocate(v_grad, H, tmp_m_x, tmp_R)
!  
!enddo

  TOUCH mo_coef 
  print*,'HF', HF_energy

  call compute_spatial_extent(spatial_extent)

end program  
#+END_SRC

$A_{12} = \langle 1 | r| 2 \rangle \langle 1 | r | 2 \rangle -
\frac{1}{4} (\langle 1 | r | 1 \rangle - \langle 2 | r | 2 \rangle)
(\langle 1 | r | 1 \rangle - \langle 2 | r | 2 \rangle)$

$B_{12} = (\langle 1 | r | 1 \rangle - \langle 2 | r | 2 \rangle)
\langle 1 | r| 2 \rangle$

#+BEGIN_SRC  f90 :comments org :tangle localization.irp.f
subroutine gradient_orb_loc(n, mo_beg, mo_end, v_grad, max_elem)
  
  implicit none
  
  integer, intent(in) :: n, mo_beg, mo_end
  double precision, intent(out) :: v_grad(n), max_elem
  double precision, allocatable :: m_grad(:,:)
  integer :: i,j,k,l
  double precision :: pi

  pi = 3.1415926535897932
  
  ! Allocation
  allocate(m_grad(mo_num, mo_num))
 
  ! Calculation
  m_grad = 0d0

  do j = mo_beg, mo_end
    do i = mo_beg, mo_end
      m_grad(i,j) = 4d0 * mo_dipole_x(i,j) * (mo_dipole_x(i,i) - mo_dipole_x(j,j)) &
                  +4d0 * mo_dipole_y(i,j) * (mo_dipole_y(i,i) - mo_dipole_y(j,j)) &
                  +4d0 * mo_dipole_z(i,j) * (mo_dipole_z(i,i) - mo_dipole_z(j,j))
    enddo
  enddo

  !m_grad = - m_grad ! A cause de la transposition de m**** dans la matrice de rotation que je n'ai toujours pas enlevé
  
  ! 2D -> 1D
  do k = 1, n
    call vec_to_mat_index(k,i,j)
    v_grad(k) = m_grad(i,j) 
  enddo

  ! Maximum element in the gradient
  max_elem = 0d0
  do k = 1, n
    if (ABS(v_grad(k)) > max_elem) then
      max_elem = ABS(v_grad(k))
    endif
  enddo 

  ! Deallocation
  deallocate(m_grad)

end subroutine

subroutine gradient_tmp_orb_loc(tmp_n, mo_beg, mo_end, v_grad, max_elem)
  
  implicit none
  
  integer, intent(in) :: tmp_n, mo_beg, mo_end
  double precision, intent(out) :: v_grad(tmp_n), max_elem
  double precision, allocatable :: m_grad(:,:)
  integer :: i,j,k,tmp_i,tmp_j,tmp_k, tmp_size
  double precision :: pi

  pi = 3.1415926535897932
  tmp_size = mo_end - mo_beg + 1 !size of the tmp array from mo_beg to mo_end
  
  ! Allocation
  allocate(m_grad(tmp_size, tmp_size))
 
  ! Calculation
  do tmp_j = 1, tmp_size
    call tmp_to_full_index(tmp_j,mo_beg,j)
    !q = j + mo_beg - 1
    do tmp_i = 1, tmp_size
      call tmp_to_full_index(tmp_i,mo_beg,i)
      !p = i + mo_beg - 1
      m_grad(tmp_i,tmp_j) = 4d0 * mo_dipole_x(i,j) * (mo_dipole_x(i,i) - mo_dipole_x(j,j)) &
                  +4d0 * mo_dipole_y(i,j) * (mo_dipole_y(i,i) - mo_dipole_y(j,j)) &
                  +4d0 * mo_dipole_z(i,j) * (mo_dipole_z(i,i) - mo_dipole_z(j,j))
    enddo
  enddo
  ! Peut être mis directement dans le vecteur de taille tmp_n

  !m_grad = - m_grad ! A cause de la transposition de m**** dans l'applicationde la matrice de rotation que je n'ai toujours pas enlevé
  
  ! 2D -> 1D
  do tmp_k = 1, tmp_n
    call vec_to_mat_index(tmp_k,tmp_i,tmp_j)
    v_grad(tmp_k) = m_grad(tmp_i,tmp_j) 
  enddo

  ! Maximum element in the gradient
  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (ABS(v_grad(tmp_k)) > max_elem) then
      max_elem = ABS(v_grad(tmp_k))
    endif
  enddo 

  ! Deallocation
  deallocate(m_grad)

end subroutine

subroutine gradient_tmp_orb_loc_v2(tmp_n, tmp_list_size, tmp_list, v_grad, max_elem)
  
  implicit none
  
  integer, intent(in) :: tmp_n, tmp_list_size, tmp_list(tmp_list_size)
  double precision, intent(out) :: v_grad(tmp_n), max_elem
  double precision, allocatable :: m_grad(:,:)
  integer :: i,j,k,tmp_i,tmp_j,tmp_k
  double precision :: pi

  pi = 3.1415926535897932
  
  ! Allocation
  allocate(m_grad(tmp_list_size, tmp_list_size))
 
  ! Calculation
  do tmp_j = 1, tmp_list_size
    j = tmp_list(tmp_j)
    do tmp_i = 1, tmp_list_size
      i = tmp_list(tmp_i)
      m_grad(tmp_i,tmp_j) = 4d0 * mo_dipole_x(i,j) * (mo_dipole_x(i,i) - mo_dipole_x(j,j)) &
                  +4d0 * mo_dipole_y(i,j) * (mo_dipole_y(i,i) - mo_dipole_y(j,j)) &
                  +4d0 * mo_dipole_z(i,j) * (mo_dipole_z(i,i) - mo_dipole_z(j,j))
    enddo
  enddo
  ! Peut être mis directement dans le vecteur de taille tmp_n

  !m_grad = - m_grad ! A cause de la transposition de m**** dans l'application de la matrice de rotation que je n'ai toujours pas enlevé
  
  ! 2D -> 1D
  do tmp_k = 1, tmp_n
    call vec_to_mat_index(tmp_k,tmp_i,tmp_j)
    v_grad(tmp_k) = m_grad(tmp_i,tmp_j) 
  enddo

  ! Maximum element in the gradient
  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (ABS(v_grad(tmp_k)) > max_elem) then
      max_elem = ABS(v_grad(tmp_k))
    endif
  enddo 

  ! Deallocation
  deallocate(m_grad)

end subroutine

subroutine H_orb_loc(n, mo_beg, mo_end, H)

  implicit none

  integer, intent(in) :: n, mo_beg, mo_end
  double precision, intent(out) :: H(n,n)
  double precision, allocatable :: H_4D(:,:,:,:), beta(:,:)
  integer :: i,j,k,l,pq,p,q,rs,r,s
  double precision :: max_elem

  ! Allocation
  allocate(H_4D(mo_num,mo_num,mo_num,mo_num), beta(mo_num,mo_num))
  
  ! Calculation
  beta = 0d0
  do j = mo_beg, mo_end
    do i = mo_beg, mo_end
      beta(i,j) = (mo_dipole_x(i,i) - mo_dipole_x(j,j))**2 - 4d0 * mo_dipole_x(i,j)**2 &
                 +(mo_dipole_y(i,i) - mo_dipole_y(j,j))**2 - 4d0 * mo_dipole_y(i,j)**2 &
                 +(mo_dipole_z(i,i) - mo_dipole_z(j,j))**2 - 4d0 * mo_dipole_z(i,j)**2
    enddo
  enddo

  H_4D = 0d0
  do j = mo_beg, mo_end 
    do i = mo_beg, mo_end
      H_4D(i,j,i,j) = 4d0 * beta(i,j)
    enddo
  enddo
  
  ! 4D -> 2D
  do rs = 1, n
    call vec_to_mat_index(rs,r,s)
    do pq = 1, n
      call vec_to_mat_index(pq,p,q)
      H(pq,rs) = H_4D(p,q,r,s)   
    enddo
  enddo

  max_elem = 0d0
  do i = 1, n
    if (H(i,i) < max_elem) then
      max_elem = H(i,i)
    endif
  enddo
  print*, 'Min elem H:', max_elem

  max_elem = 0d0
  do i = 1, n
    if (H(i,i) > max_elem) then
      max_elem = H(i,i)
    endif
  enddo
  print*, 'Max elem H:', max_elem
  
  max_elem = 1d10
  do i = 1, n
    if (ABS(H(i,i)) < ABS(max_elem)) then
      max_elem = H(i,i)
    endif
  enddo
  print*, 'Near 0 elem H:', max_elem

  ! Deallocation
  deallocate(H_4D, beta)

end subroutine

subroutine H_diag_tmp_orb_loc(tmp_n, tmp_size, mo_beg, mo_end, H)

  implicit none

  integer, intent(in) :: tmp_n, mo_beg, mo_end
  double precision, intent(out) :: H(tmp_n, tmp_n)
  double precision, allocatable :: beta(:,:)
  integer :: i,j,tmp_k,tmp_i, tmp_j, tmp_size
  double precision :: max_elem
    
  ! Allocation
  allocate(beta(tmp_size,tmp_size))
  
  ! Calculation
  do tmp_j = 1, tmp_size
    call tmp_to_full_index(tmp_j,mo_beg,j)
    !j = tmp_j + mo_beg - 1
    do tmp_i = 1, tmp_size
      call tmp_to_full_index(tmp_i,mo_beg,i)
      !i = tmp_i + mo_beg - 1
      beta(tmp_i,tmp_j) = (mo_dipole_x(i,i) - mo_dipole_x(j,j))**2 - 4d0 * mo_dipole_x(i,j)**2 &
                         +(mo_dipole_y(i,i) - mo_dipole_y(j,j))**2 - 4d0 * mo_dipole_y(i,j)**2 &
                         +(mo_dipole_z(i,i) - mo_dipole_z(j,j))**2 - 4d0 * mo_dipole_z(i,j)**2
    enddo
  enddo

  do tmp_k = 1, tmp_n
    call vec_to_mat_index(tmp_k,tmp_i,tmp_j)
    H(tmp_k,tmp_k) = 4d0 * beta(tmp_i, tmp_j)
  enddo
  
  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (H(tmp_k,tmp_k) < max_elem) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Min elem H:', max_elem

  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (H(tmp_k,tmp_k) > max_elem) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Max elem H:', max_elem
  
  max_elem = 1d10
  do tmp_k = 1, tmp_n
    if (ABS(H(tmp_k,tmp_k)) < ABS(max_elem)) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Near 0 elem H:', max_elem

  ! Deallocation
  deallocate(beta)

end subroutine

subroutine H_diag_tmp_orb_loc_v2(tmp_n, tmp_list_size, tmp_list, H)

  implicit none

  integer, intent(in) :: tmp_n, tmp_list_size, tmp_list(tmp_list_size)
  double precision, intent(out) :: H(tmp_n, tmp_n)
  double precision, allocatable :: beta(:,:)
  integer :: i,j,tmp_k,tmp_i, tmp_j
  double precision :: max_elem
    
  ! Allocation
  allocate(beta(tmp_list_size,tmp_list_size))
  
  ! Calculation
  do tmp_j = 1, tmp_list_size
    j = tmp_list(tmp_j)
    do tmp_i = 1, tmp_list_size
      i = tmp_list(tmp_i)
      beta(tmp_i,tmp_j) = (mo_dipole_x(i,i) - mo_dipole_x(j,j))**2 - 4d0 * mo_dipole_x(i,j)**2 &
                         +(mo_dipole_y(i,i) - mo_dipole_y(j,j))**2 - 4d0 * mo_dipole_y(i,j)**2 &
                         +(mo_dipole_z(i,i) - mo_dipole_z(j,j))**2 - 4d0 * mo_dipole_z(i,j)**2
    enddo
  enddo

  H = 0d0
  do tmp_k = 1, tmp_n
    call vec_to_mat_index(tmp_k,tmp_i,tmp_j)
    H(tmp_k,tmp_k) = 4d0 * beta(tmp_i, tmp_j)
  enddo
  
  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (H(tmp_k,tmp_k) < max_elem) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Min elem H:', max_elem

  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (H(tmp_k,tmp_k) > max_elem) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Max elem H:', max_elem
  
  max_elem = 1d10
  do tmp_k = 1, tmp_n
    if (ABS(H(tmp_k,tmp_k)) < ABS(max_elem)) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Near 0 elem H:', max_elem

  ! Deallocation
  deallocate(beta)

end subroutine

subroutine x_orb_loc(n, v_grad, H, m_x)

  implicit none

  integer, intent(in) :: n
  double precision, intent(in) :: v_grad(n)
  double precision, intent(in) :: H(n,n)
  double precision, intent(out) :: m_x(mo_num, mo_num)
  double precision, allocatable :: x(:)
  double precision :: lambda , accu, max_elem
  integer :: i,j,k, mo_beg, mo_end

  ! Allocation
  allocate(x(n))

  ! Level shifted hessian
  lambda = 0d0
  do i = 1, n
    if (H(i,i) < lambda) then
      lambda = H(i,i)
    endif
  enddo

  ! min element in the hessian
  if (lambda < 0d0) then
    lambda = -lambda + 1d-6
  endif  
  
  print*, 'lambda', lambda
 
  x = 0d0
  ! Good
  do i = 1, n
    if (ABS(H(i,i)) > 1d-6) then
      x(i) = - 1d0/(ABS(H(i,i))+lambda) *  v_grad(i)!(-v_grad(i)) 
    endif
  enddo
  
  ! 1D -> 2D
  m_x = 0d0
  do j = 1, mo_num
    do i = 1, mo_num
      if (i>j) then
        call mat_to_vec_index(i,j,k)
        m_x(i,j) = x(k)
      else
        m_x(i,j) = 0d0
      endif
    enddo
  enddo

  do j = 1, mo_num
    do i = 1, mo_num
      if (i<j) then
        m_x(i,j) = - m_x(j,i)
      endif
    enddo
  enddo

  ! Deallocation
  deallocate(x)

end subroutine

subroutine x_tmp_orb_loc(tmp_n, tmp_size, mo_beg, mo_end, v_grad, H, tmp_m_x)

  implicit none

  integer, intent(in) :: tmp_n, mo_beg, mo_end, tmp_size
  double precision, intent(in) :: v_grad(tmp_n)
  double precision, intent(in) :: H(tmp_n, tmp_n)
  double precision, intent(out) :: tmp_m_x(tmp_size, tmp_size)
  double precision, allocatable :: x(:)
  double precision :: lambda , accu, max_elem
  integer :: i,j,tmp_i,tmp_j,tmp_k

  ! Allocation
  allocate(x(tmp_n))

  ! Level shifted hessian
  lambda = 0d0
  do tmp_k = 1, tmp_n
    if (H(tmp_k,tmp_k) < lambda) then
      lambda = H(tmp_k,tmp_k)
    endif
  enddo

  ! min element in the hessian
  if (lambda < 0d0) then
    lambda = -lambda + 1d-6
  endif  
  
  print*, 'lambda', lambda
 
  ! Good
  do tmp_k = 1, tmp_n
    if (ABS(H(tmp_k,tmp_k)) > 1d-6) then
      x(tmp_k) = - 1d0/(ABS(H(tmp_k,tmp_k))+lambda) * v_grad(tmp_k)!(-v_grad(tmp_k)) 
    endif
  enddo

  ! 1D tmp -> 2D tmp 
  tmp_m_x = 0d0
  do tmp_j = 1, tmp_size - 1
    do tmp_i = tmp_j + 1, tmp_size
      call mat_to_vec_index(tmp_i,tmp_j,tmp_k)
      tmp_m_x(tmp_i, tmp_j) = x(tmp_k)
    enddo
  enddo

  ! Antisym, pourrait être mieux avec m_x - m_x^T ?
  do tmp_i = 1, tmp_size - 1
    do tmp_j = tmp_i + 1, tmp_size
      tmp_m_x(tmp_i,tmp_j) = - tmp_m_x(tmp_j,tmp_i) 
    enddo
  enddo

  ! Deallocation
  deallocate(x)

end subroutine

subroutine x_tmp_orb_loc_v2(tmp_n, tmp_list_size, tmp_list, v_grad, H,tmp_x, tmp_m_x)

  implicit none

  integer, intent(in) :: tmp_n, tmp_list_size, tmp_list(tmp_list_size)
  double precision, intent(in) :: v_grad(tmp_n)
  double precision, intent(in) :: H(tmp_n, tmp_n)
  double precision, intent(out) :: tmp_m_x(tmp_list_size, tmp_list_size), tmp_x(tmp_list_size)
  !double precision, allocatable :: x(:)
  double precision :: lambda , accu, max_elem
  integer :: i,j,tmp_i,tmp_j,tmp_k

  ! Allocation
  !allocate(x(tmp_n))

  ! Level shifted hessian
  lambda = 0d0
  do tmp_k = 1, tmp_n
    if (H(tmp_k,tmp_k) < lambda) then
      lambda = H(tmp_k,tmp_k)
    endif
  enddo

  ! min element in the hessian
  if (lambda < 0d0) then
    lambda = -lambda + 1d-6
  endif  
  
  print*, 'lambda', lambda
 
  ! Good
  do tmp_k = 1, tmp_n
    if (ABS(H(tmp_k,tmp_k)) > 1d-6) then
       tmp_x(tmp_k) = - 1d0/(ABS(H(tmp_k,tmp_k))+lambda) * v_grad(tmp_k)!(-v_grad(tmp_k))
      !x(tmp_k) = - 1d0/(ABS(H(tmp_k,tmp_k))+lambda) * (-v_grad(tmp_k)) 
    endif
  enddo

  ! 1D tmp -> 2D tmp 
  tmp_m_x = 0d0
  do tmp_j = 1, tmp_list_size - 1
    do tmp_i = tmp_j + 1, tmp_list_size
      call mat_to_vec_index(tmp_i,tmp_j,tmp_k)
      tmp_m_x(tmp_i, tmp_j) = tmp_x(tmp_k)!x(tmp_k)
    enddo
  enddo

  ! Antisym, pourrait être mieux avec m_x - m_x^T ?
  do tmp_i = 1, tmp_list_size - 1
    do tmp_j = tmp_i + 1, tmp_list_size
      tmp_m_x(tmp_i,tmp_j) = - tmp_m_x(tmp_j,tmp_i) 
    enddo
  enddo

  ! Deallocation
  !deallocate(x)

end subroutine

subroutine compute_gradient(mo_beg, mo_end, m_x)

  implicit none
  
  integer, intent(in) :: mo_beg, mo_end
  double precision, intent(out) :: m_x(mo_num, mo_num)
  double precision, allocatable :: gradient(:), hessian(:,:), x(:)
  double precision, allocatable :: m_gradient(:,:), beta(:,:), gamma(:,:), H(:,:,:,:)
  double precision :: accu, max_elem
  integer :: i,j,k,p,q,pq,r,s,rs,n

  n = mo_num*(mo_num-1)/2

  allocate(m_gradient(mo_num, mo_num))
  allocate(beta(mo_num, mo_num), gamma(mo_num, mo_num), H(mo_num,mo_num,mo_num,mo_num))
  allocate(hessian(n,n), x(n), gradient(n))

  beta = 0d0
  do j = 1, mo_num
    do i = 1, mo_num
      beta(i,j) = (mo_dipole_x(i,i) - mo_dipole_x(j,j))**2 - 4d0 *  mo_dipole_x(i,j)**2 &
                 +(mo_dipole_y(i,i) - mo_dipole_y(j,j))**2 - 4d0 *  mo_dipole_y(i,j)**2 &
                 +(mo_dipole_z(i,i) - mo_dipole_z(j,j))**2 - 4d0 *  mo_dipole_z(i,j)**2
    enddo
  enddo

  gamma = 0d0
  do j = 1, mo_num
    do i = 1, mo_num
      gamma(i,j) = 4d0 * mo_dipole_x(i,j) * (mo_dipole_x(i,i) - mo_dipole_x(j,j)) &
                  +4d0 * mo_dipole_y(i,j) * (mo_dipole_y(i,i) - mo_dipole_y(j,j)) &
                  +4d0 * mo_dipole_z(i,j) * (mo_dipole_z(i,i) - mo_dipole_z(j,j))
    enddo
  enddo

  m_gradient = 0d0
  do j = 1, mo_num
    do i = 1, mo_num
      m_gradient(i,j) = beta(i,j) * dsin(0d0) + gamma(i,j) * dcos(0d0) 
    enddo
  enddo

  do k = 1, n
    call vec_to_mat_index(k,i,j)
    gradient(k) = m_gradient(i,j)
  enddo 

  do k = 1, n
    call vec_to_mat_index(k,i,j)
  enddo

  max_elem = 0d0
  do k = 1, n
    if (ABS(gradient(k)) > max_elem) then
      max_elem = ABS(gradient(k))
    endif
  enddo 
  print*, "Max element in the gradient:", max_elem

  H = 0d0
  do j = 1, mo_num
    do i = 1, mo_num
      H(i,j,i,j) = 4d0 * beta(i,j) * dcos(0d0) - 4d0 * gamma(i,j) * dsin(0d0)
    enddo
  enddo
  
  do rs = 1, n
    call vec_to_mat_index(rs,r,s)
    do pq = 1, n
      call vec_to_mat_index(pq,p,q)
      hessian(pq,rs) = H(p,q,r,s)   
    enddo
  enddo

  accu = 0d0
  do i = 1, n
    if (hessian(i,i) < accu) then
      accu = hessian(i,i)
    endif
  enddo
  accu = accu - 1d-6

  do i = 1, n
    hessian(i,i) = hessian(i,i) - accu
  enddo

  x = 0d0
  do i = 1, n 
    if (ABS(hessian(i,i)) > 1d-6) then
      x(i) = - 1d0/hessian(i,i) * (-gradient(i))
    else
      x(i) = 0d0
    endif
  enddo

  print*,'norm_grad', sum(gradient(:)**2)

  m_x = 0d0
  do j = mo_beg, mo_end
    do i = mo_beg, mo_end
      if (i>j) then
        call mat_to_vec_index(i,j,k)
        m_x(i,j) = x(k)
      else
        m_x(i,j) = 0d0
      endif
    enddo
  enddo

  do j = mo_beg, mo_end
    do i = mo_beg, mo_end
      if (i<j) then
        m_x(i,j) = - m_x(j,i)
      endif
    enddo
  enddo

  !print*,'hessian:'
  !do i = 1, n
  !  write(*,'(100(E12.5))') hessian(i,:)
  !enddo

  !print*,'gradient:'
  !do i = 1, n
  !  write(*,'(100(E12.5))') m_gradient(i,:)
  !enddo
end subroutine

subroutine compute_theta(m_theta)

  implicit none
  
  integer :: i,j
  double precision, intent(out) :: m_theta(mo_num, mo_num)

  double precision, allocatable :: A12(:,:), B12(:,:)
  double precision :: pi

  pi = 3.1415926535897932

  allocate(A12(mo_num, mo_num), B12(mo_num, mo_num))
  
  !A12
  do j = 1, mo_num
    do i = 1, mo_num
      A12(i,j) = mo_dipole_x(i,j) * mo_dipole_x(i,j) &
                 - 0.25d0 * (mo_dipole_x(i,i) - mo_dipole_x(j,j)) * &
                 (mo_dipole_x(i,i) - mo_dipole_x(j,j)) &
                + &
                mo_dipole_y(i,j) * mo_dipole_y(i,j) &
                 - 0.25d0 * (mo_dipole_y(i,i) - mo_dipole_y(j,j)) * &
                 (mo_dipole_y(i,i) - mo_dipole_y(j,j)) &
                + &
                mo_dipole_z(i,j) * mo_dipole_z(i,j) &
                 - 0.25d0 * (mo_dipole_z(i,i) - mo_dipole_z(j,j)) * &
                 (mo_dipole_z(i,i) - mo_dipole_z(j,j))
    enddo
  enddo

  ! B12
  do j = 1, mo_num
    do i = 1, mo_num
      B12(i,j) = (mo_dipole_x(i,i) - mo_dipole_x(j,j)) * mo_dipole_x(i,j) &
                 + &
                 (mo_dipole_y(i,i) - mo_dipole_y(j,j)) * mo_dipole_y(i,j) &
                 + &
                 (mo_dipole_z(i,i) - mo_dipole_z(j,j)) * mo_dipole_z(i,j)
    enddo
  enddo

  ! m_theta
  do j = 1, mo_num
    do i = 1, mo_num
      if (i == j) then
        m_theta(i,j) = 0d0     !(-B12(i,j), A12(i,j)) ?? pourquoi j'avais mis le - ici ????
      elseif (0.25d0 * atan2(B12(i,j), -A12(i,j)) >= 0d0) then
        m_theta(i,j) =  0d0 * pi * 0.25d0 + 0.25d0 * atan2(B12(i,j), -A12(i,j))
      else
        m_theta(i,j) = - 0d0 *pi * 0.25d0 + 0.25d0 * atan2(B12(i,j), -A12(i,j))
      endif
    enddo
  enddo

end subroutine

subroutine compute_criterion(criterion)

  implicit none

  double precision, intent(out) :: criterion
  integer :: i

  ! Criterion (= \sum_i <i|r|i>^2 )
  criterion = 0d0
  do i = 1, mo_num
    criterion = criterion + mo_dipole_x(i,i)**2 + mo_dipole_y(i,i)**2 + mo_dipole_z(i,i)**2
  enddo
  criterion = - criterion

end subroutine

subroutine compute_spatial_extent(spatial_extent)

  implicit none
 
  double precision, intent(out) :: spatial_extent(mo_num)
  double precision :: average_core, average_occ, average_vir
  double precision :: std_var_core, std_var_occ, std_var_vir
  integer :: i,j,k,l, n_occ
   

  spatial_extent = 0d0
  
  do i = 1, mo_num
    spatial_extent(i) = mo_spread_x(i,i) - mo_dipole_x(i,i)**2
  enddo
  do i = 1, mo_num
    spatial_extent(i) = spatial_extent(i) + mo_spread_y(i,i) - mo_dipole_y(i,i)**2
  enddo
  do i = 1, mo_num
    spatial_extent(i) = spatial_extent(i) + mo_spread_z(i,i) - mo_dipole_z(i,i)**2
  enddo

  do i = 1, mo_num
    spatial_extent(i) = dsqrt(spatial_extent(i))
  enddo

  call nb_occ_om(n_occ)

  average_core = 0d0
  std_var_core = 0d0
  if (n_core_orb >= 2) then
    call compute_average_sp_ext(spatial_extent, 1, n_core_orb, average_core)
    call compute_std_var_sp_ext(spatial_extent, 1, n_core_orb, average_core, std_var_core)
  endif
  
  call compute_average_sp_ext(spatial_extent, n_core_orb + 1, n_occ, average_occ)
  call compute_std_var_sp_ext(spatial_extent, n_core_orb + 1, n_occ, average_occ, std_var_occ)
  
  call compute_average_sp_ext(spatial_extent, n_occ + 1, mo_num, average_vir)
  call compute_std_var_sp_ext(spatial_extent, n_occ + 1, mo_num, average_vir, std_var_vir)

  print*,''
  print*,'============================='
  print*,'  Spatial extent of the MOs'
  print*,'============================='
  print*,''

  print*, 'elec_num:', elec_num
  print*, 'core:', n_core_orb
  print*, 'occ:', n_occ
  print*, 'vir:', mo_num - n_occ
  print*, 'mo_num:', mo_num
  print*,''
   
  print*,'-- Core MOs --'
  print*,'Average:', average_core
  print*,'Std var:', std_var_core
  print*,''
  
  print*,'-- Occupied MOs --'
  print*,'Average:', average_occ
  print*,'Std var:', std_var_occ
  print*,''

  print*,'-- Virtual MOs --'
  print*,'Average:', average_vir
  print*,'Std var:', std_var_vir
  print*,''

  print*,'Spatial extent:'
  do i = 1, mo_num
    print*, i, spatial_extent(i)
  enddo

end

subroutine compute_average_sp_ext(spatial_extent, mo_beg, mo_end, average)

  implicit none

  integer, intent(in) :: mo_beg, mo_end
  double precision, intent(in) :: spatial_extent(mo_num)
  double precision, intent(out) :: average
  integer :: i,j, size

  size = mo_end - mo_beg + 1
  
  average = 0d0
  do i = mo_beg, mo_end
    average = average + spatial_extent(i)
  enddo

  average = average / DBLE(size)

end

subroutine compute_std_var_sp_ext(spatial_extent, mo_beg, mo_end, average, std_var)

  implicit none

  integer, intent(in) :: mo_beg, mo_end
  double precision, intent(in) :: spatial_extent(mo_num)
  double precision, intent(in) :: average
  double precision, intent(out) :: std_var
  integer :: i,j, size

  size = mo_end - mo_beg + 1
 
  std_var = 0d0

  do i = mo_beg, mo_end
    std_var = std_var + (spatial_extent(i) - average)**2
  enddo
  
  std_var = dsqrt(1d0/DBLE(size) * std_var)

end

subroutine research_max_theta(mo_beg, mo_end, m_theta, i_theta_max, j_theta_max, theta_max)

  implicit none

  integer, intent(in) :: mo_beg, mo_end
  double precision, intent(in) :: m_theta(mo_num, mo_num)
  integer, intent(out) :: i_theta_max, j_theta_max
  double precision, intent(out) :: theta_max
  integer :: i,j
  
  ! research the max theta for the MOs between mo_beg and mo_end

  theta_max = 0d0
  do j = mo_beg, mo_end
    do i = mo_beg, mo_end
      if (ABS(theta_max) <= ABS(m_theta(i,j))) then
        i_theta_max = i 
        j_theta_max = j 
        theta_max =  m_theta(i,j)
      endif
    enddo
  enddo

end subroutine

subroutine apply_pairwise_rotation(i_theta_max, j_theta_max, theta_max)

  implicit none

  integer, intent(in) :: i_theta_max, j_theta_max
  double precision, intent(in) :: theta_max
  double precision, allocatable :: new_mos(:,:)
  integer :: k

  allocate(new_mos(ao_num, mo_num))

  ! Rotation
  new_mos = mo_coef

  do k = 1, ao_num
    new_mos(k, i_theta_max) = mo_coef(k, i_theta_max) * cos(theta_max) &
                            + mo_coef(k, j_theta_max) * sin(theta_max)
    new_mos(k, j_theta_max) = - mo_coef(k, i_theta_max) * sin(theta_max) &
                            + mo_coef(k, j_theta_max) * cos(theta_max)
  enddo

  mo_coef = new_mos
  call save_mos()
  
  !call clear_mo_map
  !TOUCH mo_coef

end subroutine

! It works but it needs the four index integrals... => bad
!subroutine compute_hf_energy()
!
!  implicit none
!
!  double precision :: energy, mo_two_e_integral
!  integer :: i,j,k,l
!
!  energy = 0d0
!  do j = 1, mo_num
!    do i = 1, mo_num
!      energy = energy + mo_one_e_integrals(i,j) * one_e_dm_mo(i,j)
!    enddo
!  enddo
!
!  do l = 1, mo_num
!    do k = 1, mo_num
!      do j = 1, mo_num
!        do i = 1, mo_num
!          energy = energy +0.5d0 * mo_two_e_integral(i,j,k,l) * two_e_dm_mo(i,j,k,l)
!        enddo
!      enddo
!    enddo
!  enddo
!
!  energy = energy + nuclear_repulsion
!
!  print*,'energy scf', energy
!
!end subroutine
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle localization.irp.f
subroutine nb_occ_om(n_occ)
  
  implicit none
  
  integer, intent(out) :: n_occ ! number of occupied orbitals
  
  if (mod(elec_num,2) == 0) then
    n_occ = elec_num/2
  else
    n_occ = elec_num/2 + 1
  endif
  
end

subroutine tmp_to_full_index(tmp_i,mo_beg,i)

  implicit none
  
  ! For a square matrix M,m by m, we define a smaller square matrix T (=tmp) (mo_end - mo_beg + 1 by mo_end - mo_beg + 1)
  ! which contains the elements between mo_beg,mo_beg and mo_end,mo_end
  ! index i in T matrix corresponds to index p in M
  ! index j in T matrix corresponds to index q in M 

  integer, intent(in) :: tmp_i
  integer, intent(in) :: mo_beg
  integer, intent(out) :: i

  i = tmp_i + mo_beg - 1

end

subroutine full_to_tmp_index(i,mo_beg,tmp_i)

  implicit none
  
  ! For a square matrix M,m by m, we define a smaller square matrix T (=tmp) (mo_end - mo_beg + 1 by mo_end - mo_beg + 1)
  ! which contains the elements between mo_beg,mo_beg and mo_end,mo_end
  ! index tmp_i in T matrix corresponds to index i in M
  ! index tmp_j in T matrix corresponds to index i in M 

  integer, intent(in) :: i
  integer, intent(in) :: mo_beg
  integer, intent(out) :: tmp_i

  tmp_i = i - mo_beg + 1

end

subroutine tmp_to_full(tmp_m_x, tmp_size, mo_beg, mo_end, m_x)

  implicit none

  integer, intent(in) :: tmp_size, mo_beg, mo_end
  double precision, intent(in) :: tmp_m_x(tmp_size,tmp_size)
  double precision, intent(out) :: m_x(mo_num,mo_num) 
  integer :: i,j, tmp_i, tmp_j

  m_x = 0d0
  do j = mo_beg, mo_end
    call full_to_tmp_index(j, mo_beg, tmp_j)
    do i = mo_beg, mo_end
       call full_to_tmp_index(i, mo_beg, tmp_i)
       m_x(i,j) = tmp_m_x(tmp_i,tmp_j)
    enddo
  enddo

end


subroutine ao_to_mo_no_sym(A_ao,LDA_ao,A_mo,LDA_mo)
  implicit none
  BEGIN_DOC
  ! Transform A from the |AO| basis to the |MO| basis
  !
  ! $C^\dagger.A_{ao}.C$
  END_DOC
  integer, intent(in)            :: LDA_ao,LDA_mo
  double precision, intent(in)   :: A_ao(LDA_ao,ao_num)
  double precision, intent(out)  :: A_mo(LDA_mo,mo_num)
  double precision, allocatable  :: T(:,:)

  allocate ( T(ao_num,mo_num) )
  !DIR$ ATTRIBUTES ALIGN : $IRP_ALIGN :: T

  call dgemm('N','N', ao_num, mo_num, ao_num,                    &
      1.d0, A_ao,LDA_ao,                                             &
      mo_coef, size(mo_coef,1),                                      &
      0.d0, T, size(T,1))

  call dgemm('T','N', mo_num, mo_num, ao_num,                &
      1.d0, mo_coef,size(mo_coef,1),                                 &
      T, ao_num,                                                     &
      0.d0, A_mo, size(A_mo,1))

  deallocate(T)
end

subroutine ao_to_mo_no_sym_tmp(tmp_size, mo_beg ,A_ao,LDA_ao,A_mo,LDA_mo)
  implicit none
  BEGIN_DOC
  ! Transform A from the |AO| basis to the |MO| basis
  !
  ! $C^\dagger.A_{ao}.C$
  END_DOC
  integer, intent(in)            :: LDA_ao,LDA_mo,tmp_size, mo_beg
  double precision, intent(in)   :: A_ao(LDA_ao,ao_num)
  double precision, intent(out)  :: A_mo(LDA_mo,mo_num)
  double precision, allocatable  :: T(:,:)

  allocate ( T(ao_num,tmp_size) )
  !DIR$ ATTRIBUTES ALIGN : $IRP_ALIGN :: T

  call dgemm('N','N', ao_num, tmp_size, ao_num,                    &
      1.d0, A_ao,LDA_ao,                                             &
      mo_coef(1,mo_beg), size(mo_coef,1),                                      &
      0.d0, T, size(T,1))

  call dgemm('T','N', tmp_size, tmp_size, ao_num,                &
      1.d0, mo_coef(1,mo_beg),size(mo_coef,1),                                 &
      T, ao_num,                                                     &
      0.d0, A_mo(mo_beg,mo_beg), size(A_mo,1))

  deallocate(T)
end
#+END_SRC
