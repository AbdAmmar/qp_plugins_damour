* Orbital localization

Molecular orbitals localization

** Doc

The program localizes the orbitals in function of their mo_class:
- core MOs
- inactive MOs
- active MOs
- virtual MOs
- deleted MOs -> no orbital localization

Core MOs are localized with core MOs, inactives MOs are localized with
inactives MOs and so on. But deleted orbitals are not localized.

WARNING: 
- The user MUST SPECIFY THE MO CLASSES, otherwise the localization will be
done for all the orbitals between them, so the occupied and virtual
MOs will be combined together which is clearly not what we want to
do. 
- The mo class is not important (except "deleted") because it is not
link to the kind of MOs for CASSCF or CIPSI. It is just a way to
separate the MOs in order to localize them separetely, for example to
separate the core MOs, the occupied MOs and the virtuals MOs.
- The user MUST CHANGE THE MO CLASSES AFTER THE LOCALIZATION in order to
have the right mo class for his next calculation...

For more information on the mo classes:
qp set_mo_class -h

*** Foster-Boys localization
Foster-Boys localization:
- cite Foster
- cite Kleir 
- cite Hoyvik
- cite le papier des physiciens

The Foster-Boys localization is a method to generate localized MOs
(LMOs) by minimizing the Foster-Boys criterion:
$$ C_{FB} = \sum_{i=1}^N \left[ < \phi_i | r^2 | \phi_i > - < \phi_i | r |
\phi_i >^2 \right] $$.
In fact it is equivalent to maximise
$$ C_2 = \sum_{i>j, \ i=1}^N \left[  < \phi_i | r | \phi_i > -  <
\phi_j | r | \phi_j > \left]^2$$ 
or
$$ C_3 = \sum_{i=1}^N \left[ < \phi_i | r | \phi_i > \right]^2.$$

Where $\phi_i$ is an MO and $N$ the number of MOs,
\begin{align*}
< \phi_i | r^2 | \phi_i > &= < \phi_i | x^2 | \phi_i >  \\
&+ < \phi_i | y^2 | \phi_i > \\
&+ < \phi_i | z^2 | \phi_i >
\end{align*}
and
\begin{align*}
< \phi_i | r | \phi_i >^2 &= < \phi_i | x | \phi_i >^2  \\
&+ < \phi_i | y | \phi_i >^2 \\
&+ < \phi_i | z | \phi_i >^2
\end{align*}

 
Starting with a set of MOs $\left\{\phi_i\right\}_{i=1}^N$ and we
are looking for a new set of MOs $\left\{\tilde{\phi}_i\right\}_{i=1}^N$ which
minimizes the Foster-Boys criterion. This new set of MOs can be found
by applying a unitary transformation $\textbf{R}$ s.t. $\textbf{R} \cdot
\textbf{R}^T = \textbf{R}^T \cdot \textbf{R} = \textbf{I}$ on the
coefficients of the MOs. The unitary transformation matrix or rotation
matrix is obtained by exponentiating an antihermithian matrix
$\textbf{X}$, the elements $\textbf{X}_{ij}$ correspond to the
rotation angle between the MO i and the MO j. 
In the case where two MOs ($\phi_p$,$\phi_q$) are combined between them at each iteration it
is the Jacobi sweep method and the related rotation matrix is trivial:
\begin{align*}
\textbf{R}=
\begin{pmatrix}
\cos(\theta_{pq}) & \sin(\theta_{pq}) \\
- \sin(\theta_{pq}) & \cos(\theta_{pq})
\end{pmatrix}
\end{align*}

The application of $\textbf{R}$ on $\phi_p$ and $\phi_q$ leads to:
\begin{align*}
\tilde{\phi}_p &=  \phi_p \cos(\theta_{pq}) + \phi_q \sin(\theta_{pq}) \\
\tilde{\phi}_q &= -\phi_p \sin(\theta_{pq}) + \phi_q \cos(\theta_{pq})
\end{align*}

Consequently, the criterion becomes

\begin{align*}
C_{FB} &= \sum_{i=1}^N \left[ < \phi_i | r^2 | \phi_i > 
- < \phi_i | r | \phi_i >^2 \right] \\ 
&- \left[ < \phi_{p}| r^2 | \phi_{p} > - < \phi_{p} | r |
\phi_{p} >^2 +  < \phi_{q} | r^2 | \phi_{q}
> - < \phi_{q} | r | \phi_{q} >^2 \right] \\
&+ \left[ < \tilde{\phi}_p| r^2 | \tilde{\phi}_p > - < \tilde{\phi}_p | r |
\tilde{\phi}_p >^2 +  < \tilde{\phi}_q | r^2 | \tilde{\phi}_q
> - < \tilde{\phi}_q | r | \tilde{\phi}_q >^2 \right] 
\end{align*}

Noting 
$$A_{ii} = < \phi_i | r^2 | \phi_i > $$
$$B_{ii} = < \phi_i | r | \phi_i > $$
$$\tilde{\phi_p} = \tilde{p} $$ 

\begin{align*}
C_{FB}(\theta) &= \sum_{i=1}^N \left[ A_{ii} - A_{jj} \right] \\ 
&- \left[  A_{pp} - B_{pp}^2 +  A_{qq} - B_{qq}^2 \right] \\
&+ \left[ < \tilde{p}| r^2 | \tilde{p} > - < \tilde{p} | r |
\tilde{p} >^2 +  < \tilde{q} | r^2 | \phi_{\tilde{q}}
> - < \tilde{q} | r | \tilde{q} >^2 \right] 
\end{align*}

From that we have
\begin{align*}
< \tilde{p}| r^2 | \tilde{p} > &= <  p \cos(\theta) + q \sin(\theta) | r^2 | p \cos(\theta) + q \sin(\theta) > \\
&= \cos^2(\theta) A_{pp} + \sin^2(\theta) A_{qq} + 2 \sin(2 \theta) A_{pq}
\end{align*}

and 
\begin{align*}
< \tilde{q}| r^2 | \tilde{q} > &= <  -p \sin(\theta) + q \cos(\theta) | r^2 | -p \sin(\theta) + q \cos(\theta) > \\
&= \sin^2(\theta) A_{pp} + \cos^2(\theta) A_{qq} - 2 \sin(2 \theta) A_{pq}
\end{align*}

which leads to
\begin{align*}
< \tilde{p}| r^2 | \tilde{p} > + < \tilde{q}| r^2 | \tilde{q} > =
A_{pp} + A_{qq}.
\end{align*}

Clearly, these two terms do not depend of the rotation angle
$\theta_{pq}$. For that reason the derivatives with respect to $\textbf{X}$ of $C_{FB}$ is the same
that $-C_3$.

And for the two other terms
\begin{align*}
< \tilde{p}| r | \tilde{p} >^2 &= <  p \cos(\theta) + q \sin(\theta) | r | p \cos(\theta) + q \sin(\theta) >^2 \\
&= (\cos^2(\theta) B_{pp} + \sin^2(\theta) B_{qq} + 2 \sin(2 \theta) B_{pq})^2
\end{align*}

\begin{align*}
< \tilde{q}| r | \tilde{q} >^2 &= <  -p \sin(\theta) + q \cos(\theta) | r | -p \sin(\theta) + q \cos(\theta) >^2 \\
&= (\sin^2(\theta) B_{pp} + \cos^2(\theta) B_{qq} - 2 \sin(2 \theta) B_{pq})^2
\end{align*}

So we have
\begin{align*}
< \tilde{p}| r | \tilde{p} >^2 + < \tilde{q}| r | \tilde{q} >^2 &= (\cos^4(\theta) + \sin^4(\theta)) B_{pp}^2 \\
&+ (\cos^4(\theta) + \sin^4(\theta)) B_{qq}^2 \\
&+ (2 \cos^2(\theta)\sin(2 \theta) - 2 \sin^2(\theta)\sin(2 \theta)) B_{qq} B_{pq} \\
&+ (2 \sin^2(\theta)\sin(2 \theta) - 2 \cos^2(\theta)\sin(2 \theta)) B_{pp} B_{pq} \\
&+ 4 \cos^2(\theta) \sin^2(\theta) B_{pp} B_{qq} \\
&+ 2 \sin^2(2 \theta) B_{pq}^2.
\end{align*}

Since:
$$\cos^2(\theta) - \sin^2(\theta) = \cos(2 \theta) $$
$$\sin(\theta) \cos(\theta) = \frac{1}{2} \sin(2 \theta) $$
$$\sin^2(\theta) = \frac{1 - \cos(2 \theta)}{2}  $$
It becomes
\begin{align*}
< \tilde{p}| r | \tilde{p} >^2 + < \tilde{q}| r | \tilde{q} >^2 &= (\cos^4(\theta) + \sin^4(\theta)) (B_{pp}^2 + B_{pp}^2) \\
&+ \sin(4\theta) B_{pq} (-B_{pp} + B_{qq}) \\
&+ \sin^2(2\theta) B_{pp} B_{qq} \\
&+ 2 \sin^2(2\theta) B_{pq}^2
\end{align*}

And with
$$ \cos^4(\theta) + \sin^4(\theta) = \frac{1}{4} (3 + \cos(4\theta))$$

we have
\begin{align*}
< \tilde{p}| r | \tilde{p} >^2 + < \tilde{q}| r | \tilde{q} >^2 
&= B_{pp}^2 + B_{qq}^2 -\frac{1}{4} [(1-\cos(4\theta) \beta + \sin(4\theta) \gamma].
\end{align*}

with
$$ \beta = (B_{pp} - B_{qq})^2 - 4 B_{pq}^2 $$ 
$$ \gamma = 4 B_{pq} (B_{pp} - B_{qq}) $$

Consequently:
\begin{align*}
C_1(\theta) &= \sum_{i=1}^N \left[ A_{ii} - B_{ii}^2 \right] \\ 
&- \left[  A_{pp} - B_{pp}^2 +  A_{qq} - B_{qq}^2 \right] \\
&+ \left[  A_{pp} +  A_{qq} - B_{pp}^2 - B_{qq}^2
+ \frac{1}{4} [(1-\cos(4\theta) \beta + \sin(4\theta) \gamma] \right] \\
&= C_1(\theta=0) + \frac{1}{4} [(1-\cos(4\theta)) \beta + \sin(4\theta) \gamma]
\end{align*}

The derivatives are:
\begin{align*}
\frac{\partial C_1(\theta)}{\partial \theta} = \beta \sin(4\theta) + \gamma \cos(4 \theta)
\end{align*}

\begin{align*}
\frac{\partial^2 C_1(\theta)}{\partial \theta^2} = 4 \beta \cos(4\theta) - 4 \gamma \sin(4 \theta)
\end{align*}

Similarly:
\begin{align*}
C_3(\theta) &= \sum_{i=1}^N [B_{ii}^2] \\
&- B_{pp}^2 - B_{qq}^2 \\
&+ B_{pp}^2 + B_{qq}^2 - \frac{1}{4} [(1-\cos(4\theta) \beta + \sin(4\theta) \gamma] \\
&= C_3(\theta=0) - \frac{1}{4} [(1-\cos(4\theta)) \beta + \sin(4\theta) \gamma]
\end{align*}

The derivatives are:
\begin{align*}
\frac{\partial C_3(\theta)}{\partial \theta} = - \beta \sin(4\theta) - \gamma \sin(4 \theta)
\end{align*}

\begin{align*}
\frac{\partial^2 C_3(\theta)}{\partial \theta^2} = - 4 \beta \cos(4\theta) + 4 \gamma \cos(4 \theta)
\end{align*}


Locality of the orbitals:
- cite Hoyvik
As the Foster-Boys method tries to minimize the sum of the second
moment MO spread, the locality of each MO can be expressed as the
second moment of the MO spread. For the MO i, the locality criterion is
\begin{align*}
\sigma_i &= \sqrt{ <i|r^2|i> - <i|r|i>^2} \\
&= \sqrt{ <i|x^2|i> - <i|x|i>^2 + <i|y^2|i> - <i|y|i>^2 + <i|z^2|i> - <i|z|i>^2}
\end{align*} 

Localization procedure:

To do the localization we have compute the gradient and the
diagonal hessian of the Foster-Boys criterion with respect to the MO
rotations and we minimize it with the Newton method.
Since we already have compute the first and second derivatives of the
FB criterion with respect to the MO rotations we have the analytical gradient
and diagonal hessian. Hovik uses an other method in her algorithm and
it seems to work very for big systems.

In order to avoid the problem of starting on a saddle point, the
localization procedure starts by giving a little kick in the MOs in
order to break the symmetry and escape from a possible saddle point.

In order to speed up the iteration we compute the gradient, the
diagonal hessian and the step in temporary matrices of the size
(number MOs in mo_class by number MOs in mo_class)

*** Pipek-Mezey localization
-cite pipek mezey 1989
J. Pipek, P. G. Mezey, J. Chem. Phys. 90, 4916 (1989)
DOI: 10.1063/1.456588

FB localization does not preserve the $\sigma - \pi$ separation of the
MOs, it leads to "banana" orbitals. The Pipek-Mezey localization
normally preserve this separation.

Their localization method starts from fact that the localization of the
MOs can be definined as
\begin{align*}
d_i = \left( \sum_{A = 1}^N (Q_A^i)^2 \right)^{-1}, \quad 0 < d_i < N
\end{align*}
with $A$ representing the differents atoms of the moleculs and $Q_A^i$
the Mulliken population of the MO $i$. 
From that the mean delocalization is 
\begin{align*}
D^{-1} = n^{-1} \sum_{i=1}^n d_i^{-1}, \quad 0 < D \leq D_{max} \leq N
\end{align*}
where
\begin{align*}
D_{max} &= \frac{n^2}{\sum_{A=1}^N \textbf{Q}_A^2} \\
&= \frac{\left( \sum_{A=1}^N \textbf{Q}_A\right)^2}{\sum_{A=1}^N \textbf{Q}_A^2}
\end{align*}
"with $\textbf{Q_A}$ is the total atomic charges (populations) which
are invariant to any unitary transformation."
"$D$ measures the mean extension of the one-elec-
tron orbitals"
As for the Foster-Boys method we have to search the unitary
transformation which minimizes $D$.

They defined for each AOs $|\mu>$ the corresponding operator 
\begin{align*}
P_{\mu} = P_{\mu}^{\dagger} = \frac{1}{2}
\left( |\tilde{\mu} > < \mu| + |\mu > < \tilde{\mu}| \right)
\end{align*}
with
\begin{align*}
|\tilde{\mu} > = \sum_{\nu} (\textbf{S})^{-1}_{\nu \mu} |\nu>
\end{align*}
and $\textbf{S}$ the overlap matrix,
\begin{align*}
S_{\mu \nu} = < \mu | \nu >
\end{align*}

Then the population operator is defined as
\begin{align*}
P_A = P_A^{\dagger} = \sum_{\mu \in A} P_{\mu}
\end{align*}
and the atomic population of (normalized) MO $|i>$ is 
\begin{align*}
Q_A^i = < i | P_A | i >
\end{align*}

The optimum functional $\mathcal{P}$ is obtained for the maximum of
$D^{-1}$
\begin{align*}
\mathcal{\phi_i} = \sum_{i=1}^n \sum_{A=1}^N \left[ <i|P_A|i> \right]^2
\end{align*}

As for the Foster Boys localization, the change in the functional for
the rotation of two MOs can be obtained using very similar terms
\begin{align*}
\beta_{st} = \sum_{A=1}^N \left( <s|P_A|t>^2 - \frac{1}{4} \left[<s|P_A|s> - <t|P_A|t> \right]^2 \right)
\end{align*}
\begin{align*}
\gamma_{st} = \sum_{A=1}^N <s|P_A|t> \left[ <s| P_A |s> - <t|P_A|t> \right]
\end{align*}
The matrix element of the operator $P_A$ are obtained using 
\begin{align*}
<\rho | \tilde{\mu}> = \delta_{\rho \mu}
\end{align*}
which leads to
\begin{align*}
<s|P_A|t> = \frac{1}{2} \sum_{\rho} \sum_{\mu \in A} \left[ c_{\rho}^{s*} S_{\rho \nu} c_{\mu}^{t} +c_{\mu}^{s*} S_{\mu \rho} c_{\rho}^t \right]
\end{align*}
$\sum_{\rho}$ -> all the AOs
$\sum_{\mu \in A}$ -> AOs which belongs to atom A
$c^t$ -> expansion coefficient of orbital |t>
qp2:
nucl_aos
integer, allocatable    :: nucl_aos     (nucl_num,N_AOs_max)
List of AOs centered on each atom
** IDK

Variables:

NB: The indexes i and j refere to the positions of the elements in
the "full space", i.e., the arrays containing elements for all the MOs,
but the indexes tmp_i and tmp_j to the positions of the elements in
the "reduced space/subspace", i.e., the arrays containing elements for
a restricted number of MOs. 
Example:
The gradient for the localization of the core MOs can be expressed 
as a vector of length mo_num*(mo_num-1)/2 with only
n_core_orb*(n_core_orb-1)/2 non zero elements, so it is more relevant
to use a vector of size n_act_orb*(n_core_orb-1)/2.
So here the gradient is a vector of size
tmp_list_size*(tmp_list_size)/2 where tmp_list_size is the number of
MOs is the corresponding mo class.
The same thing happened for the hessian, the matrix containing the
step and the rotation matrix, which are tmp_list_size by tmp_list_size
matrices.

Ex gradient for 4 core orbitales:
\begin{align*}
\begin{pmatrix}
0 & -a & -b & -d & \hdots & 0 \\
a &  0 & -c & -e & \hdots & 0 \\
b &  c &  0 & -f & \hdots & 0 \\
d &  e &  f &  0 & \hdots & 0 \\  
\vdots &  \vdots &  \vdots & \vdots  & \ddots & \vdots \\
0 &  0 &  0 &  0 & \hdots & 0 \\
\end{pmatrix}
\Rightarrow
\begin{pmatrix}
a \\
b \\
c \\
e \\
f \\
0 \\
\vdots \\
0 \\
\end{pmatrix}
\end{align*} 

\begin{align*}
\begin{pmatrix}
0 & -a & -b & -d & \hdots & 0 \\
a &  0 & -c & -e & \hdots & 0 \\
b &  c &  0 & -f & \hdots & 0 \\
d &  e &  f &  0 & \hdots & 0 \\  
\vdots &  \vdots &  \vdots & \vdots  & \ddots & \vdots \\
0 &  0 &  0 &  0 & \hdots & 0 \\
\end{pmatrix}
\Rightarrow
\begin{pmatrix}
0 & -a & -b & -d \\
a &  0 & -c & -e \\
b &  c &  0 & -f \\
d &  e &  f &  0 \\  
\end{pmatrix}
\Rightarrow
\begin{pmatrix}
a \\
b \\
c \\
e \\
f \\
\end{pmatrix}
\end{align*}

The same thing can be done if indexes of the orbitales are not
consecutives since it's done with lists of MOs:

\begin{align*}
\begin{pmatrix}
0 & -a &  0 & -b & -d & \hdots & 0 \\
a &  0 &  0 & -c & -e & \hdots & 0 \\
0 &  0 &  0 &  0 &  0 & \hdots & 0 \\
b &  c &  0 &  0 & -f & \hdots & 0 \\
d &  e &  0 &  f &  0 & \hdots & 0 \\  
\vdots &  \vdots & \vdots & \vdots & \vdots  & \ddots & \vdots \\
0 &  0 &  0 &  0 &  0 & \hdots & 0 \\
\end{pmatrix}
\Rightarrow
\begin{pmatrix}
0 & -a & -b & -d \\
a &  0 & -c & -e \\
b &  c &  0 & -f \\
d &  e &  f &  0 \\  
\end{pmatrix}
\Rightarrow
\begin{pmatrix}
a \\
b \\
c \\
e \\
f \\
\end{pmatrix}
\end{align*}

The dipoles are updated using the ao_to_mo subroutine without the
restore_symmetry which is actually in N^4 but can be rewrite in N^2
log(N^2).
The bottleneck of the program is normally N^3 with the matrix
multiplications/diagonalizations. The use of the full hessian can be
an improvement but it will scale in N^4... 

By using the trust region the bottleneck is the diagonalization of the
hessian. 

** Program

#+BEGIN_SRC f90 org :tangle localization.irp.f
program localization
 call run_localization
end
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle localization.irp.f
subroutine run_localization

  include 'constants.h'

  implicit none

  ! Variables
  double precision, allocatable :: pre_rot(:,:), R(:,:)
  double precision, allocatable :: prev_mos(:,:), spatial_extent(:), tmp_R(:,:)
  double precision :: criterion, norm_grad
  integer          :: i,j,k,l,p, tmp_i, tmp_j, tmp_k
  integer          :: info
  integer          :: n, tmp_n, tmp_list_size
  double precision, allocatable :: v_grad(:), H(:,:), tmp_m_x(:,:), tmp_x(:),W(:,:),e_val(:)
  double precision :: max_elem, t1, t2, t3, t4, t5, t6
  integer, allocatable :: tmp_list(:), key(:)
  double precision :: prev_criterion, rho, delta, criterion_model
  integer :: nb_iter
  logical :: not_converged, not_core_converged
  logical :: not_act_converged, not_inact_converged, not_virt_converged
  logical :: use_trust_region, must_exit, cancel_step

  !restore_symm = .False.
  !SOFT_TOUCH restore_symm
 
  n = mo_num*(mo_num-1)/2

  ! Allocation
  allocate(spatial_extent(mo_num))
  allocate(pre_rot(mo_num, mo_num), R(mo_num, mo_num))
  allocate(prev_mos(ao_num, mo_num))

  ! Locality before the localization
  call compute_spatial_extent(spatial_extent)

  ! Choice of the method (with qp_edit)
  print*,'Localization method:',localization_method
  if (localization_method == 'boys') then
    print*,'Foster-Boys localization'
  elseif (localization_method == 'pipek') then
    print*,'Pipek-Mezey localization'
  else
    print*,'Unknown localization_method, please select boys or pipek'
    call abort
  endif

  ! Localization criterion (FB, PM, ...)
  call criterion_localization(criterion)
  print*,'Criterion:', criterion

  ! Debug
  !print*,'HF', HF_energy

  print*, 'Default mo_class:', default_mo_class

  ! The default mo_classes are setted only if the MOs to localize are not specified
  if (default_mo_class .and. dim_list_inact_orb < 2 &
     .and. dim_list_virt_orb < 2 .and. dim_list_del_orb < 2)) then

    print*, 'Auto setting of the mo_class core/active/virtual...'
    if (n_core_orb > 0) then
      do i = 1, n_core_orb
        mo_class(i) = 'Core'
      enddo
    endif
    do i = MAX(1,n_core_orb), MAX(elec_alpha_num,elec_beta_num)
      mo_class(i) = 'Active' 
    enddo 
    do i = MAX(elec_alpha_num,elec_beta_num), mo_num
      mo_class(i) = 'Virtual'
    enddo

    ! To update the mo_class
    TOUCH mo_class
  endif
#+END_SRC

** Pre rotation
In order to give a little kick in the system
#+BEGIN_SRC f90 :comments org :tangle localization.irp.f
  ! Initialization of the matrix
  pre_rot = 0d0

  if (kick_in_mos) then
    ! Pre rotation for core MOs
    if (dim_list_core_orb >= 2) then
      do tmp_j = 1, dim_list_core_orb
        j = list_core(tmp_j)
        do tmp_i = 1, dim_list_core_orb
          i = list_core(tmp_i)
          if (i > j) then
            pre_rot(i,j) = angle_pre_rot
          elseif (i < j) then
            pre_rot(i,j) = - angle_pre_rot
          else
            pre_rot(i,j) = 0d0
          endif
        enddo
      enddo
    endif
    
    ! Pre rotation for active MOs
    if (dim_list_act_orb >= 2) then
      do tmp_j = 1, dim_list_act_orb
        j = list_act(tmp_j)
        do tmp_i = 1, dim_list_act_orb
          i = list_act(tmp_i)
          if (i > j) then
            pre_rot(i,j) = angle_pre_rot
          elseif (i < j) then
            pre_rot(i,j) = - angle_pre_rot
          else
            pre_rot(i,j) = 0d0
          endif
        enddo
      enddo
    endif
  
    ! Pre rotation for inactive MOs
    if (dim_list_inact_orb >= 2) then
      do tmp_j = 1, dim_list_inact_orb
        j = list_inact(tmp_j)
        do tmp_i = 1, dim_list_inact_orb
          i = list_inact(tmp_i)
          if (i > j) then
            pre_rot(i,j) = angle_pre_rot
          elseif (i < j) then
            pre_rot(i,j) = - angle_pre_rot
          else
            pre_rot(i,j) = 0d0
          endif
        enddo
      enddo
    endif
  
    ! Pre rotation for virtual MOs
    if (dim_list_virt_orb >= 2) then
      do tmp_j = 1, dim_list_virt_orb
        j = list_virt(tmp_j)
        do tmp_i = 1, dim_list_virt_orb
          i = list_virt(tmp_i)
          if (i > j) then
            pre_rot(i,j) = angle_pre_rot
          elseif (i < j) then
            pre_rot(i,j) = - angle_pre_rot
          else
            pre_rot(i,j) = 0d0
          endif
        enddo
      enddo
    endif
  
    ! Nothing for deleted ones
  
    ! Compute pre rotation matrix from pre_rot
    call org_rotation_matrix(pre_rot,mo_num,R,mo_num,mo_num,info)
  
    ! New Mos (we don't car eabout the previous MOs prev_mos)
    call org_apply_mo_rotation(R,prev_mos)
  
    ! Update the things related to mo_coef
    TOUCH mo_coef
  endif
#+END_SRC

** Loc
#+BEGIN_SRC f90 :comments org :tangle localization.irp.f
  ! Criterion after the pre rotation
  call criterion_localization(criterion)
  print*,'### After pre rotation :'
  print*,'Criterion:', criterion

  ! Debug
  !print*,'HF', HF_energy

  print*,''
  print*,'========================'
  print*,'  Orbital localization'
  print*,'========================'
  print*,'' 

  !Initialization
  not_converged = .TRUE.

  if (dim_list_core_orb >= 2) then
    not_core_converged = .TRUE.
  else
    not_core_converged = .FALSE. 
  endif
  
  if (dim_list_act_orb >= 2) then
    not_act_converged = .TRUE.
  else
    not_act_converged = .FALSE.
  endif

  if (dim_list_inact_orb >= 2) then
    not_inact_converged = .TRUE.
  else
    not_inact_converged = .FALSE.
  endif

  if (dim_list_virt_orb >= 2) then
    not_virt_converged = .TRUE.
  else
    not_virt_converged = .FALSE.
  endif
 
  do l = 1, 4

    if (l==1) then ! core
      not_converged = not_core_converged
      tmp_list_size = dim_list_core_orb
    elseif (l==2) then ! act
      not_converged = not_act_converged
      tmp_list_size = dim_list_act_orb
    elseif (l==3) then ! inact
      not_converged = not_inact_converged
      tmp_list_size = dim_list_inact_orb
    else ! virt
      not_converged = not_virt_converged
      tmp_list_size = dim_list_virt_orb
    endif
  
    ! Allocation tmp array  
    allocate(tmp_list(tmp_list_size))

    if (l==1) then ! core
      tmp_list = list_core
    elseif (l==2) then
      tmp_list = list_act
    elseif (l==3) then
      tmp_list = list_inact
    else
      tmp_list = list_virt
    endif

    if (not_converged) then
      ! Display mo_class
      print*,''
      print*,'###', mo_class(tmp_list(1)), 'MOs ###'
      print*,''
    endif

    ! Size for the 2D -> 1D transformation 
    tmp_n = tmp_list_size * (tmp_list_size - 1)/2
  
    ! Allocation of temporary arrays
    allocate(v_grad(tmp_n), H(tmp_n, tmp_n), tmp_m_x(tmp_list_size, tmp_list_size), tmp_R(tmp_list_size, tmp_list_size))
    allocate(tmp_x(tmp_n),W(tmp_n,tmp_n),e_val(tmp_n),key(tmp_n))

    ! ### Initialization ###
    delta = 0d0 ! can be deleted (normally)
    nb_iter = 0 ! Must start at 0 !!!
    rho = 0.5d0 ! Must be 0.5

    ! ### TODO ###
    ! Compute the criterion before the loop
    !call compute_criterion(prev_criterion) 
    call criterion_localization(prev_criterion)

    ! Loop until the convergence
    do while (not_converged)
      ! ### TODO ## 
      ! Call your gradient
      ! Call you hessian
      ! Diagonalize the hessian

      print*,''
      print*,'***********************'
      print*,'Iteration', nb_iter
      print*,'***********************'
      print*,''
  
      ! Gradient
      call gradient_localization(tmp_n, tmp_list_size, tmp_list, v_grad, max_elem, norm_grad)
      ! Diagonal hessian
      call hessian_localization(tmp_n, tmp_list_size, tmp_list, H)
      
      ! Diagonalization of the diagonal hessian by hands
      !call org_diagonalization_hessian(tmp_n,H,e_val,w)
      do i = 1, tmp_n
        e_val(i) = H(i,i)
      enddo

      ! Key list for dsort
      do i = 1, tmp_n 
        key(i) = i
      enddo

      ! Sort of the eigenvalues
      call dsort(e_val, key, tmp_n)

      ! Eigenvectors
      W = 0d0
      do i = 1, tmp_n
        j = key(i)
        W(j,i) = 1d0
      enddo

      cancel_step = .True. ! To enter in the loop just after 

      ! Loop to reduce the trust radius until the criterion decreases and rho >= thresh_rho
      do while (cancel_step)

        ! Hessian,gradient,Criterion -> x 
        call step_in_trust_region(tmp_n,tmp_list_size,H,W,e_val,v_grad,prev_criterion,rho,nb_iter,delta,criterion_model,tmp_x,must_exit) 
        if (must_exit) then
          ! ### Message ###
          ! if step_in_trust_region sets must_exit on true for numerical reasons
          print*,'step_in_trust_region sends the message : Exit'
          exit 
        endif

        !### TODO ###  
        ! Compute x -> m_x (1D -> 2D)
        ! Compute m_x -> R (R = exp(m_x))
        ! Apply R and keep the previous MOs... (new_mo_coef = mo_coef . R)
        ! Update/touch 
        ! Compute the new criterion/energy -> criterion

        ! 1D tmp -> 2D tmp 
        call vec_to_mat_v2(tmp_n,tmp_list_size,tmp_x,tmp_m_x)

        ! Rotation submatrix (square matrix tmp_list_size by tmp_list_size)
        call org_rotation_matrix(tmp_m_x,tmp_list_size,tmp_R,tmp_list_size,tmp_list_size,info)
        ! tmp_R to R, subspace to full space
        R = 0d0
        do i = 1, mo_num
          R(i,i) = 1d0 ! 1 on the diagonal because it is a rotation matrix, 1 = nothing change for the corresponding orbital
        enddo
        do tmp_j = 1, tmp_list_size
          j = tmp_list(tmp_j)
          do tmp_i = 1, tmp_list_size
            i = tmp_list(tmp_i)
            R(i,j) = tmp_R(tmp_i,tmp_j)
          enddo
        enddo

        ! Rotation of the MOs
        call org_apply_mo_rotation(R, prev_mos)   

        ! Update the things related to mo_coef
        call update_data_localization()

        ! Update the criterion
        call criterion_localization(criterion)
        print*,'Criterion:', nb_iter, criterion

        ! Criterion -> step accepted or rejected 
        call is_step_cancel_trust_region(nb_iter,prev_criterion, criterion, criterion_model,rho,cancel_step)
        ! ### TODO ###
        !if (cancel_step) then
        ! Cancel the previous step (mo_coef = prev_mos if you keep them...)
        !endif

        ! Previous MOs
        if (cancel_step) then
          mo_coef = prev_mos
        endif
      enddo
      !call save_mos() !### depend of the time for 1 iteration

      ! To exit the external loop if must_exti = .True.
      if (must_exit) then
        exit
      endif 

      ! Step accepted, nb iteration + 1
      nb_iter = nb_iter + 1

      ! ### TODO ###
      !if (###Conditions###) then
      ! no_converged = .False.
      !endif
      if (DABS(max_elem) < thresh_loc_max_elem_grad) then
        not_converged = .False.
      endif
      if (nb_iter > localization_max_nb_iter) then
        not_converged = .False.
      endif
    enddo

    ! Deallocation of temporary arrays
    deallocate(v_grad, H, tmp_m_x, tmp_R, tmp_list,tmp_x,W,e_val,key)
    
    ! Save the MOs
    call save_mos()
    TOUCH mo_coef 
    ! Debug
    !print*,'HF', HF_energy
    
  enddo

  TOUCH mo_coef 

  ! To sort the MOs using the diagonal elements of the Fock matrix
  if (sort_mos_by_e) then
    call run_sort_by_fock_energies()
  endif

  ! Debug
  !print*,'HF', HF_energy

  ! Locality after the localization
  call compute_spatial_extent(spatial_extent)

end   
#+END_SRC

** Rassemblement bourrin

#+BEGIN_SRC f90 :comments org :tangle localization_sub.irp.f
subroutine gradient_localization(tmp_n, tmp_list_size, tmp_list, v_grad, max_elem, norm_grad)
  
  include 'constants.h'

  implicit none
  
  integer, intent(in) :: tmp_n, tmp_list_size, tmp_list(tmp_list_size)
  double precision, intent(out) :: v_grad(tmp_n), max_elem, norm_grad

  if (localization_method == 'boys') then
    call gradient_FB_omp(tmp_n, tmp_list_size, tmp_list, v_grad, max_elem, norm_grad)
    !call gradient_FB(tmp_n, tmp_list_size, tmp_list, v_grad, max_elem, norm_grad)
  elseif (localization_method== 'pipek') then
    call gradient_PM(tmp_n, tmp_list_size, tmp_list, v_grad, max_elem, norm_grad)
  else
    v_grad = 0d0
    max_elem = 0d0
    norm_grad = 0d0
  endif

end

subroutine hessian_localization(tmp_n, tmp_list_size, tmp_list, H)

  include 'constants.h'

  implicit none

  integer, intent(in) :: tmp_n, tmp_list_size, tmp_list(tmp_list_size)
  double precision, intent(out) :: H(tmp_n, tmp_n)

  if (localization_method == 'boys') then
    call hessian_FB_omp(tmp_n, tmp_list_size, tmp_list, H)
    !call hessian_FB(tmp_n, tmp_list_size, tmp_list, H)
  elseif (localization_method == 'pipek') then
    call hessian_PM(tmp_n, tmp_list_size, tmp_list, H)
  else
    H = 0d0
  endif

end

subroutine criterion_localization(criterion)

  include 'constants.h'
  
  implicit none

  double precision, intent(out) :: criterion

  if (localization_method == 'boys') then
    call criterion_FB(criterion)
  elseif (localization_method == 'pipek') then
    call criterion_PM(criterion)
  else
    criterion = 0d0
  endif

end

subroutine update_data_localization()

  include 'constants.h'

  implicit none

  if (localization_method == 'boys') then
    ! Update the dipoles
    call ao_to_mo_no_sym(ao_dipole_x, ao_num, mo_dipole_x, mo_num)
    call ao_to_mo_no_sym(ao_dipole_y, ao_num, mo_dipole_y, mo_num)
    call ao_to_mo_no_sym(ao_dipole_z, ao_num, mo_dipole_z, mo_num)
  elseif (localization_method == 'pipek') then
  else
  endif
end
#+END_SRC

** Foster-Boys

#+BEGIN_SRC  f90 :comments org :tangle localization_sub.irp.f
subroutine gradient_FB(tmp_n, tmp_list_size, tmp_list, v_grad, max_elem, norm_grad)
  
  implicit none
  
  integer, intent(in) :: tmp_n, tmp_list_size, tmp_list(tmp_list_size)
  double precision, intent(out) :: v_grad(tmp_n), max_elem, norm_grad
  double precision, allocatable :: m_grad(:,:)
  integer :: i,j,k,tmp_i,tmp_j,tmp_k
  double precision :: t1, t2, t3

  print*,''
  print*,'---gradient_FB---'
  print*,''

  call wall_time(t1)

  ! Allocation
  allocate(m_grad(tmp_list_size, tmp_list_size))

  ! Calculation
  do tmp_j = 1, tmp_list_size
    j = tmp_list(tmp_j)
    do tmp_i = 1, tmp_list_size
      i = tmp_list(tmp_i)
      m_grad(tmp_i,tmp_j) = 4d0 * mo_dipole_x(i,j) * (mo_dipole_x(i,i) - mo_dipole_x(j,j)) &
                           +4d0 * mo_dipole_y(i,j) * (mo_dipole_y(i,i) - mo_dipole_y(j,j)) &
                           +4d0 * mo_dipole_z(i,j) * (mo_dipole_z(i,i) - mo_dipole_z(j,j))
    enddo
  enddo
  
  ! 2D -> 1D
  do tmp_k = 1, tmp_n
    call vec_to_mat_index(tmp_k,tmp_i,tmp_j)
    v_grad(tmp_k) = m_grad(tmp_i,tmp_j) 
  enddo

  ! Maximum element in the gradient
  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (ABS(v_grad(tmp_k)) > max_elem) then
      max_elem = ABS(v_grad(tmp_k))
    endif
  enddo 
 
  ! Norm of the gradient
  norm_grad = 0d0
  do tmp_k = 1, tmp_n
    norm_grad = norm_grad + v_grad(tmp_k)**2
  enddo
  norm_grad = dsqrt(norm_grad)

  print*, 'Maximal element in the gradient:', max_elem
  print*, 'Norm of the gradient:', norm_grad  

  ! Deallocation
  deallocate(m_grad)

  call wall_time(t2)
  t3 = t2 - t1
  print*,'Time in gradient_FB:', t3

  print*,''
  print*,'---End gradient_FB---'
  print*,''

end subroutine

subroutine gradient_FB_omp(tmp_n, tmp_list_size, tmp_list, v_grad, max_elem, norm_grad)
  
  use omp_lib

  implicit none
  
  integer, intent(in) :: tmp_n, tmp_list_size, tmp_list(tmp_list_size)
  double precision, intent(out) :: v_grad(tmp_n), max_elem, norm_grad
  double precision, allocatable :: m_grad(:,:)
  integer :: i,j,k,tmp_i,tmp_j,tmp_k
  double precision :: t1, t2, t3

  print*,''
  print*,'---gradient_FB_omp---'
  print*,''

  call wall_time(t1)

  ! Allocation
  allocate(m_grad(tmp_list_size, tmp_list_size))

  ! Initialization omp
  call omp_set_max_active_levels(1)

  !$OMP PARALLEL                                                             &
      !$OMP PRIVATE(i,j,tmp_i,tmp_j,tmp_k)                                         &
      !$OMP SHARED(tmp_n,tmp_list_size,m_grad,v_grad,mo_dipole_x,mo_dipole_y,mo_dipole_z,tmp_list) &
      !$OMP DEFAULT(NONE)

  ! Calculation
  !$OMP DO
  do tmp_j = 1, tmp_list_size
    j = tmp_list(tmp_j)
    do tmp_i = 1, tmp_list_size
      i = tmp_list(tmp_i)
      m_grad(tmp_i,tmp_j) = 4d0 * mo_dipole_x(i,j) * (mo_dipole_x(i,i) - mo_dipole_x(j,j)) &
                           +4d0 * mo_dipole_y(i,j) * (mo_dipole_y(i,i) - mo_dipole_y(j,j)) &
                           +4d0 * mo_dipole_z(i,j) * (mo_dipole_z(i,i) - mo_dipole_z(j,j))
    enddo
  enddo
  !$OMP END DO

  ! 2D -> 1D
  !$OMP DO
  do tmp_k = 1, tmp_n
    call vec_to_mat_index(tmp_k,tmp_i,tmp_j)
    v_grad(tmp_k) = m_grad(tmp_i,tmp_j) 
  enddo 
  !$OMP END DO

  !$OMP END PARALLEL

  call omp_set_max_active_levels(4)

  ! Maximum element in the gradient
  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (ABS(v_grad(tmp_k)) > max_elem) then
      max_elem = ABS(v_grad(tmp_k))
    endif
  enddo 

  ! Norm of the gradient
  norm_grad = 0d0
  do tmp_k = 1, tmp_n
    norm_grad = norm_grad + v_grad(tmp_k)**2
  enddo
  norm_grad = dsqrt(norm_grad)

  print*, 'Maximal element in the gradient:', max_elem
  print*, 'Norm of the gradient:', norm_grad  

  ! Deallocation
  deallocate(m_grad)

  call wall_time(t2)
  t3 = t2 - t1
  print*,'Time in gradient_FB_omp:', t3

  print*,''
  print*,'---End gradient_FB_omp---'
  print*,''

end subroutine

subroutine hessian_FB(tmp_n, tmp_list_size, tmp_list, H)

  implicit none

  integer, intent(in) :: tmp_n, tmp_list_size, tmp_list(tmp_list_size)
  double precision, intent(out) :: H(tmp_n, tmp_n)
  double precision, allocatable :: beta(:,:)
  integer :: i,j,tmp_k,tmp_i, tmp_j
  double precision :: max_elem, t1,t2,t3
   
  print*,''
  print*,'---hessian_FB---'
  print*,''

  call wall_time(t1)


  ! Allocation
  allocate(beta(tmp_list_size,tmp_list_size))
  
  ! Calculation
  do tmp_j = 1, tmp_list_size
    j = tmp_list(tmp_j)
    do tmp_i = 1, tmp_list_size
      i = tmp_list(tmp_i)
      beta(tmp_i,tmp_j) = (mo_dipole_x(i,i) - mo_dipole_x(j,j))**2 - 4d0 * mo_dipole_x(i,j)**2 &
                         +(mo_dipole_y(i,i) - mo_dipole_y(j,j))**2 - 4d0 * mo_dipole_y(i,j)**2 &
                         +(mo_dipole_z(i,i) - mo_dipole_z(j,j))**2 - 4d0 * mo_dipole_z(i,j)**2
    enddo
  enddo

  ! Diagonal of the hessian
  H = 0d0
  do tmp_k = 1, tmp_n
    call vec_to_mat_index(tmp_k,tmp_i,tmp_j)
    H(tmp_k,tmp_k) = 4d0 * beta(tmp_i, tmp_j)
  enddo
  
  ! Min elem
  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (H(tmp_k,tmp_k) < max_elem) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Min elem H:', max_elem

  ! Max elem
  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (H(tmp_k,tmp_k) > max_elem) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Max elem H:', max_elem
  
  ! Near 0
  max_elem = 1d10
  do tmp_k = 1, tmp_n
    if (ABS(H(tmp_k,tmp_k)) < ABS(max_elem)) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Near 0 elem H:', max_elem

  ! Deallocation
  deallocate(beta)
 
  call wall_time(t2)
  t3 = t2 - t1
  print*,'Time in hessian_FB:', t3

  print*,''
  print*,'---End hessian_FB---'
  print*,''

end subroutine

subroutine hessian_FB_omp(tmp_n, tmp_list_size, tmp_list, H)

  implicit none

  integer, intent(in) :: tmp_n, tmp_list_size, tmp_list(tmp_list_size)
  double precision, intent(out) :: H(tmp_n, tmp_n)
  double precision, allocatable :: beta(:,:)
  integer :: i,j,tmp_k,tmp_i, tmp_j
  double precision :: max_elem, t1,t2,t3
   
  print*,''
  print*,'---hessian_FB_omp---'
  print*,''

  call wall_time(t1)

  ! Allocation
  allocate(beta(tmp_list_size,tmp_list_size))

  ! Initialization omp
  call omp_set_max_active_levels(1)

  !$OMP PARALLEL                                                             &
      !$OMP PRIVATE(i,j,tmp_i,tmp_j,tmp_k)                                         &
      !$OMP SHARED(tmp_n,tmp_list_size,beta,H,mo_dipole_x,mo_dipole_y,mo_dipole_z,tmp_list) &
      !$OMP DEFAULT(NONE)

  
  ! Calculation
  !$OMP DO
  do tmp_j = 1, tmp_list_size
    j = tmp_list(tmp_j)
    do tmp_i = 1, tmp_list_size
      i = tmp_list(tmp_i)
      beta(tmp_i,tmp_j) = (mo_dipole_x(i,i) - mo_dipole_x(j,j))**2 - 4d0 * mo_dipole_x(i,j)**2 &
                         +(mo_dipole_y(i,i) - mo_dipole_y(j,j))**2 - 4d0 * mo_dipole_y(i,j)**2 &
                         +(mo_dipole_z(i,i) - mo_dipole_z(j,j))**2 - 4d0 * mo_dipole_z(i,j)**2
    enddo
  enddo
  !$OMP END DO

  ! Initialization
  !$OMP DO
  do j = 1, tmp_n
    do i = 1, tmp_n
      H(i,j) = 0d0 
    enddo
  enddo
  !$OMP END DO
  
  ! Diagonalm of the hessian
  !$OMP DO
  do tmp_k = 1, tmp_n
    call vec_to_mat_index(tmp_k,tmp_i,tmp_j)
    H(tmp_k,tmp_k) = 4d0 * beta(tmp_i, tmp_j)
  enddo
  !$OMP END DO
  
  !$OMP END PARALLEL

  call omp_set_max_active_levels(4)

  ! Min elem
  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (H(tmp_k,tmp_k) < max_elem) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Min elem H:', max_elem

  ! Max elem
  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (H(tmp_k,tmp_k) > max_elem) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Max elem H:', max_elem
  
  ! Near 0
  max_elem = 1d10
  do tmp_k = 1, tmp_n
    if (ABS(H(tmp_k,tmp_k)) < ABS(max_elem)) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Near 0 elem H:', max_elem

  ! Deallocation
  deallocate(beta)
 
  call wall_time(t2)
  t3 = t2 - t1
  print*,'Time in hessian_FB_omp:', t3

  print*,''
  print*,'---End hessian_FB_omp---'
  print*,''

end subroutine
#+END_SRC
** Pipek-Mezey
#+BEGIN_SRC  f90 :comments org :tangle localization_sub.irp.f
subroutine grad_pipek(tmp_n, tmp_list_size, tmp_list, v_grad, max_elem, norm_grad)

  implicit none
  
  integer, intent(in) :: tmp_n, tmp_list_size, tmp_list(tmp_list_size)
  double precision, intent(out) :: v_grad(tmp_n), max_elem, norm_grad
  double precision, allocatable :: m_grad(:,:), tmp_int(:,:)
  integer :: i,j,k,tmp_i,tmp_j,tmp_k, a, b, mu ,rho 

  ! Allocation
  allocate(m_grad(tmp_list_size, tmp_list_size), tmp_int(tmp_list_size, tmp_list_size))

  ! Initialization 
  m_grad = 0d0

  do a = 1, nucl_num ! loop over the nuclei
    tmp_int = 0d0 ! Initialization for each nuclei

    ! Loop over the MOs of the a given mo_class to compute <i|Q_a|j>
    do tmp_j = 1, tmp_list_size
      j = tmp_list(tmp_j) 
      do tmp_i = 1, tmp_list_size
        i = tmp_list(tmp_i)
        do rho = 1, ao_num ! loop over all the AOs
          do b = 1, nucl_n_aos(a) ! loop over the number of AOs which belongs to the nuclei a
            mu = nucl_aos(a,b)

            tmp_int(tmp_i,tmp_j) = tmp_int(tmp_i,tmp_j) + 0.5d0 * (mo_coef(rho,i) * ao_overlap(rho,mu) * mo_coef(mu,j) &
                                   + mo_coef(mu,i) * ao_overlap(mu,rho) * mo_coef(rho,j))

          enddo
        enddo  
      enddo
    enddo

    ! Gradient
    do tmp_j = 1, tmp_list_size
      do tmp_i = 1, tmp_list_size

        m_grad(tmp_i,tmp_j) = m_grad(tmp_i,tmp_j) +  4d0 * tmp_int(tmp_i,tmp_j) * (tmp_int(tmp_i,tmp_i) - tmp_int(tmp_j,tmp_j))

      enddo
    enddo

  enddo

  ! 2D -> 1D
  do tmp_k = 1, tmp_n
    call vec_to_mat_index(tmp_k,tmp_i,tmp_j)
    v_grad(tmp_k) = m_grad(tmp_i,tmp_j) 
  enddo

  ! Maximum element in the gradient
  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (ABS(v_grad(tmp_k)) > max_elem) then
      max_elem = ABS(v_grad(tmp_k))
    endif
  enddo 
  
  ! Norm of the gradient
  norm_grad = 0d0
  do tmp_k = 1, tmp_n
    norm_grad = norm_grad + v_grad(tmp_k)**2
  enddo
  norm_grad = dsqrt(norm_grad)

  print*, 'Maximal element in the gradient:', max_elem
  print*, 'Norm of the gradient:', norm_grad

  ! Deallocation
  deallocate(m_grad,tmp_int)

end

subroutine gradient_PM(tmp_n, tmp_list_size, tmp_list, v_grad, max_elem, norm_grad)

  implicit none
  
  integer, intent(in) :: tmp_n, tmp_list_size, tmp_list(tmp_list_size)
  double precision, intent(out) :: v_grad(tmp_n), max_elem, norm_grad
  double precision, allocatable :: m_grad(:,:), tmp_int(:,:), CS(:,:), tmp_mo_coef(:,:), tmp_mo_coef2(:,:),tmp_accu(:,:),tmp_CS(:,:)
  integer :: i,j,k,tmp_i,tmp_j,tmp_k, a, b, mu ,rho
  double precision :: t1,t2,t3

  print*,''
  print*,'---gradient_PM---'
  print*,''

  call wall_time(t1)

  ! Allocation
  allocate(m_grad(tmp_list_size, tmp_list_size), tmp_int(tmp_list_size, tmp_list_size),tmp_accu(tmp_list_size, tmp_list_size))
  allocate(CS(tmp_list_size,ao_num),tmp_mo_coef(ao_num,tmp_list_size))


  ! submatrix of the mo_coef
  do tmp_i = 1, tmp_list_size
    i = tmp_list(tmp_i)
    do j = 1, ao_num

      tmp_mo_coef(j,tmp_i) = mo_coef(j,i)
 
    enddo
  enddo

  call dgemm('T','N',tmp_list_size,ao_num,ao_num,1d0,tmp_mo_coef,size(tmp_mo_coef,1),ao_overlap,size(ao_overlap,1),0d0,CS,size(CS,1))
 
  m_grad = 0d0

  do a = 1, nucl_num ! loop over the nuclei
    tmp_int = 0d0

    !do tmp_j = 1, tmp_list_size
    !  do tmp_i = 1, tmp_list_size
    !    do b = 1, nucl_n_aos(a) ! loop over the number of AOs which belongs to the nuclei a
    !      mu = nucl_aos(a,b)

    !      tmp_int(tmp_i,tmp_j) = tmp_int(tmp_i,tmp_j) + 0.5d0 * (CS(tmp_i,mu) * tmp_mo_coef(mu,tmp_j) + tmp_mo_coef(mu,tmp_i) * CS(tmp_j,mu))

    !                             !  (mo_coef(rho,i) * ao_overlap(rho,mu) * mo_coef(mu,j) &
    !                             !+ mo_coef(mu,i) * ao_overlap(mu,rho) * mo_coef(rho,j))

    !    enddo
    !  enddo
    !enddo

    allocate(tmp_mo_coef2(nucl_n_aos(a),tmp_list_size),tmp_CS(tmp_list_size,nucl_n_aos(a)))

    do tmp_i = 1, tmp_list_size
      do b = 1, nucl_n_aos(a)
        mu = nucl_aos(a,b)

        tmp_mo_coef2(b,tmp_i) = tmp_mo_coef(mu,tmp_i)

      enddo
    enddo
    
    do b = 1, nucl_n_aos(a)
      mu = nucl_aos(a,b)
      do tmp_i = 1, tmp_list_size

        tmp_CS(tmp_i,b) = CS(tmp_i,mu)

      enddo
    enddo   

    call dgemm('N','N',tmp_list_size,tmp_list_size,nucl_n_aos(a),1d0,tmp_CS,size(tmp_CS,1),tmp_mo_coef2,size(tmp_mo_coef2,1),0d0,tmp_accu,size(tmp_accu,1))
 
    do tmp_j = 1, tmp_list_size
      do tmp_i = 1, tmp_list_size

        tmp_int(tmp_i,tmp_j) = 0.5d0 * (tmp_accu(tmp_i,tmp_j) + tmp_accu(tmp_j,tmp_i))   

      enddo
    enddo

    deallocate(tmp_mo_coef2,tmp_CS)

    do tmp_j = 1, tmp_list_size
      do tmp_i = 1, tmp_list_size

        m_grad(tmp_i,tmp_j) = m_grad(tmp_i,tmp_j) +  4d0 * tmp_int(tmp_i,tmp_j) * (tmp_int(tmp_i,tmp_i) - tmp_int(tmp_j,tmp_j))

      enddo
    enddo

  enddo

  ! 2D -> 1D
  do tmp_k = 1, tmp_n
    call vec_to_mat_index(tmp_k,tmp_i,tmp_j)
    v_grad(tmp_k) = m_grad(tmp_i,tmp_j) 
  enddo

  ! Maximum element in the gradient
  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (ABS(v_grad(tmp_k)) > max_elem) then
      max_elem = ABS(v_grad(tmp_k))
    endif
  enddo 

  ! Norm of the gradient
  norm_grad = 0d0
  do tmp_k = 1, tmp_n
    norm_grad = norm_grad + v_grad(tmp_k)**2
  enddo
  norm_grad = dsqrt(norm_grad)

  print*, 'Maximal element in the gradient:', max_elem
  print*, 'Norm of the gradient:', norm_grad

  ! Deallocation
  deallocate(m_grad,tmp_int,CS,tmp_mo_coef)

  call wall_time(t2)
  t3 = t2 - t1
  print*,'Time in gradient_PM:', t3

  print*,''
  print*,'---End gradient_PM---'
  print*,''

end

subroutine hess_pipek(tmp_n, tmp_list_size, tmp_list, H)

  implicit none

  integer, intent(in) :: tmp_n, tmp_list_size, tmp_list(tmp_list_size)
  double precision, intent(out) :: H(tmp_n, tmp_n)
  double precision, allocatable :: beta(:,:),tmp_int(:,:)
  integer :: i,j,tmp_k,tmp_i, tmp_j, a,b,rho,mu
  double precision :: max_elem
    
  ! Allocation
  allocate(beta(tmp_list_size,tmp_list_size),tmp_int(tmp_list_size,tmp_list_size))

  beta = 0d0

  do a = 1, nucl_num
    tmp_int = 0d0

    do tmp_j = 1, tmp_list_size
      j = tmp_list(tmp_j)
      do tmp_i = 1, tmp_list_size
        i = tmp_list(tmp_i)
        do rho = 1, ao_num
          do b = 1, nucl_n_aos(a) ! loop over the number of AOs which belongs to the nuclei a
            mu = nucl_aos(a,b)

            tmp_int(tmp_i,tmp_j) = tmp_int(tmp_i,tmp_j) + 0.5d0 * (mo_coef(rho,i) * ao_overlap(rho,mu) * mo_coef(mu,j) &
                                   + mo_coef(mu,i) * ao_overlap(mu,rho) * mo_coef(rho,j))

          enddo
        enddo  
      enddo
    enddo

    ! Calculation
    do tmp_j = 1, tmp_list_size
      do tmp_i = 1, tmp_list_size

        beta(tmp_i,tmp_j) = beta(tmp_i, tmp_j) +  (tmp_int(tmp_i,tmp_i) - tmp_int(tmp_j,tmp_j))**2 - 4d0 * tmp_int(tmp_i,tmp_j)**2

      enddo
    enddo
  
  enddo

  H = 0d0
  do tmp_k = 1, tmp_n
    call vec_to_mat_index(tmp_k,tmp_i,tmp_j)
    H(tmp_k,tmp_k) = 4d0 * beta(tmp_i, tmp_j)
  enddo
  
  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (H(tmp_k,tmp_k) < max_elem) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Min elem H:', max_elem

  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (H(tmp_k,tmp_k) > max_elem) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Max elem H:', max_elem
  
  max_elem = 1d10
  do tmp_k = 1, tmp_n
    if (ABS(H(tmp_k,tmp_k)) < ABS(max_elem)) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Near 0 elem H:', max_elem

  ! Deallocation
  deallocate(beta,tmp_int)

end

subroutine hessian_PM(tmp_n, tmp_list_size, tmp_list, H)

  implicit none

  integer, intent(in) :: tmp_n, tmp_list_size, tmp_list(tmp_list_size)
  double precision, intent(out) :: H(tmp_n, tmp_n)
  double precision, allocatable :: beta(:,:),tmp_int(:,:),CS(:,:),tmp_mo_coef(:,:),tmp_mo_coef2(:,:),tmp_accu(:,:),tmp_CS(:,:)
  integer :: i,j,tmp_k,tmp_i, tmp_j, a,b,rho,mu
  double precision :: max_elem, t1,t2,t3
    
  print*,''
  print*,'---hessian_PM---'
  print*,''

  call wall_time(t1)

  ! Allocation
  allocate(beta(tmp_list_size,tmp_list_size),tmp_int(tmp_list_size,tmp_list_size),tmp_accu(tmp_list_size,tmp_list_size))
  allocate(CS(tmp_list_size,ao_num),tmp_mo_coef(ao_num,tmp_list_size))

  ! ### TODO ### EXPLICIT YOUR ******* temporaty arrays with formula

  beta = 0d0

  do tmp_i = 1, tmp_list_size
    i = tmp_list(tmp_i)
    do j = 1, ao_num

      tmp_mo_coef(j,tmp_i) = mo_coef(j,i)
 
    enddo
  enddo

  call dgemm('T','N',tmp_list_size,ao_num,ao_num,1d0,tmp_mo_coef,size(tmp_mo_coef,1),ao_overlap,size(ao_overlap,1),0d0,CS,size(CS,1))
 
  do a = 1, nucl_num ! loop over the nuclei
    tmp_int = 0d0

    !do tmp_j = 1, tmp_list_size
    !  do tmp_i = 1, tmp_list_size
    !    do b = 1, nucl_n_aos(a) ! loop over the number of AOs which belongs to the nuclei a
    !      mu = nucl_aos(a,b)

    !      tmp_int(tmp_i,tmp_j) = tmp_int(tmp_i,tmp_j) + 0.5d0 * (CS(tmp_i,mu) * tmp_mo_coef(mu,tmp_j) + tmp_mo_coef(mu,tmp_i) * CS(tmp_j,mu))

    !                             !  (mo_coef(rho,i) * ao_overlap(rho,mu) * mo_coef(mu,j) &
    !                             !+ mo_coef(mu,i) * ao_overlap(mu,rho) * mo_coef(rho,j))

    !    enddo
    !  enddo
    !enddo
 
    allocate(tmp_mo_coef2(nucl_n_aos(a),tmp_list_size),tmp_CS(tmp_list_size,nucl_n_aos(a)))

    do tmp_i = 1, tmp_list_size
      do b = 1, nucl_n_aos(a)
        mu = nucl_aos(a,b)

        tmp_mo_coef2(b,tmp_i) = tmp_mo_coef(mu,tmp_i)

      enddo
    enddo
    
    do b = 1, nucl_n_aos(a)
      mu = nucl_aos(a,b)
      do tmp_i = 1, tmp_list_size

        tmp_CS(tmp_i,b) = CS(tmp_i,mu)

      enddo
    enddo   

    call dgemm('N','N',tmp_list_size,tmp_list_size,nucl_n_aos(a),1d0,tmp_CS,size(tmp_CS,1),tmp_mo_coef2,size(tmp_mo_coef2,1),0d0,tmp_accu,size(tmp_accu,1))
 
    do tmp_j = 1, tmp_list_size
      do tmp_i = 1, tmp_list_size

        tmp_int(tmp_i,tmp_j) = 0.5d0 * (tmp_accu(tmp_i,tmp_j) + tmp_accu(tmp_j,tmp_i))   

      enddo
    enddo

    deallocate(tmp_mo_coef2,tmp_CS)

    ! Calculation
    do tmp_j = 1, tmp_list_size
      do tmp_i = 1, tmp_list_size

        beta(tmp_i,tmp_j) = beta(tmp_i, tmp_j) +  (tmp_int(tmp_i,tmp_i) - tmp_int(tmp_j,tmp_j))**2 - 4d0 * tmp_int(tmp_i,tmp_j)**2

      enddo
    enddo
  
  enddo

  H = 0d0
  do tmp_k = 1, tmp_n
    call vec_to_mat_index(tmp_k,tmp_i,tmp_j)
    H(tmp_k,tmp_k) = 4d0 * beta(tmp_i, tmp_j)
  enddo
  
  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (H(tmp_k,tmp_k) < max_elem) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Min elem H:', max_elem

  max_elem = 0d0
  do tmp_k = 1, tmp_n
    if (H(tmp_k,tmp_k) > max_elem) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Max elem H:', max_elem
  
  max_elem = 1d10
  do tmp_k = 1, tmp_n
    if (ABS(H(tmp_k,tmp_k)) < ABS(max_elem)) then
      max_elem = H(tmp_k,tmp_k)
    endif
  enddo
  print*, 'Near 0 elem H:', max_elem

  ! Deallocation
  deallocate(beta,tmp_int)

  call wall_time(t2)
  t3 = t2 - t1
  print*,'Time in hessian_PM:', t3

  print*,''
  print*,'---End hessian_PM---'
  print*,''

end

#+END_SRC

** Criterion
#+BEGIN_SRC f90 :comments org :tangle localization_sub.irp.f
subroutine compute_crit_pipek(criterion)

  implicit none

  double precision, intent(out) :: criterion
  double precision, allocatable :: tmp_int(:,:)
  integer :: i,j,k,tmp_i,tmp_j,tmp_k, a, b, mu ,rho 

  ! Allocation
  allocate(tmp_int(mo_num, mo_num))
 
  criterion = 0d0

  do a = 1, nucl_num ! loop over the nuclei
    tmp_int = 0d0

    do i = 1, mo_num
      do rho = 1, ao_num ! loop over all the AOs
        do b = 1, nucl_n_aos(a) ! loop over the number of AOs which belongs to the nuclei a
          mu = nucl_aos(a,b)

          tmp_int(i,i) = tmp_int(i,i) + 0.5d0 * (mo_coef(rho,i) * ao_overlap(rho,mu) * mo_coef(mu,i) &
                                 + mo_coef(mu,i) * ao_overlap(mu,rho) * mo_coef(rho,i))

        enddo
      enddo  
    enddo

    do i = 1, mo_num 
      criterion = criterion + tmp_int(i,i)**2
    enddo

  enddo
  
  criterion = - criterion 

  deallocate(tmp_int)

end

subroutine criterion_PM(criterion)

  implicit none

  double precision, intent(out) :: criterion
  double precision, allocatable :: tmp_int(:,:),CS(:,:)
  integer :: i,j,k,tmp_i,tmp_j,tmp_k, a, b, mu ,rho 

  ! Allocation
  allocate(tmp_int(mo_num, mo_num))
 
  criterion = 0d0

  allocate(CS(mo_num,ao_num))

  call dgemm('T','N',mo_num,ao_num,ao_num,1d0,mo_coef,size(mo_coef,1),ao_overlap,size(ao_overlap,1),0d0,CS,size(CS,1))
 
  do a = 1, nucl_num ! loop over the nuclei
    tmp_int = 0d0

      do i = 1, mo_num
        do b = 1, nucl_n_aos(a) ! loop over the number of AOs which belongs to the nuclei a
          mu = nucl_aos(a,b)

          tmp_int(i,i) = tmp_int(i,i) + 0.5d0 * (CS(i,mu) * mo_coef(mu,i) + mo_coef(mu,i) * CS(i,mu))

                                 !  (mo_coef(rho,i) * ao_overlap(rho,mu) * mo_coef(mu,j) &
                                 !+ mo_coef(mu,i) * ao_overlap(mu,rho) * mo_coef(rho,j))

      enddo
    enddo

    do i = 1, mo_num 
      criterion = criterion + tmp_int(i,i)**2
    enddo

  enddo
  
  criterion = - criterion 

  deallocate(tmp_int)

end

subroutine criterion_FB(criterion)

  implicit none

  double precision, intent(out) :: criterion
  integer :: i

  ! Criterion (= \sum_i <i|r|i>^2 )
  criterion = 0d0
  do i = 1, mo_num
    criterion = criterion + mo_dipole_x(i,i)**2 + mo_dipole_y(i,i)**2 + mo_dipole_z(i,i)**2
  enddo
  criterion = - criterion

end subroutine
#+END_SRC
** Spatial extent
#+BEGIN_SRC f90 :comments org :tangle localization_sub.irp.f
subroutine compute_spatial_extent(spatial_extent)

  implicit none
 
  double precision, intent(out) :: spatial_extent(mo_num)
  double precision :: average_core, average_act, average_inact, average_virt
  double precision :: std_var_core, std_var_act, std_var_inact, std_var_virt
  integer :: i,j,k,l

  spatial_extent = 0d0
  
  do i = 1, mo_num
    spatial_extent(i) = mo_spread_x(i,i) - mo_dipole_x(i,i)**2
  enddo
  do i = 1, mo_num
    spatial_extent(i) = spatial_extent(i) + mo_spread_y(i,i) - mo_dipole_y(i,i)**2
  enddo
  do i = 1, mo_num
    spatial_extent(i) = spatial_extent(i) + mo_spread_z(i,i) - mo_dipole_z(i,i)**2
  enddo

  do i = 1, mo_num
    spatial_extent(i) = dsqrt(spatial_extent(i))
  enddo

  average_core = 0d0
  std_var_core = 0d0
  if (dim_list_core_orb >= 2) then
    call compute_average_sp_ext(spatial_extent, list_core, dim_list_core_orb, average_core)
    call compute_std_var_sp_ext(spatial_extent, list_core, dim_list_core_orb, average_core, std_var_core)
  endif

  average_act = 0d0
  std_var_act = 0d0
  if (dim_list_act_orb >= 2) then
    call compute_average_sp_ext(spatial_extent, list_act, dim_list_act_orb, average_act)
    call compute_std_var_sp_ext(spatial_extent, list_act, dim_list_act_orb, average_act, std_var_act)
  endif
  
  average_inact = 0d0
  std_var_inact = 0d0
  if (dim_list_inact_orb >= 2) then
    call compute_average_sp_ext(spatial_extent, list_inact, dim_list_inact_orb, average_inact)
    call compute_std_var_sp_ext(spatial_extent, list_inact, dim_list_inact_orb, average_inact, std_var_inact)
  endif

  average_virt = 0d0
  std_var_virt = 0d0
  if (dim_list_virt_orb >= 2) then
    call compute_average_sp_ext(spatial_extent, list_virt, dim_list_virt_orb, average_virt)
    call compute_std_var_sp_ext(spatial_extent, list_virt, dim_list_virt_orb, average_virt, std_var_virt)
  endif

  print*,''
  print*,'============================='
  print*,'  Spatial extent of the MOs'
  print*,'============================='
  print*,''

  print*, 'elec_num:', elec_num
  print*, 'elec_alpha_num:', elec_alpha_num
  print*, 'elec_beta_num:', elec_beta_num
  print*, 'core:', dim_list_core_orb
  print*, 'act:', dim_list_act_orb
  print*, 'inact:', dim_list_inact_orb
  print*, 'virt:', dim_list_virt_orb
  print*, 'mo_num:', mo_num
  print*,''
   
  print*,'-- Core MOs --'
  print*,'Average:', average_core
  print*,'Std var:', std_var_core
  print*,''
  
  print*,'-- Active MOs --'
  print*,'Average:', average_act
  print*,'Std var:', std_var_act
  print*,''

  print*,'-- Inactive MOs --'
  print*,'Average:', average_inact
  print*,'Std var:', std_var_inact
  print*,''

  print*,'-- Virtual MOs --'
  print*,'Average:', average_virt
  print*,'Std var:', std_var_virt
  print*,''

  print*,'Spatial extent:'
  do i = 1, mo_num
    print*, i, spatial_extent(i)
  enddo

end

subroutine compute_average_sp_ext(spatial_extent, list, list_size, average)

  implicit none

  integer, intent(in) :: list_size, list(list_size)
  double precision, intent(in) :: spatial_extent(mo_num)
  double precision, intent(out) :: average
  integer :: i, tmp_i
  
  average = 0d0
  do tmp_i = 1, list_size
    i = list(tmp_i)
    average = average + spatial_extent(i)
  enddo

  average = average / DBLE(list_size)

end

subroutine compute_std_var_sp_ext(spatial_extent, list, list_size, average, std_var)

  implicit none

  integer, intent(in) :: list_size, list(list_size)
  double precision, intent(in) :: spatial_extent(mo_num)
  double precision, intent(in) :: average
  double precision, intent(out) :: std_var
  integer :: i, tmp_i

  std_var = 0d0

  do tmp_i = 1, list_size
    i = list(tmp_i)
    std_var = std_var + (spatial_extent(i) - average)**2
  enddo
  
  std_var = dsqrt(1d0/DBLE(list_size) * std_var)

end
#+END_SRC
** Pairwise
#+BEGIN_SRC f90 :comments org :tangle localization_sub.irp.f
! Doesn't work during the last try but was working at one moment, idk
subroutine compute_theta_FB(m_theta)

  include 'constants.h'

  implicit none
  
  integer :: i,j
  double precision, intent(out) :: m_theta(mo_num, mo_num)

  double precision, allocatable :: A12(:,:), B12(:,:)

  allocate(A12(mo_num, mo_num), B12(mo_num, mo_num))
  
  !A12
  do j = 1, mo_num
    do i = 1, mo_num
      A12(i,j) = mo_dipole_x(i,j) * mo_dipole_x(i,j) &
                 - 0.25d0 * (mo_dipole_x(i,i) - mo_dipole_x(j,j)) * &
                 (mo_dipole_x(i,i) - mo_dipole_x(j,j)) &
                + &
                mo_dipole_y(i,j) * mo_dipole_y(i,j) &
                 - 0.25d0 * (mo_dipole_y(i,i) - mo_dipole_y(j,j)) * &
                 (mo_dipole_y(i,i) - mo_dipole_y(j,j)) &
                + &
                mo_dipole_z(i,j) * mo_dipole_z(i,j) &
                 - 0.25d0 * (mo_dipole_z(i,i) - mo_dipole_z(j,j)) * &
                 (mo_dipole_z(i,i) - mo_dipole_z(j,j))
    enddo
  enddo

  ! B12
  do j = 1, mo_num
    do i = 1, mo_num
      B12(i,j) = (mo_dipole_x(i,i) - mo_dipole_x(j,j)) * mo_dipole_x(i,j) &
                 + &
                 (mo_dipole_y(i,i) - mo_dipole_y(j,j)) * mo_dipole_y(i,j) &
                 + &
                 (mo_dipole_z(i,i) - mo_dipole_z(j,j)) * mo_dipole_z(i,j)
    enddo
  enddo

  ! m_theta
  do j = 1, mo_num
    do i = 1, mo_num
      if (i == j) then
        m_theta(i,j) = 0d0     !(-B12(i,j), A12(i,j)) ?? pourquoi j'avais mis le - ici ????
      elseif (0.25d0 * atan2(B12(i,j), -A12(i,j)) >= 0d0) then
        m_theta(i,j) =  0d0 * pi * 0.25d0 + 0.25d0 * atan2(B12(i,j), -A12(i,j))
      else
        m_theta(i,j) = - 0d0 *pi * 0.25d0 + 0.25d0 * atan2(B12(i,j), -A12(i,j))
      endif
    enddo
  enddo

  deallocate(A12,B12)

end subroutine

subroutine compute_theta_PM(list_size,list,m_theta)

  implicit none

  integer, intent(in) :: list_size, list(list_size)
  double precision, intent(out) :: m_theta(mo_num,mo_num) 
  integer :: i,j, a, b, rho, mu,tmp_i,tmp_j
  double precision, allocatable :: A12(:,:), B12(:,:), tmp_int(:,:)
  double precision :: atan2

  allocate(A12(mo_num,mo_num),B12(mo_num,mo_num), tmp_int(mo_num,mo_num))
  A12 = 0d0
  B12 = 0d0
  do a = 1, nucl_num ! loop over the nuclei
    tmp_int = 0d0

    do tmp_j = 1, list_size
      j = list(tmp_j)
      do tmp_i = 1, list_size
        i = list(tmp_i)
        do rho = 1, ao_num ! loop over all the AOs
          do b = 1, nucl_n_aos(a) ! loop over the number of AOs which belongs to the nuclei a
            mu = nucl_aos(a,b)

            tmp_int(i,j) = tmp_int(i,j) + 0.5d0 * (mo_coef(rho,i) * ao_overlap(rho,mu) * mo_coef(mu,j) &
                                   + mo_coef(mu,i) * ao_overlap(mu,rho) * mo_coef(rho,j))

          enddo
        enddo  
      enddo
    enddo

   do j = 1, mo_num
      do i = 1, mo_num

        A12(i,j) = A12(i,j) + tmp_int(i,j)**2 - 0.25d0 *(tmp_int(i,i) - tmp_int(j,j))**2

      enddo
    enddo

    do j = 1, mo_num
      do i = 1, mo_num

        B12(i,j) = B12(i,j) + tmp_int(i,j) * (tmp_int(i,i) - tmp_int(j,j))

      enddo
    enddo

  enddo

  ! m_theta
  do tmp_j = 1, list_size
    j = list(tmp_j)
    do tmp_i = 1, list_size
      i = list(tmp_i)
      if (i == j) then
        m_theta(i,j) = 0d0 
      else
        m_theta(i,j) = 0.25d0 * atan2(B12(i,j), -A12(i,j))
      endif
    enddo
  enddo

  do i = 1, mo_num
    write(*,'(10E12.5)') m_theta(i,:)
  enddo

  deallocate(A12,B12)
  
end

subroutine research_max_theta(mo_beg, mo_end, m_theta, i_theta_max, j_theta_max, theta_max)

  implicit none

  integer, intent(in) :: mo_beg, mo_end
  double precision, intent(in) :: m_theta(mo_num, mo_num)
  integer, intent(out) :: i_theta_max, j_theta_max
  double precision, intent(out) :: theta_max
  integer :: i,j
  
  ! research the max theta for the MOs between mo_beg and mo_end

  theta_max = 0d0
  do j = mo_beg, mo_end
    do i = mo_beg, mo_end
      if (ABS(theta_max) <= ABS(m_theta(i,j))) then
        i_theta_max = i 
        j_theta_max = j 
        theta_max =  m_theta(i,j)
      endif
    enddo
  enddo

end subroutine

subroutine apply_pairwise_rotation(i_theta_max, j_theta_max, theta_max)

  implicit none

  integer, intent(in) :: i_theta_max, j_theta_max
  double precision, intent(in) :: theta_max
  double precision, allocatable :: new_mos(:,:)
  integer :: k

  allocate(new_mos(ao_num, mo_num))

  ! Rotation
  new_mos = mo_coef

  do k = 1, ao_num
    new_mos(k, i_theta_max) = mo_coef(k, i_theta_max) * cos(theta_max) &
                            + mo_coef(k, j_theta_max) * sin(theta_max)
    new_mos(k, j_theta_max) = - mo_coef(k, i_theta_max) * sin(theta_max) &
                            + mo_coef(k, j_theta_max) * cos(theta_max)
  enddo

  mo_coef = new_mos
  call save_mos()
  
end subroutine

! It works but it needs the four index integrals... => bad
!subroutine compute_hf_energy()
!
!  implicit none
!
!  double precision :: energy, mo_two_e_integral
!  integer :: i,j,k,l
!
!  energy = 0d0
!  do j = 1, mo_num
!    do i = 1, mo_num
!      energy = energy + mo_one_e_integrals(i,j) * one_e_dm_mo(i,j)
!    enddo
!  enddo
!
!  do l = 1, mo_num
!    do k = 1, mo_num
!      do j = 1, mo_num
!        do i = 1, mo_num
!          energy = energy +0.5d0 * mo_two_e_integral(i,j,k,l) * two_e_dm_mo(i,j,k,l)
!        enddo
!      enddo
!    enddo
!  enddo
!
!  energy = energy + nuclear_repulsion
!
!  print*,'energy scf', energy
!
!end subroutine
#+END_SRC
** Utils

#+BEGIN_SRC  f90 :comments org :tangle localization_sub.irp.f
subroutine x_tmp_orb_loc_v2(tmp_n, tmp_list_size, tmp_list, v_grad, H,tmp_x, tmp_m_x)

  implicit none

  integer, intent(in) :: tmp_n, tmp_list_size, tmp_list(tmp_list_size)
  double precision, intent(in) :: v_grad(tmp_n)
  double precision, intent(in) :: H(tmp_n, tmp_n)
  double precision, intent(out) :: tmp_m_x(tmp_list_size, tmp_list_size), tmp_x(tmp_list_size)
  !double precision, allocatable :: x(:)
  double precision :: lambda , accu, max_elem
  integer :: i,j,tmp_i,tmp_j,tmp_k

  ! Allocation
  !allocate(x(tmp_n))

  ! Level shifted hessian
  lambda = 0d0
  do tmp_k = 1, tmp_n
    if (H(tmp_k,tmp_k) < lambda) then
      lambda = H(tmp_k,tmp_k)
    endif
  enddo

  ! min element in the hessian
  if (lambda < 0d0) then
    lambda = -lambda + 1d-6
  endif  
  
  print*, 'lambda', lambda
 
  ! Good
  do tmp_k = 1, tmp_n
    if (ABS(H(tmp_k,tmp_k)) > 1d-6) then
       tmp_x(tmp_k) = - 1d0/(ABS(H(tmp_k,tmp_k))+lambda) * v_grad(tmp_k)!(-v_grad(tmp_k))
      !x(tmp_k) = - 1d0/(ABS(H(tmp_k,tmp_k))+lambda) * (-v_grad(tmp_k)) 
    endif
  enddo

  ! 1D tmp -> 2D tmp 
  tmp_m_x = 0d0
  do tmp_j = 1, tmp_list_size - 1
    do tmp_i = tmp_j + 1, tmp_list_size
      call mat_to_vec_index(tmp_i,tmp_j,tmp_k)
      tmp_m_x(tmp_i, tmp_j) = tmp_x(tmp_k)!x(tmp_k)
    enddo
  enddo

  ! Antisym, pourrait être mieux avec m_x - m_x^T ?
  do tmp_i = 1, tmp_list_size - 1
    do tmp_j = tmp_i + 1, tmp_list_size
      tmp_m_x(tmp_i,tmp_j) = - tmp_m_x(tmp_j,tmp_i) 
    enddo
  enddo

  ! Deallocation
  !deallocate(x)

end subroutine
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle localization_sub.irp.f
subroutine ao_to_mo_no_sym(A_ao,LDA_ao,A_mo,LDA_mo)
  implicit none
  BEGIN_DOC
  ! Transform A from the |AO| basis to the |MO| basis
  !
  ! $C^\dagger.A_{ao}.C$
  END_DOC
  integer, intent(in)            :: LDA_ao,LDA_mo
  double precision, intent(in)   :: A_ao(LDA_ao,ao_num)
  double precision, intent(out)  :: A_mo(LDA_mo,mo_num)
  double precision, allocatable  :: T(:,:)

  allocate ( T(ao_num,mo_num) )
  !DIR$ ATTRIBUTES ALIGN : $IRP_ALIGN :: T

  call dgemm('N','N', ao_num, mo_num, ao_num,                    &
      1.d0, A_ao,LDA_ao,                                             &
      mo_coef, size(mo_coef,1),                                      &
      0.d0, T, size(T,1))

  call dgemm('T','N', mo_num, mo_num, ao_num,                &
      1.d0, mo_coef,size(mo_coef,1),                                 &
      T, ao_num,                                                     &
      0.d0, A_mo, size(A_mo,1))

  deallocate(T)
end

subroutine run_sort_by_fock_energies()
  BEGIN_DOC
  ! Program that saves the current |MOs| ordered by diagonal element of the Fock operator.
  !
  ! Warning : the Fock operator, and therefore its matrix elements, depends on the occupancy.
  END_DOC
  implicit none
  integer                        :: i,j,k
  integer, allocatable           :: iorder(:)
  double precision, allocatable  :: fock_energies_tmp(:), new_mo_coef(:,:)

  allocate(iorder(mo_num), fock_energies_tmp(mo_num),new_mo_coef(ao_num,mo_num))

  do i = 1, mo_num
    fock_energies_tmp(i) = Fock_matrix_diag_mo(i)
    print*,'fock_energies_tmp(i) = ',fock_energies_tmp(i)
    iorder(i) = i
  enddo

  print*,''
  print*,'Sorting by Fock energies'
  print*,''

  call dsort(fock_energies_tmp,iorder,mo_num)

  do i = 1, mo_num
    k = iorder(i)
    print*,'fock_energies_new(i) = ',fock_energies_tmp(i)
    do j = 1, ao_num
      new_mo_coef(j,i) = mo_coef(j,k)
    enddo
  enddo

  mo_coef = new_mo_coef
  touch mo_coef
  call save_mos
  
end

#+END_SRC
