* Orbital optimization program

This is an optimization program for molecular orbitals. It produces
orbital rotations in order to lower the energy of a truncated wave
function.  
This program just optimize the orbitals for a fixed number of
determinants. This optimization process must be repeated for different
number of determinants.

#+BEGIN_SRC f90 :comments org :tangle org_orb_opt_trust_v2.irp.f
#+END_SRC

* Main program : orb_opt_trust

#+BEGIN_SRC f90 :comments org :tangle org_orb_opt_trust_v2.irp.f 
program org_orb_opt_trust_v2
  read_wf = .true. ! must be True for the orbital optimization !!!
  TOUCH read_wf
  call org_run_orb_opt_trust_v2
end
#+END_SRC

* Subroutine : run_orb_opt_trust

#+BEGIN_SRC f90 :comments org :tangle org_orb_opt_trust_v2.irp.f
#+END_SRC

*Subroutine to optimize orbitals*

Optimization process :
   - compute the gradient
   - compute the hessian 
   - diagonalize the hessian
   - compute the step of the Newton method in the trust region
   - compute the predicted energy for the new MOs
   - compute the rotation matrix
   - compute the new MOs using the rotation matrix and the actual MOs
   - diagonalize the hamiltonian
   - compute rho, the quality of the model. While the quality is not good,
     the orbital rotations are cancelled and the a smaller step is
     computed. If there is a good agreement, the step is accepted and
     the algorithm compute a new step.

   There are three convergence criteria:
   - the maximal value in the gradient,
   - the size of the trust region,
   - And to avoid problems, there is a limit in the maximal number of
     hamiltonian diagonalization.  

Provided:
| mo_num                         | integer          | number of MOs                  |
| ao_num                         | integer          | number of AOs                  |
| N_states                       | integer          | number of states               |
| ci_energy(N_states)            | double precision | CI energies                   |
| state_average_weight(N_states) | double precision | Weight of the different states |

Parameter:
| method | integer | - 1 -> full hessian     |
|        |         | - 2 -> diagonal hessian |

Variables:
| n                               | integer          | mo_num*(mo_num-1)/2                                |
| v_grad(n)                       | double precision | gradient                                           |
| H(n,n)                          | double precision | hessian (2D)                                       |
| h_f(mo_num,mo_num,mo_num,mo_num | double precision | hessian (4D)                                       |
| e_val(n)                        | double precision | eigenvalues of the hessian                         |
| w(n,n)                          | double precision | eigenvectors of the hessian                        |
| x(n)                            | double precision | step given by the trust region                     |
| m_x(n,n)                        | double precision | step given by the trust region after               |
| R(mo_num,mo_num)                | double precision | rotation matrix                                    |
|                                 |                  | the transformation into a matrixÅ“                  |
| prev_mos(ao_num,mo_num)         | double precision | previous MOs (before the rotation)                 |
| new_mos(ao_num,mo_num)          | double precision | new MOs (after the roration)                       |
| delta                           | double precision | radius of the trust region                         |
| rho                             | double precision | agreement between the model and the exact function |
| max_elem                        | double precision | maximum element in the gradient                    |
| i                               | integer          | index                                              |
| converged                       | logical          | convergence of the algorithm                       |
| cancel_step                     | logical          | if the step must be cancelled                      |
| nb_iter                         | integer          | number of iterations (accepted)                    |
| nb_diag                         | integer          | number of diagonalizations of the CI matrix        |
| nb_cancel                       | integer          | number of cancelled steps for the actual iteration |
| nb_cancel_tot                   | integer          | total number of cancel steps                       |
| info                            | integer          | if 0 ok, else problem in the diagonalization of    |
|                                 |                  | the hessian with the Lapack routine                |
| prev_energy                     | double precision | energy before the rotation                         |
| e_model                         | double precision | estimated energy after the rotation using          |
|                                 |                  | a Taylor series                                   |


   #+BEGIN_SRC f90 :comments org :tangle org_orb_opt_trust_v2.irp.f
subroutine org_run_orb_opt_trust_v2

  include 'constants.h'

  implicit none

  ! Variables

  double precision, allocatable :: R(:,:)
  double precision, allocatable :: H(:,:),h_f(:,:,:,:)
  double precision, allocatable :: v_grad(:)
  double precision, allocatable :: prev_mos(:,:),new_mos(:,:)
  integer                       :: info
  integer                       :: n
  integer                       :: i,j,p,q,k
  double precision              :: max_elem, delta, rho
  logical :: cancel_step
  integer :: nb_iter, nb_diag, nb_cancel, nb_cancel_tot
  double precision :: t1, t2, t3
  double precision :: prev_criterion, criterion, criterion_model
  logical :: not_converged, must_exit
  integer :: m, tmp_n, tmp_i, tmp_j, tmp_k
  integer,allocatable :: tmp_list(:)
  double precision, allocatable :: tmp_m_x(:,:),tmp_R(:,:), tmp_x(:)

  PROVIDE mo_two_e_integrals_in_map ci_energy psi_det psi_coef
   #+END_SRC
   
** Method
   There are two different methods : 
   - the "full" hessian, which uses all the elements of the hessian
     matrix, called "hess" in "hessian.irp.f"
   - the "diagonal" hessian, which uses only the diagonal elements of the
     hessian, called "diag_hess" in "diagonal_hessian.irp.f"

   #+BEGIN_SRC f90 :comments org :tangle org_orb_opt_trust_v2.irp.f
  !Display the method
  print*, 'Method :', method
  if (method == 1) then ! 1 -> Full hessian, 2 -> Diagonal hessian
    print*, 'Full hessian'
  else 
    print*,'Diagonal hessian'
  endif
  print*, 'Absolute value of the hessian:', absolute_eig
   #+END_SRC

** Allocation

   n represents the number of pairs (p,q) with p<q.
   Where p and q are general molecular orbitals.

   In other words, the gradient is an antisymmetric matrix of size mo_num
   by mo_num. So we can summarize the matrix by the lower/upper triangle.
   And this triangle is composed of :
   $$(mo_{num}^2 - mo_{num})/2 = mo_{num}(mo_{num}-1)/2$$

   Cf. mat_to_vec_index and vec_to_mat_index

   #+BEGIN_SRC f90 :comments org :tangle org_orb_opt_trust_v2.irp.f
  ! Definition of n
  allocate(R(mo_num,mo_num))  ! rotation matrix
  allocate(prev_mos(ao_num,mo_num),new_mos(ao_num,mo_num)) ! old and new MOs
  
  m = dim_list_act_orb
  tmp_n = m*(m-1)/2
  
  allocate(tmp_list(m))
  allocate(tmp_R(m,m), tmp_m_x(m,m), tmp_x(tmp_n))
  allocate(H(tmp_n,tmp_n), h_f(m,m,m,m), v_grad(tmp_n))

   #+END_SRC

** Calculations
*** Initialization

    #+BEGIN_SRC f90 :comments org :tangle org_orb_opt_trust_v2.irp.f
  ! Initialization of the CI energy
  call diagonalize_ci

  print *, 'CI energy : ', ci_energy

    #+END_SRC

*** Algorithm


    #+BEGIN_SRC f90 :comments org :tangle org_orb_opt_trust_v2.irp.f
  ! Loop until the convergence of the optimization

  !### Initialization ###
  nb_iter = 0
  rho = 0.5d0
  not_converged = .True.
  tmp_list = list_act
  
  ! ### TODO ###
  ! Compute the criterion before the loop
  call update_st_av_ci_energy(prev_criterion)
  print*, 'State av energy :', prev_criterion

  do while (not_converged)
    ! ### TODO ## 
    ! Call your gradient
    ! Call you hessian

    ! Gradient
    call first_gradient_list(tmp_n,m,tmp_list,v_grad)
    max_elem = 1d0
    ! Hessian
    if (method == 1) then
       call first_hess_list(tmp_n,m,tmp_list,H,h_f)
    else
       call first_diag_hess_list(tmp_n,m,tmp_list,H,h_f)
    endif

    cancel_step = .True. ! To enter in the loop just after 
    ! Loop to Reduce the trust radius until the criterion decreases and rho >= thresh_rho
    do while (cancel_step)
      ! Hessian,gradient,Criterion -> x 
      call step_in_trust_region(tmp_n,m,H,v_grad,prev_criterion,rho,nb_iter,delta,criterion_model,tmp_x,must_exit) 
      if (must_exit) then
        ! ### Message ###
        ! if algo_trust1 sets must_exit on true for numerical reasons
        print*,'step_in_trust_region sends the message : Exit'
        exit
      endif
      !### TODO ###  
      ! Compute x -> m_x
      ! Compute m_x -> R
      ! Apply R and keep the previous MOs...
      ! Update/touch 
      ! Compute the new criterion/energy -> criterion

      ! 1D tmp -> 2D tmp 
      call vec_to_mat_v2(tmp_n,m,tmp_x,tmp_m_x)

      call org_rotation_matrix(tmp_m_x,m,tmp_R,m,m,info)

      ! tmp_R to R, subspace to full space
      R = 0d0
      do i = 1, mo_num
        R(i,i) = 1d0 ! 1 on the diagonal because it is a rotation matrix, 1 = nothing change for the corresponding orbital
      enddo
      do tmp_j = 1, m
        j = tmp_list(tmp_j)
        do tmp_i = 1, m
          i = tmp_list(tmp_i)
          R(i,j) = tmp_R(tmp_i,tmp_j)
        enddo
      enddo

      call org_apply_mo_rotation(R, prev_mos)   

      ! Update and diagonalization of the hamiltonian
      call clear_mo_map
      TOUCH mo_coef psi_det psi_coef
      call diagonalize_ci
      call save_wavefunction_unsorted

      ! Energy of the actual step
      call update_st_av_ci_energy(criterion)

      ! Criterion -> step accepted or rejected 
      call is_step_cancel_trust_region(nb_iter,prev_criterion, criterion, criterion_model,rho,cancel_step)

      !Â ### TODO ###
      !if (cancel_step) then
      ! Cancel the previous step (mo_coef = prev_mos if you keep them...)
      !endif

      if (cancel_step) then
        mo_coef = prev_mos
        call save_mos()
      endif
      if (delta < 1d-10) then
        print*,'delta < 1d-10, return'
        return
      endif

    enddo
    call save_mos() !### depend of the time for 1 iteration
    ! To exit the external loop if must_exti = .True.
    if (must_exit) then
      exit
    endif 

    ! Step accepted, nb iteration + 1
    nb_iter = nb_iter + 1
    ! ### TODO ###
    !if (###Conditions###) then
    ! no_converged = .False.
    !endif
    if (DABS(max_elem) < 1d-6) then
      not_converged = .False.
    endif
    if (nb_iter > 20) then
      not_converged = .False. 
    endif
    if (.not. not_converged) then
      print*,'##################################'
      print*,'Converged, end of the optimization'
      print*,'##################################'
    endif
  enddo

  call diagonalize_ci
    #+END_SRC
    
** Deallocation, end

    #+BEGIN_SRC f90 :comments org :tangle org_orb_opt_trust_v2.irp.f
  deallocate(v_grad,H,R)
  deallocate(h_f,prev_mos,new_mos)

end
    #+END_SRC
