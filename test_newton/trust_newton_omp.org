* Newton's method to find the optimal lambda

*Compute the lambda value for the trust region*

This subroutine use the Newton's method in order to find the optimal
lambda (to have the step in the trust region). So we just search the
minimum of $||\textbf{x}_{(k+1)}(\lambda)||^2 - \Delta^2$ for $\lambda \in
]-h_1;+\infty[$. $h_1$ is the smallest eigenvalue and $h_1 < 0$. So to
avoid numerical problems (cf. trust_region) we start the algorithm at
$\lambda=0$.

By the way, we already know the value of the function
$||\textbf{x}_{(k+1)}(\lambda)||^2 - \Delta^2$ for the optimal lambda (0). 

The Newton's method to find the optimal $\lambda$ is :
\begin{equation}
\lambda_{(k+1)} = \lambda_{(k)} - H_{(k)}^{-1} g_{(k)}
\end{equation}

H : the hessian <=> second derivative with respect to lambda
g : the gradient <=> first derivative with respect to lambda

The first and second derivatives are :
\begin{equation}
\frac{\partial }{\partial \lambda} (||\textbf{x}(\lambda)||^2 - \Delta^2)^2 
= 2 \left(\sum_{i=1}^n \frac{-2(\textbf{w}_i^T \textbf{g})^2}{(h_i + \lambda)^3} \right)
\left( - \Delta^2 + \sum_{i=1}^n \frac{(\textbf{w}_i^T \textbf{g})^2}{(h_i+ \lambda)^2} \right)
\end{equation}
\begin{equation}
\frac{\partial^2 }{\partial \lambda^2} (||\textbf{x}(\lambda)||^2 - \Delta^2)^2 
= 2 \left[ \left( \sum_{i=1}^n 6 \frac{(\textbf{w}_i^T \textbf{g})^2}{(h_i + \lambda)^4} \right) \left( - \Delta^2 + \sum_{i=1}^n \frac{(\textbf{w}_i^T \textbf{g})^2}{(h_i + \lambda)^2} \right) + \left( \sum_{i=1}^n -2 \frac{(\textbf{w}_i^T \textbf{g})^2}{(h_i + \lambda)^3} \right)^2 \right]
\end{equation}

Provided:
| mo_num | integer | number of MOs |

Input:
 | n         | integer          | mo_num*(mo_num-1)/2         |
 | e_val(n)  | double precision | eigenvalues of the hessian  |
 | W(n,n)    | double precision | eigenvectors of the hessian |
 | v_grad(n) | double precision | gradient                    |
 | delta     | double precision | delta for the trust region  |

Output:
| lambda | double precision | Lagrange multiplier to constrain the norm of the size of the Newton step |
|        |                  | lambda > 0                                                           |

Internal:
| d1_N     | double precision | value of d1_norm_trust_region |
| d2_N     | double precision | value of d2_norm_trust_region |
| f_N      | double precision | value of f_norm_trust_region  |
| t1,t2,t3 | double precision | wall time                     |
| i        | integer          | index                         |

Function:
| d1_norm_trust_region | double precision | first derivative with respect to lambda of  norm(x)^2 - Delta^2 |
| d2_norm_trust_region | double precision | second derivative with respect to lambda of norm(x)^2 - Delta^2 |
| f_norm_trust_region  | double precision | value of norm(x)^2                                              |


#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
subroutine org_trust_newton_omp(n,e_val,w,v_grad,delta,lambda)

  include 'constants.h'

  implicit none
  
  ! Variables
  
  ! in
  integer, intent(in) :: n
  double precision, intent(in) :: e_val(n)
  double precision, intent(in) :: w(n,n)
  double precision, intent(in) :: v_grad(n)
  double precision, intent(in) :: delta 

  ! out
  double precision, intent(out) :: lambda

  ! Internal
  double precision :: d1_N,d2_N,f_N
  double precision :: t1,t2,t3
  integer          :: i

  ! Functions
  double precision :: d1_norm_trust_region,d1_norm_trust_region_omp
  double precision :: d2_norm_trust_region, d2_norm_trust_region_omp
  double precision :: f_norm_trust_region, f_norm_trust_region_omp
#+END_SRC

Resolution with the Newton method:
#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
 if (debug) then
    print*,'Enter in trust_newton'
  endif

  ! Initialization
  lambda = 0d0

  ! Newton's method to find the optimal lambda for the trust region
  CALL wall_time(t1)

  ! Debug
  if (debug) then
      print*, 'Iteration   First derivative   lambda    ||x||^2'
  endif

  ! Initialization  
  i = 1
  f_N = 0d0 ! to enter in the loop ...

  ! Newton's method
  do while (i <= 100 .and. ABS(1d0-f_N/delta**2)>1d-6)
    d1_N = d1_norm_trust_region_omp(n,e_val,w,v_grad,lambda,delta) ! first derivative
    d2_N = d2_norm_trust_region_omp(n,e_val,w,v_grad,lambda,delta) ! second derivative
    lambda = lambda - (1d0/ABS(d2_N))*d1_N ! New lambda
    f_N = f_norm_trust_region_omp(n,e_val,w,v_grad,lambda) ! Value of the norm
    
    ! Debug
    if (debug) then
      print*, i, d1_N, lambda, f_N, ABS(1d0-f_N/delta**2)
    endif  

    i = i+1
  enddo

  CALL wall_time(t2)

  ! Time
  t3 = t2 - t1
  print*,'Time to search the optimal lambda :', t3
  print*,'Number of iterations :', i
  print*,'Error on the trust region :', 1d0-f_N/delta**2
  
  ! Debug
  if (debug) then
    print*,'Leave trust_newton'
  endif

end subroutine
#+END_SRC

* OMP : First derivative of (||x||^2 - Delta^2)^2

*Function to compute the first derivative of (||x||^2 - Delta^2)^2*

This function compute the first derivative of (||x||^2 - Delta^2)^2
with respect to lambda.

\begin{equation}
\frac{\partial }{\partial \lambda} (||\textbf{x}(\lambda)||^2 - \Delta^2)^2 
= 2 \left(\sum_{i=1}^n \frac{-2(\textbf{w}_i^T \textbf{g})^2}{(h_i + \lambda)^3} \right)
\left( - \Delta^2 + \sum_{i=1}^n \frac{(\textbf{w}_i^T \textbf{g})^2}{(h_i+ \lambda)^2} \right)
\end{equation}

Provided:
| mo_num | integer | number of MOs |

Input:
| n         | integer          | mo_num*(mo_num-1)/2         |
| e_val(n)  | double precision | eigenvalues of the hessian  |
| W(n,n)    | double precision | eigenvectors of the hessian |
| v_grad(n) | double precision | gradient                    |
| lambda    | double precision | Lagrange multiplier         |
| delta     | double precision | Delta of the trust region   |

Internal:
| accu1      | double precision | first sum of the formula           |
| accu2      | double precision | second sum of the formula          |
| tmp_accu1  | double precision | temporary array for the first sum  |
| tmp_accu2  | double precision | temporary array for the second sum |
| tmp_wtg(n) | double precision | temporary array for W^t.v_grad     |
| i,j        | integer          | indexes                            |

Function:
| d1_norm_trust_region | double precision | first derivative with respect to lambda of norm(x)^2 - Delta^2 |

#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
function d1_norm_trust_region_omp(n,e_val,w,v_grad,lambda,delta)

  use omp_lib

  implicit none

  ! in
  integer, intent(in)           :: n
  double precision, intent(in)  :: e_val(n)
  double precision, intent(in)  :: w(n,n)
  double precision, intent(in)  :: v_grad(n)
  double precision, intent(in)  :: lambda
  double precision, intent(in)  :: delta
   
  ! Internal
  double precision              :: wtg,accu1,accu2
  integer                       :: i,j
  double precision, allocatable :: tmp_accu1(:), tmp_accu2(:), tmp_wtg(:)

  ! Functions
  double precision              :: d1_norm_trust_region_omp

  ! Allocation
  allocate(tmp_accu1(n), tmp_accu2(n), tmp_wtg(n))

  ! OMP
  call omp_set_max_active_levels(1)

  ! OMP 
  !$OMP PARALLEL                                                      &
      !$OMP PRIVATE(i,j)                                          &
      !$OMP SHARED(n,lambda,v_grad, w, e_val,                         &
      !$OMP tmp_accu1, tmp_accu2, tmp_wtg, accu1,accu2) &
      !$OMP DEFAULT(NONE)
#+END_SRC

** Initialization

#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
  !$OMP MASTER
  accu1 = 0d0
  accu2 = 0d0
  !$OMP END MASTER

  !$OMP DO
  do i = 1, n
    tmp_accu1(i) = 0d0
  enddo
  !$OMP END DO

  !$OMP DO
  do i = 1, n
    tmp_accu2(i) = 0d0
  enddo
  !$OMP END DO

  !$OMP DO
  do i = 1, n
    tmp_wtg = 0d0
  enddo
  !$OMP END DO
#+END_SRC

** Part 1

\begin{equation}
\sum_{i=1}^n \frac{-2(w_i^T g_k)^2}{(h_i + \lambda)^3}
\end{equation}

#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
  !$OMP DO
  do i = 1, n
    do j = 1, n
      tmp_wtg(i) = tmp_wtg(i) +  w(j,i) * v_grad(j)
    enddo
  enddo
  !$OMP END DO

  !$OMP DO
  do i = 1, n
    if (e_val(i)>1e-6) then
      tmp_accu1(i) = - 2d0 * tmp_wtg(i)**2 /  (e_val(i) + lambda)**3
    endif
  enddo
  !$OMP END DO
 
  !$OMP MASTER
  do i = 1, n 
    accu1 = accu1 + tmp_accu1(i)
  enddo
  !$OMP END MASTER
#+END_SRC

** Part 2

\begin{equation}
\sum_{i=1}^n \frac{(w_i^T g_k)^2}{(h_i+ \lambda)^2}
\end{equation}

#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
  !$OMP DO
  do i = 1, n
    if (e_val(i)>1e-6) then
      tmp_accu2(i) =  tmp_wtg(i)**2 / (e_val(i) + lambda)**2
    endif
  enddo
  !$OMP END DO

  !$OMP MASTER
  do i = 1, n
    accu2 = accu2 + tmp_accu2(i)
  enddo
  !$OMP END MASTER
#+END_SRC

** End 

#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
  !$OMP END PARALLEL

  call omp_set_max_active_levels(4)

  d1_norm_trust_region_omp = 2d0 * accu1 * (accu2 - delta**2)

  deallocate(tmp_accu1, tmp_accu2, tmp_wtg)

end function
#+END_SRC

* OMP : Second derivative of (||x||^2 - Delta^2)^2

*Function to compute the second derivative of (||x||^2 - Delta^2)^2*

This function compute the second derivative of (||x||^2 - Delta^2)^2
with respect to lambda.
\begin{equation}
\frac{\partial^2 }{\partial \lambda^2} (||\textbf{x}(\lambda)||^2 - \Delta^2)^2 
= 2 \left[ \left( \sum_{i=1}^n 6 \frac{(\textbf{w}_i^T \textbf{g})^2}{(h_i + \lambda)^4} \right) \left( - \Delta^2 + \sum_{i=1}^n \frac{(\textbf{w}_i^T \textbf{g})^2}{(h_i + \lambda)^2} \right) + \left( \sum_{i=1}^n -2 \frac{(\textbf{w}_i^T \textbf{g})^2}{(h_i + \lambda)^3} \right)^2 \right]
\end{equation}

Provided:
| m_num | integer | number of MOs |

Input:
| n         | integer          | mo_num*(mo_num-1)/2         |
| e_val(n)  | double precision | eigenvalues of the hessian  |
| W(n,n)    | double precision | eigenvectors of the hessian |
| v_grad(n) | double precision | gradient                    |
| lambda    | double precision | Lagrange multiplier         |
| delta     | double precision | Delta of the trust region   |

Internal:
| accu1      | double precision | first sum of the formula           |
| accu2      | double precision | second sum of the formula          |
| accu3      | double precision | third sum of the formula           |
| tmp_accu1  | double precision | temporary array for the first sum  |
| tmp_accu2  | double precision | temporary array for the second sum |
| tmp_accu2  | double precision | temporary array for the third sum  |
| tmp_wtg(n) | double precision | temporary array for W^t.v_grad     |
| i,j        | integer          | indexes                            |

Function:
| d2_norm_trust_region | double precision | second derivative with respect to lambda of norm(x)^2 - Delta^2 |

#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
function d2_norm_trust_region_omp(n,e_val,w,v_grad,lambda,delta)
  
  use omp_lib

  implicit none

  ! Variables

  ! in
  integer, intent(in) :: n
  double precision, intent(in) :: e_val(n)
  double precision, intent(in) :: w(n,n)
  double precision, intent(in) :: v_grad(n)
  double precision, intent(in) :: lambda
  double precision, intent(in) :: delta

  ! Functions
  double precision :: d2_norm_trust_region_omp
  double precision :: ddot

  ! Internal
  double precision :: wtg,accu1,accu2,accu3
  double precision, allocatable :: tmp_wtg(:), tmp_accu1(:), tmp_accu2(:), tmp_accu3(:)
  integer :: i, j
  
  ! Allocation
  allocate(tmp_wtg(n), tmp_accu1(n), tmp_accu2(n), tmp_accu3(n))

  call omp_set_max_active_levels(1)

  ! OMP 
  !$OMP PARALLEL                                                     &
      !$OMP PRIVATE(i,j)                                         &
      !$OMP SHARED(n,lambda,v_grad, w, e_val, &
      !$OMP tmp_accu1, tmp_accu2, tmp_accu3, tmp_wtg, accu1,accu2,accu3)&
      !$OMP DEFAULT(NONE)
#+END_SRC
 
** Initialization

#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
  !$OMP MASTER
  accu1 = 0d0
  accu2 = 0d0
  accu3 = 0d0 
  !$OMP END MASTER

  !$OMP DO
  do i = 1, n 
    tmp_wtg(i) = 0d0
  enddo
  !$OMP END DO
  !$OMP DO
  do i = 1, n 
    tmp_accu1(i) = 0d0
  enddo
  !$OMP END DO
  !$OMP DO
  do i = 1, n
    tmp_accu2(i) = 0d0
  enddo
  !$OMP END DO
  !$OMP DO
  do i = 1, n
    tmp_accu3(i) = 0d0
  enddo
  !$OMP END DO
#+END_SRC
 
** Part 1
\begin{equation}
\left( \sum_{i=1}^n 6 \frac{(\textbf{w}_i^T \textbf{g})^2}{(h_i + \lambda)^4} \right)
\end{equation}
#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
  !$OMP DO
  do i = 1, n
    do j = 1, n
      tmp_wtg(i) = tmp_wtg(i) +  w(j,i) * v_grad(j)
    enddo
  enddo
  !$OMP END DO

  !$OMP DO
  do i = 1, n
    if (e_val(i)>1e-6) then
      tmp_accu1(i) = 6d0 * tmp_wtg(i)**2 /  (e_val(i) + lambda)**4
    endif
  enddo
  !$OMP END DO

  !$OMP MASTER
  do i = 1, n
    accu1 = accu1 + tmp_accu1(i)
  enddo
  !$OMP END MASTER
#+END_SRC

** Part 2
\begin{equation}
\left( \sum_{i=1}^n \frac{(\textbf{w}_i^T
\textbf{g})^2}{(h_i + \lambda)^2} \right)
\end{equation}
#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
  !$OMP DO
  do i = 1, n
    if (e_val(i)>1e-6) then
      tmp_accu2(i) = tmp_wtg(i)**2 /  (e_val(i) + lambda)**2
    endif
  enddo
  !$OMP END DO
 
  !$OMP MASTER
  do i = 1, n
    accu2 = accu2 + tmp_accu2(i)
  enddo
  !$OMP END MASTER
#+END_SRC

** Part 3
\begin{equation}
\left( \sum_{i=1}^n -2 \frac{(\textbf{w}_i^T \textbf{g})^2}{(h_i + \lambda)^3} \right)^2 \right]
\end{equation}
#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
  !$OMP DO
  do i = 1, n
    if (e_val(i)>1e-6) then
      tmp_accu3(i) = -2d0 * tmp_wtg(i)**2 /  (e_val(i) + lambda)**3
    endif
  enddo
  !$OMP END DO

  !$OMP MASTER
  do i = 1, n
    accu3 = accu3 + tmp_accu3(i)
  enddo
  !$OMP END MASTER
#+END_SRC

** End 

#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
  !$OMP END PARALLEL

  d2_norm_trust_region_omp = 2d0 * (accu1 * (- delta**2 + accu2) + accu3**2)

  deallocate(tmp_wtg, tmp_accu1, tmp_accu2, tmp_accu3)

end function
#+END_SRC

* OMP : Function value of ||x||^2

*Compute the value of ||x||^2*

This function compute the value of ||x(lambda)||^2

\begin{equation}
||\textbf{x}(\lambda)||^2 = \sum_{i=1}^n \frac{(\textbf{w}_i^T \textbf{g})^2}{(h_i + \lambda)^2}
\end{equation}

Provided:
| m_num | integer | number of MOs |

Input:
| n         | integer          | mo_num*(mo_num-1)/2         |
| e_val(n)  | double precision | eigenvalues of the hessian  |
| W(n,n)    | double precision | eigenvectors of the hessian |
| v_grad(n) | double precision | gradient                    |
| lambda    | double precision | Lagrange multiplier         |
| delta     | double precision | Delta of the trust region   |

Internal:
| tmp_wtg(n) | double precision | temporary array for W^T.v_grad   |
| tmp_fN     | double precision | temporary array for the function |
| i,j        | integer          | indexes                          |

#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
function f_norm_trust_region_omp(n,e_val,w,v_grad,lambda)

  use omp_lib

  implicit none

  ! Variables

  ! in
  integer, intent(in) :: n
  double precision, intent(in) :: e_val(n)
  double precision, intent(in) :: w(n,n)
  double precision, intent(in) :: v_grad(n)
  double precision, intent(in) :: lambda
 
  ! functions
  double precision :: f_norm_trust_region_omp
 
  ! internal
  double precision, allocatable :: tmp_wtg(:), tmp_fN(:)
  integer :: i,j

  ! Allocation
  allocate(tmp_wtg(n), tmp_fN(n))

  call omp_set_max_active_levels(1)

  ! OMP 
  !$OMP PARALLEL                              &
      !$OMP PRIVATE(i,j)                  &
      !$OMP SHARED(n,lambda,v_grad, w, e_val, &
      !$OMP tmp_fN, tmp_wtg, f_norm_trust_region_omp)          &
      !$OMP DEFAULT(NONE)
#+END_SRC

** Initialization
#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
  ! Initialization
  !$OMP MASTER
  f_norm_trust_region_omp = 0d0
  !$OMP END MASTER

  !$OMP DO
  do i = 1, n
    tmp_fN(i) = 0d0
  enddo
  !$OMP END DO

  !$OMP DO
  do i = 1, n
    tmp_wtg(i) = 0d0
  enddo
  !$OMP END DO
#+END_SRC

** Calculation
#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
  !$OMP DO
  do i = 1, n
    do j = 1, n
      tmp_wtg(i) = tmp_wtg(i) +  w(j,i) * v_grad(j)
    enddo
  enddo
  !$OMP END DO

  !$OMP DO
  do i = 1, n
    if (e_val(i)>1d-6) then
      tmp_fN(i) = tmp_wtg(i)**2 / (e_val(i) + lambda)**2
    endif
  enddo
  !$OMP END DO
  
  !$OMP MASTER
  do i = 1, n
    f_norm_trust_region_omp =  f_norm_trust_region_omp + tmp_fN(i)
  enddo
  !$OMP END MASTER

  !$OMP END PARALLEL

  deallocate(tmp_wtg, tmp_fN)

end function
#+END_SRC

* First derivative of (||x||^2 - Delta^2)^2
Version without omp

*Function to compute the first derivative of ||x||^2 - Delta*

This function compute the first derivative of (||x||^2 - Delta^2)^2
with respect to lambda.

\begin{equation}
\frac{\partial }{\partial \lambda} (||\textbf{x}(\lambda)||^2 - \Delta^2)^2 
= 2 \left(\sum_{i=1}^n \frac{-2(\textbf{w}_i^T \textbf{g})^2}{(h_i + \lambda)^3} \right)
\left( - \Delta^2 + \sum_{i=1}^n \frac{(\textbf{w}_i^T \textbf{g})^2}{(h_i+ \lambda)^2} \right)
\end{equation}

Provided:
| m_num | integer | number of MOs |

Input:
| n         | integer          | mo_num*(mo_num-1)/2         |
| e_val(n)  | double precision | eigenvalues of the hessian  |
| W(n,n)    | double precision | eigenvectors of the hessian |
| v_grad(n) | double precision | gradient                    |
| lambda    | double precision | Lagrange multiplier         |
| delta     | double precision | Delta of the trust region   |

Internal:
| accu1 | double precision | first sum of the formula               |
| accu2 | double precision | second sum of the formula              |
| wtg   | double precision | temporary variable to store W^T.v_grad |
| i,j   | integer          | indexes                                |

Function:
| d1_norm_trust_region | double precision | first derivative with respect to lambda of norm(x)^2 - Delta^2 |
| ddot                 | double precision | blas dot product                                               |

#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
function d1_norm_trust_region(n,e_val,w,v_grad,lambda,delta)

  implicit none

  ! Variables
  
  ! in
  integer, intent(in)          :: n
  double precision, intent(in) :: e_val(n)
  double precision, intent(in) :: w(n,n)
  double precision, intent(in) :: v_grad(n)
  double precision, intent(in) :: lambda
  double precision, intent(in) :: delta

  ! Internal
  double precision :: wtg,accu1,accu2
  integer          :: i,j

  ! Functions
  double precision :: d1_norm_trust_region
  double precision :: ddot
#+END_SRC  

** Calculations
*** Initialization
#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
  accu1 = 0d0
  accu2 = 0d0
#+END_SRC

*** Part 1
\begin{equation}
\sum_{i=1}^n \frac{-2(w_i^T g_k)^2}{(h_i + \lambda)^3}
\end{equation}
#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
  do i = 1, n
    wtg = 0d0
    do j = 1, n
      wtg = wtg + w(j,i) * v_grad(j)
    enddo
    !wtg = ddot(n,w(:,i),1,v_grad,1)
    if (e_val(i)>1e-6) then
      accu1 = accu1 - 2d0 * wtg**2 / (e_val(i) + lambda)**3
    endif
  enddo
#+END_SRC

*** Part 2
\begin{equation}
\sum_{i=1}^n \frac{(w_i^T g_k)^2}{(h_i+ \lambda)^2}
\end{equation} 
#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
  do i = 1, n
    wtg = 0d0
    do j = 1, n
      wtg = wtg + w(j,i) * v_grad(j)
    enddo
    !wtg = ddot(n,w(:,i),1,v_grad,1)
    if (e_val(i)>1e-6) then
      accu2 = accu2 + wtg**2 / (e_val(i) + lambda)**2
    endif
  enddo
#+END_SRC

*** End
#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
  d1_norm_trust_region = 2d0 * accu1 * (accu2 - delta**2)

end function
#+END_SRC

* Second derivative of (||x||^2 - Delta^2)^2
Version without OMP

*Function to compute the second derivative of ||x||^2 - Delta*

\begin{equation}
\frac{\partial^2 }{\partial \lambda^2} (||\textbf{x}(\lambda)||^2 - \Delta^2)^2 
= 2 \left[ \left( \sum_{i=1}^n 6 \frac{(\textbf{w}_i^T \textbf{g})^2}{(h_i + \lambda)^4} \right) \left( - \Delta^2 + \sum_{i=1}^n \frac{(\textbf{w}_i^T \textbf{g})^2}{(h_i + \lambda)^2} \right) + \left( \sum_{i=1}^n -2 \frac{(\textbf{w}_i^T \textbf{g})^2}{(h_i + \lambda)^3} \right)^2 \right]
\end{equation}

Provided:
| m_num | integer | number of MOs |

Input:
| n         | integer          | mo_num*(mo_num-1)/2         |
| e_val(n)  | double precision | eigenvalues of the hessian  |
| W(n,n)    | double precision | eigenvectors of the hessian |
| v_grad(n) | double precision | gradient                    |
| lambda    | double precision | Lagrange multiplier         |
| delta     | double precision | Delta of the trust region   |

Internal:
| accu1 | double precision | first sum of the formula               |
| accu2 | double precision | second sum of the formula              |
| accu3 | double precision | third sum of the formula                |
| wtg   | double precision | temporary variable to store W^T.v_grad |
| i,j   | integer          | indexes                                |

Function:
| d2_norm_trust_region | double precision | second derivative with respect to lambda of norm(x)^2 - Delta^2       |
| ddot                 | double precision | blas dot product                                               |

#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
function d2_norm_trust_region(n,e_val,w,v_grad,lambda,delta)

  implicit none

  ! Variables

  ! in
  integer, intent(in) :: n
  double precision, intent(in) :: e_val(n)
  double precision, intent(in) :: w(n,n)
  double precision, intent(in) :: v_grad(n)
  double precision, intent(in) :: lambda
  double precision, intent(in) :: delta

  ! Functions
  double precision :: d2_norm_trust_region
  double precision :: ddot

  ! Internal
  double precision :: wtg,accu1,accu2,accu3
  integer :: i, j
#+END_SRC

** Calculations
*** Initialization
#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
  accu1 = 0d0
  accu2 = 0d0
  accu3 = 0d0
#+END_SRC

*** Part 1
\begin{equation}
\left( \sum_{i=1}^n 6 \frac{(\textbf{w}_i^T \textbf{g})^2}{(h_i + \lambda)^4} \right)
\end{equation}
#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
  do i = 1, n
    if (e_val(i)>1d-6) then
      wtg = 0d0
      do j = 1, n
        wtg = wtg + w(j,i) * v_grad(j)
      enddo
      !wtg = ddot(n,w(:,i),1,v_grad,1)
      accu1 = accu1 + 6d0 * wtg**2 / (e_val(i) + lambda)**4
    endif
  enddo
#+END_SRC

*** Part 2
\begin{equation}
\left( - \Delta^2 + \sum_{i=1}^n \frac{(\textbf{w}_i^T
\textbf{g})^2}{(h_i + \lambda)^2} \right)
\end{equation}
#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
  do i = 1, n
    if (e_val(i)>1d-6) then
      wtg = 0d0
      do j = 1, n
        wtg = wtg + w(j,i) * v_grad(j)
      enddo
      !wtg = ddot(n,w(:,i),1,v_grad,1)
      accu2 = accu2 + wtg**2 / (e_val(i) + lambda)**2
    endif
  enddo
#+END_SRC

*** Part 3
\begin{equation}
\left( \sum_{i=1}^n -2 \frac{(\textbf{w}_i^T \textbf{g})^2}{(h_i + \lambda)^3} \right)^2 \right]
\end{equation}
#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
  do i = 1, n
    if (e_val(i)>1d-6) then
      wtg = 0d0
      do j = 1, n
        wtg = wtg + w(j,i) * v_grad(j)
      enddo
      !wtg = ddot(n,w(:,i),1,v_grad,1)
      accu3 = accu3 -2d0* wtg**2 / (e_val(i) + lambda)**3
    endif
  enddo
#+END_SRC

*** End 
#+BEGIN_SRC f90  :comments org :tangle org_trust_newton.irp.f
  d2_norm_trust_region = 2d0 * (accu1 * (- delta**2 + accu2) + accu3**2)

end function
#+END_SRC

* Function value of ||x||^2
Version without OMP

*Compute the value of ||x||^2*

This function compute the value of ||x(lambda)||^2

\begin{equation}
||\textbf{x}(\lambda)||^2 = \sum_{i=1}^n \frac{(\textbf{w}_i^T \textbf{g})^2}{(h_i + \lambda)^2}
\end{equation}

Provided:
| m_num | integer | number of MOs |

Input:
| n         | integer          | mo_num*(mo_num-1)/2         |
| e_val(n)  | double precision | eigenvalues of the hessian  |
| W(n,n)    | double precision | eigenvectors of the hessian |
| v_grad(n) | double precision | gradient                    |
| lambda    | double precision | Lagrange multiplier         |
| delta     | double precision | Delta of the trust region   |

Internal:
| wtg   | double precision | temporary variable to store W^T.v_grad |
| i,j   | integer          | indexes                                |

Function:
| f_norm_trust_region | double precision | value of norm(x)^2 |
| ddot                | double precision | blas dot product   |


#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
function f_norm_trust_region(n,e_val,w,v_grad,lambda)

  implicit none

  ! Variables

  ! in
  integer, intent(in) :: n
  double precision, intent(in) :: e_val(n)
  double precision, intent(in) :: w(n,n)
  double precision, intent(in) :: v_grad(n)
  double precision, intent(in) :: lambda

  ! function
  double precision :: f_norm_trust_region
  double precision :: ddot

  ! internal
  double precision :: wtg
  integer :: i,j
#+END_SRC

** Calculation
#+BEGIN_SRC f90 :comments org :tangle org_trust_newton.irp.f
  ! Initialization
  f_norm_trust_region = 0d0

  do i = 1, n
    if (e_val(i)>1d-6) then
      wtg = 0d0
      do j = 1, n
        wtg = wtg + w(j,i) * v_grad(j)
      enddo
      !wtg = ddot(n,w(:,i),1,v_grad,1)
      f_norm_trust_region = f_norm_trust_region + wtg**2 / (e_val(i) + lambda)**2
    endif
  enddo

end function
#+END_SRC
