* Rho

*Compute the ratio : rho = (prev_energy - energy) / (prev_energy - e_model)*

Rho represents the agreement between the model (predicted energy by
the Taylor expansion at the 2nd order) and the real energy :

\begin{equation}
\rho^{k+1} = \frac{E^{k} - E^{k+1}}{E^{k} - m^{k+1}}
\end{equation}
With :
$E^{k}$ the energy at the previous iteration
$E^{k+1}$ the energy at the actual iteration
$m^{k+1}$ the predicted energy for the actual iteration
(cf. trust_e_model)

If $\rho \approx 1$, the agreement is good, contrary to $\rho \approx
0$. If $\rho \leq 0$ the energy of the previous step is lower than the
actual step. We have to cancel this last step and use a smaller trust
region.

Provided:
| N_states                       | integer          | number of states     |
| ci_energy(N_states)            | double precision | CI energies          |
| state_average_weight(N_states) | double precision | weight of the states |

Input:
| prev_energy | double precision | previous energy (energy before the rotation) |
| e_model     | double precision | predicted energy after the rotation          |

Output:
| rho         | double precision | the agreement between the model and the real energy |
| prev_energy | double precision | if rho >= 0.1 the actual energy becomes the previous energy |
|             |                  | else hte previous energy doesn't change                     |

Internal:
| energy | double precision | energy (real)  after the rotation |
| i      | integer          | index                             |

#+BEGIN_SRC f90 :comments org :tangle org_rho_model.irp.f
subroutine org_rho_model(prev_energy,e_model,rho)

  include 'constants.h'

  implicit none
   
  ! Variables

  ! in
  double precision, intent(inout)  :: prev_energy
  double precision, intent(in)  :: e_model

  ! out
  double precision, intent(out) :: rho

  ! Internal
  double precision :: energy
  integer :: i
#+END_SRC

** State average energy
The state average energy $E$, is defined as :
\begin{equation}
E = \sum_i E_i w_i
\end{equation}
With :
$E_i$ energy of state i
$w_i$ weight of state i

#+BEGIN_SRC f90 :comments org :tangle org_rho_model.irp.f
  !if (debug) then
    print*,''
    print*,'---Enter in rho_model---'
  !endif

  ! Energy of the actual step
  !energy = sum(ci_energy(1:N_states) / dble(N_states))

  energy = 0d0
  do i = 1, N_states
    energy = energy + ci_energy(i) * state_average_weight(i)
  enddo
  energy = energy / DBLE(N_states)

  print*, 'ci_energy :', energy
#+END_SRC

** Rho
\begin{equation}
\rho^{k+1} = \frac{E^{k} - E^{k+1}}{E^{k} - m^{k+1}}
\end{equation}

In function of $\rho$ th step can be accepted or cancelled.

If we cancel the last step (k+1), the previous energy (k) doesn't
change !
If the step (k+1) is accepted, then the "previous energy" becomes E(k+1) 

#+BEGIN_SRC f90 :comments org :tangle org_rho_model.irp.f
  rho = (prev_energy - energy) / (prev_energy - e_model)

  print*, 'previous energy, prev_energy :', prev_energy
  print*, 'predicted energy, e_model :', e_model
  print*, 'real energy, energy :', energy
  print*, 'prev_energy - energy :', prev_energy - energy
  print*, 'e_model - energy :', prev_energy - e_model
  print*, 'Rho :', rho

  ! Modification of prev_energy in function of rho
  if (rho < 0.1) then
    ! the step is accepted  
    print*, 'Rho < 0.1, the previous energy does not change'
    print*, 'prev_energy :', prev_energy  
  else
    ! the step will is cancelled
    prev_energy = energy
    print*, 'Rho >= 0.1, energy -> prev_energy :', energy
  endif
#+END_SRC

** End 
#+BEGIN_SRC f90  :comments org :tangle org_rho_model.irp.f
  !if (debug) then
    print*,'---Leave rho_model---'
    print*,''
  !endif

end subroutine
#+END_SRC
