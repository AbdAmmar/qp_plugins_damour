* First pccd

First code: only debug purposes

cite Henderson 2014

i,j,k,l: occupied
a,b,c,d: virtual
p,q,r,s: general

pccd energy:
\begin{align*}
E= <0|H|0> + \sum_{ia} t_i^a v_{ii}^{aa}
\end{align*}

\begin{align*}
0 &= v_{ii}^{aa} + 2(fcc_a^a - fcc_i^i - \sum_{j} t_j^a v_{aa}^{jj}
- \sum_{b} t_i^b v_{bb}^{ii})t_i^a \\
&-2(2 v_{ia}^{ia} - v_{ai}^{ia} - v_{aa}^{ii} t_i^a) t_i^a \\
&+ \sum_{b} t_i^b v_{bb}^{aa} +  \sum_{j} t_j^a v_{ii}^{jj}
+ \sum_{jb} v_{bb}^{jj} t_j^a t_i^b
\end{align*}
with $fcc_q^p$ an element of the Fock operator and $v_{rs}^{pq}$ is a
bi-electronic integral.

#+BEGIN_SRC f90 :comments org :tangle first_pccd.irp.f
program first_pccd
  
  implicit none

  BEGIN_DOC
  ! First pCCD to debug purposes only
  END_DOC
  
  call run_first_pccd
  
end program
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle first_pccd.irp.f
subroutine run_first_pccd
  
  implicit none

  BEGIN_DOC
  ! First pCCD to debug purposes only
  END_DOC

  double precision, allocatable :: t2(:,:), r2(:,:)
  integer                       :: nO, nV
  integer                       :: i,j,a,b,tmp_a,tmp_b
  integer                       :: nb_iter
  double precision              :: energy, max_r2, ta, tb, CC
  double precision              :: get_two_e_integral
  double precision              :: accu1, accu2, accu3, accu4, accu5
  logical                       :: not_converged

  PROVIDE mo_two_e_integrals_in_map

  if (n_core_orb > 0) then
     print*,'No core orb with this prog, abort'
     call abort
  endif
  
  call wall_time(ta)
  nO = elec_alpha_num
  nV = mo_num - nO

  allocate(t2(nO,nV), r2(nO,nV))

  t2 = 0d0

  call pccd_energy(nO,nV,t2,energy)
  print*,'HF energy', energy

  ! Guess for t2
  do a = 1, nV
    tmp_a = a + nO
    do i = 1, nO
      t2(i,a) = get_two_e_integral(i,i,tmp_a,tmp_a,mo_integrals_map) &
     /(2d0*fock_matrix_mo(tmp_a,tmp_a) -2d0*fock_matrix_mo(i,i))
      ! print*,i,a,t2(i,a)
    enddo
  enddo

  nb_iter = 0
  not_converged = .True.
  do while (not_converged)

    ! Residue
    r2 = 0d0

    do a = 1, nV
    tmp_a = a + nO
      do i = 1, nO
        accu1 = 0d0
        do j = 1, nO
          accu1 = accu1 + t2(j,a) * get_two_e_integral(tmp_a,tmp_a,j,j,mo_integrals_map)
        enddo
        
        accu2 = 0d0
        do b = 1, nV
          tmp_b = b + nO
          accu2 = accu2 + t2(i,b) * get_two_e_integral(tmp_b,tmp_b,i,i,mo_integrals_map)
        enddo
  
        accu3 = 0d0
        do b = 1, nV
          tmp_b = b + nO
          accu3 = accu3 + t2(i,b) * get_two_e_integral(tmp_b,tmp_b,tmp_a,tmp_a,mo_integrals_map)
        enddo
  
        accu4 = 0d0
        do j = 1, nO
          accu4 = accu4 + t2(j,a) * get_two_e_integral(i,i,j,j,mo_integrals_map)
        enddo
       
        accu5 = 0d0
        do j = 1, nO
          do b = 1, nV
            tmp_b = b + nO
            accu5 = accu5 + t2(j,a) * t2(i,b) * get_two_e_integral(tmp_b,tmp_b,j,j,mo_integrals_map)
          enddo
        enddo
  
        r2(i,a) = get_two_e_integral(i,i,tmp_a,tmp_a,mo_integrals_map) &
          + 2d0 *(fock_matrix_mo(tmp_a,tmp_a) - fock_matrix_mo(i,i) - accu1 - accu2) * t2(i,a) &
          - 2d0*(2d0 * get_two_e_integral(i,tmp_a,i,tmp_a,mo_integrals_map) &
                 - get_two_e_integral(tmp_a,i,i,tmp_a,mo_integrals_map) &
                 - get_two_e_integral(tmp_a,tmp_a,i,i,mo_integrals_map) * t2(i,a)) * t2(i,a) &
          + accu3 + accu4 + accu5
        !print*,'r',i,a,r2(i,a)
      enddo
    enddo
    
    ! New amplitudes
    do a = 1, nV
      tmp_a = a + nO
      do i = 1, nO
        t2(i,a) = t2(i,a) - r2(i,a)/(2d0 * fock_matrix_mo(tmp_a,tmp_a) - 2d0 * fock_matrix_mo(i,i))
      enddo
    enddo
   
    nb_iter = nb_iter + 1

    call pccd_energy(nO,nV,t2,energy)

    ! max element in rest
    max_r2 = 0d0
    do a = 1, nV
      do i = 1, nO
        if (dabs(r2(i,a)) > max_r2) then
          max_r2 = dabs(r2(i,a))
        endif
      enddo
    enddo
    
    print*, nb_iter, energy, max_r2
    if (dabs(max_r2) < cc_thresh_conv .or. nb_iter > cc_max_iter ) then
       not_converged =  .False.
    endif

  enddo


  ! Final energy
  
  call pccd_energy(nO,nV,t2,energy)
  print*, energy

  deallocate(t2,r2)

  call wall_time(tb)
  print*,'Total time:', tb-ta
  
end
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle first_pccd.irp.f
subroutine pccd_energy(nO,nV,t2,energy)

  implicit none

  integer, intent(in)          :: nO, nV
  double precision, intent(in) :: t2(nO,nV)
  double precision             :: energy, get_two_e_integral
  integer                      :: i,a,tmp_a,tmp_b

  ! Final energy
  energy = 0d0
  do a = 1, nV
    tmp_a = a + nO
    do i = 1, nO
      energy = energy + t2(i,a) * get_two_e_integral(tmp_a,tmp_a,i,i,mo_integrals_map)
    enddo
  enddo 
  
  ! Add <0|H|0>
  energy = energy + hf_energy

end
#+END_SRC
