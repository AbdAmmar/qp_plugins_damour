* pCCD

cite Henderson 2014

i,j,k,l: occupied
a,b,c,d: virtual
p,q,r,s: general

pCCD energy:
\begin{align*}
E= <0|H|0> + \sum_{ia} t_i^a v_{ii}^{aa}
\end{align*}

\begin{align*}
r_i^a &= v_{ii}^{aa} + 2(f_a^a - f_i^i - \sum_{j} t_j^a v_{aa}^{jj}
- \sum_{b} t_i^b v_{bb}^{ii})t_i^a \\
&-2(2 v_{ia}^{ia} - v_{ai}^{ia} - v_{aa}^{ii} t_i^a) t_i^a \\
&+ \sum_{b} t_i^b v_{bb}^{aa} +  \sum_{j} t_j^a v_{ii}^{jj}
+ \sum_{jb} v_{bb}^{jj} t_j^a t_i^b
\end{align*}
\begin{align*}
&= v_{ii}^{aa} + 2(f_a^a - f_i^i - U_{1_a} - U_{2_i}) t_i^a \\
&- 2(2v_{ia}^{ia} - v_{ai}^{ia} - v_{aa}^{ii} t_i^a) t_i^a \\
&+ U_{3_i}^a + U_{4_i}^a + U_{5_i}^a
\end{align*}

$$\sum_j t_j^a v_{aa}^{jj} = U_{1_a}$$
$$\sum_b t_i^b v_{bb}^{ii} = U_{2_i}$$
$$\sum_b t_i^b v_{bb}^{aa}=U_{3_i}^a$$
$$\sum_j t_j^a v_{ii}^{jj} = U_{4_i}^a$$
$$\sum_{b} v_{bb}^{jj} t_i^b = X_{i}^{j}$$
$$\sum_{jb} v_{bb}^{jj} t_j^a t_i^b=\sum_j X_i^j t_j^a = U_{5_i}^a$$
with $f_q^p$ an element of the Fock operator and $v_{rs}^{pq}$ is a
bi-electronic integral.

Guess for $t$
$$t_i^a = \frac{v_{ii}^{aa}}{(2f_a^a - 2f_i^i)}$$

Update:
$$t_i^a \leftarrow t_i^a - \frac{r_i^a}{2f_a^a - 2f_i^i}$$


** Ideas:
| a | b | c | d |
|   | e |   | f |
| g |   | h |   |
|   |   | i | j |
A.B = C
- vertically shifted matrix: A
- horizontally shifted matrix: B
=> conserves the sum for matrix products with smaller matrices since
the zero elements have the same place in both matrices (only if we
have the same number of non zero elements on each line...)
Left shift -> matrix product -> enforce zero with the decrompression
(m,k).(k,n) -> (m,k-x).(k-x,n)
O(mnk) -> O(nm(k-x))

SVD on shifted matrix before matrix-matrix product ?

Matrix multiplication:
C = A.B
$$c_{ij} = \sum_k a_{ik} b_{kj}$$
k multiplications
k-1 summations
(2k-1)mn flops

svd A O(mn^2) m >= n

(i,j,k,l) -> (ij,kl)
   11 12 13 14 21 22 23 24 31 32 33 34 41 42 43 44
1 1
1 2
1 3
1 4
2 1
2 2
2 3
2 4
3 1
3 2
3 3
3 4
4 1
4 2
4 3
4 4

** SVD
ref tomoko 2003
Consider a $m$ by $n$ matrix $\textbf{A}$ with $m \leq n$ s.t. $A_{ij} \in \mathbb{R}$
$\forall \quad i \in (1,...,m), \quad j \in (1,...,n)$
The SVD of this matrix is
$\textbf{A} = \textbf{U} \textbf{S} \textbf{V}^T$

with $\textbf{U}$ is a $m$ by $m$ matrix and $\textbf{V}^T$ is a $m$ by
$n$ matrix
Columns of $\texbf{U}$, $\left\{\textbf{u}_k\right\}_{k=1}^m$: left
singular vectors of size $m$
Rows of $\texbf{V}^T$, $\left\{\textbf{v}^T_k\right\}_{k=1}^m$: right
singular vectors of size $n$

Then
\begin{align*}
\textbf{A}=\sum_{k=1}^m \textbf{u}_k \textbf{s}_k \textbf{v}_k^T
\end{align*}
\begin{align*}
\textbf{A}^{(l)}=\sum_{k=1}^l \textbf{u}_k \textbf{s}_k \textbf{v}_k^T, \quad l \leq r
\end{align*}
Matrix of rank $p$: $p$ non-zero eigenvalues
$\textbf{A}^{(l)}$ is the closest matrix of rank $l$ to $\textbf{A}$
If the eigenvalues $\left\{s_k\right\}_{k=l+1}^m$ are small enought
$\textbf{A}^{(l)}$ is a good approximation of $\textbf{A}$



$T_2 = \frac{1}{2} \sum_{ia} t_{ii}^{aa} a^\dagger a^\dagger i i$

** Code
#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
program pCCD
  implicit none
  
  call run_pCCD_v2
  
end program
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine run_pCCD_v2
  implicit none

  double precision, allocatable :: t2(:,:), residue(:,:), fock_matrix_pp(:)
  double precision, allocatable :: fock_matrix_aa(:), fock_matrix_ii(:)
  double precision, allocatable :: U1(:), U2(:), U3(:,:), U4(:,:), U5(:,:), X(:,:)
  integer :: p,q,i,j,a,b,tmp_a,tmp_b
  integer :: nb_iter
  double precision :: energy, max_residue, ta, tb
  double precision :: accu1, accu2, accu3, accu4, accu5
  logical :: not_converged

  print*,''
  print*,'---run_pCCD_v2---'
  call wall_time(ta)
  
  allocate(t2(dim_list_act_orb, dim_list_virt_orb), residue(dim_list_act_orb, dim_list_virt_orb), fock_matrix_pp(dim_list_act_virt_orb))
  allocate(fock_matrix_ii(dim_list_act_orb), fock_matrix_aa(dim_list_virt_orb))
  allocate(U1(dim_list_virt_orb), U2(dim_list_act_orb), U3(dim_list_act_orb, dim_list_virt_orb))
  allocate(U4(dim_list_act_orb, dim_list_virt_orb), U5(dim_list_act_orb, dim_list_virt_orb), X(dim_list_act_orb, dim_list_act_orb))

  if (dim_list_act_orb == mo_num) then
     print*,'Set the mo classes before, abort'
     call abort
  endif

  ! Init 
  t2 = 0d0
  !print*,dim_list_act_orb,dim_list_virt_orb
  call pCCD_energy(t2, energy)
  print*,'HF energy', energy

  ! f_p^p, tmp matrix for the diagonal element of the fock matrix
  fock_matrix_pp = 0d0
  do p = 1, dim_list_act_virt_orb
    fock_matrix_pp(p) = fock_matrix_mo(p,p)
  enddo

  fock_matrix_ii= 0d0
  do i = 1, dim_list_act_orb
    fock_matrix_ii(i) = fock_matrix_mo(i,i)
  enddo

  fock_matrix_aa = 0d0
  do a = 1, dim_list_virt_orb
    tmp_a = a + dim_list_act_orb
    fock_matrix_aa(a) = fock_matrix_mo(tmp_a,tmp_a)
  enddo

  ! Guess for t2 = t_i^a / (2f_a^a - 2f_i^i)
  !print*,dim_list_act_orb, dim_list_virt_orb
  !do a = 1, dim_list_virt_orb
  !  tmp_a = a + dim_list_act_orb
  !  do i = 1, dim_list_act_orb
  !    t2(i,a) = two_e_ints_ppqq(i,tmp_a) &
  !      /(2d0 * fock_matrix_pp(tmp_a) - 2d0 * fock_matrix_pp(i))
  !    !print*,i,a,t2(i,a)
  !  enddo
  !enddo

  call guess_amplitudes_pccd(fock_matrix_aa, fock_matrix_ii, t2)

  print*,''
  print*,'     Nb iter        Energy                  Residue'

  nb_iter = 0
  not_converged = .True.
  
  do while (not_converged)
     
    ! tmp arrays
    call U1_pccd(t2, U1)
    call U2_pccd(t2, U2)
    call U3_pccd(t2, U3)
    call U4_pccd(t2, U4)
    call X_pccd(t2,X)
    call U5_pccd(t2, X, U5)
    
    ! Residue
    residue = 0d0

    do a = 1, dim_list_virt_orb
      do i = 1, dim_list_act_orb
         residue(i,a) = two_e_ints_iiaa(i,a) + 2d0*(fock_matrix_aa(a) - fock_matrix_ii(i) - U1(a) - U2(i)) * t2(i,a) &
              - 2d0*(2d0 * two_e_ints_iaia(i,a) - two_e_ints_aiia(a,i) - two_e_ints_aaii(a,i) * t2(i,a)) * t2(i,a) &
              + U3(i,a) + U4(i,a) + U5(i,a)
         !print*,'r',i,a,residue(i,a)
      enddo
    enddo
    
    !do a = 1, dim_list_virt_orb
    !tmp_a = a + dim_list_act_orb
    !  do i = 1, dim_list_act_orb
    !     
    !    ! U1(a) = \sum_j t_j^a v_{aa}^{jj}
    !    accu1 = 0d0
    !    do j = 1, dim_list_act_orb
    !      accu1 = accu1 + t2(j,a) * two_e_ints_ppqq(tmp_a,j)
    !    enddo

    !    ! U2(i) = \sum_b t_i^b v_{bb}^{ii} 
    !    accu2 = 0d0
    !    do b = 1, dim_list_virt_orb
    !      tmp_b = b + dim_list_act_orb
    !      accu2 = accu2 + t2(i,b) * two_e_ints_ppqq(tmp_b,i)
    !    enddo

    !    ! U3(i,a) = \sum_b t_i^b v_{bb}^{aa}
    !    accu3 = 0d0
    !    do b = 1, dim_list_virt_orb
    !      tmp_b = b + dim_list_act_orb
    !      accu3 = accu3 + t2(i,b) * two_e_ints_ppqq(tmp_b,tmp_a)
    !    enddo

    !    ! U4(i,a) = \sum_j t_j^a v_{ii}^{jj}
    !    accu4 = 0d0
    !    do j = 1, dim_list_act_orb
    !      accu4 = accu4 + t2(j,a) * two_e_ints_ppqq(i,j)
    !    enddo

    !    ! U5(i,a) = \sum_{jb} t_j^a t_i^b v_{bb}^{jj} 
    !    accu5 = 0d0
    !    do j = 1, dim_list_act_orb
    !      do b = 1, dim_list_virt_orb
    !        tmp_b = b + dim_list_act_orb
    !        accu5 = accu5 + t2(j,a) * t2(i,b) * two_e_ints_ppqq(tmp_b,j)
    !      enddo
    !    enddo
  
    !    residue(i,a) = two_e_ints_ppqq(i,tmp_a) &
    !      + 2d0 *(fock_matrix_pp(tmp_a) - fock_matrix_pp(i) - accu1 - accu2) * t2(i,a) &
    !      - 2d0*(2d0 * two_e_ints(i,tmp_a,i,tmp_a) &
    !             - two_e_ints(tmp_a,i,i,tmp_a) &
    !             - two_e_ints(tmp_a,tmp_a,i,i) * t2(i,a)) * t2(i,a) &
    !      + accu3 + accu4 + accu5

    !    !print*,'r',i,a,residue(i,a)
    !    
    !  enddo
    !enddo
    
    !! New amplitudes
    !do a = 1, dim_list_virt_orb
    !  tmp_a = a + dim_list_act_orb
    !  do i = 1, dim_list_act_orb
    !    t2(i,a) = t2(i,a) - residue(i,a)/(2d0 * fock_matrix_pp(tmp_a) - 2d0 * fock_matrix_pp(i))
    !  enddo
    !enddo

    ! New amplitudes
    call update_amplitudes_pccd(fock_matrix_aa, fock_matrix_ii, residue, t2)
   
    nb_iter = nb_iter + 1

    ! New energy
    call pCCD_energy(t2,energy)

    ! max element in residue
    max_residue = 0d0
    do a = 1, dim_list_virt_orb
      do i = 1, dim_list_act_orb
        if (dabs(residue(i,a)) > max_residue) then
          max_residue = dabs(residue(i,a))
        endif
      enddo
    enddo
    
    print*, nb_iter, energy, max_residue

    ! Exit criterion
    if (max_residue < 1e-6) then
       not_converged = .False.
       print*,''
       print*,'******************************'
       print*,' E_pCCD:', energy
       print*,'******************************' 
    endif

    if (nb_iter >= 100) then
       print*,'#########################'
       print*,'   Convergence failed'
       print*,'#########################'
       exit
    endif

  enddo

  deallocate(t2,residue,X,U1,U2,U3,U4,U5,fock_matrix_aa,fock_matrix_ii,fock_matrix_pp)

  call wall_time(tb)
  print*,'Time in run_pCCD_v2:', tb-ta
  print*,''
  print*,'---End run_pCCD_v2---'
  print*,''
  
end
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine pCCD_energy(t2,energy)

  implicit none

  double precision, intent(in) :: t2(dim_list_act_orb, dim_list_virt_orb)
  double precision :: energy
  integer :: i,a,tmp_a,tmp_b

  ! Final energy
  energy = 0d0
  do a = 1, dim_list_virt_orb
    tmp_a = a + dim_list_act_orb
    do i = 1, dim_list_act_orb
      energy = energy + t2(i,a) * two_e_ints_ppqq(tmp_a,i)
    enddo
  enddo 
  
  ! Add <0|H|0>
  energy = energy + hf_energy

end
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine guess_amplitudes_pccd(fock_matrix_aa, fock_matrix_ii, t2)
  
  implicit none

  double precision, intent(in) :: fock_matrix_aa(dim_list_virt_orb), fock_matrix_ii(dim_list_act_orb)
  double precision, intent(out) :: t2(dim_list_act_orb, dim_list_virt_orb)
  integer :: i, a

  ! Guess for t2 = t_i^a / (2f_a^a - 2f_i^i)
  do a = 1, dim_list_virt_orb
    do i = 1, dim_list_act_orb
      t2(i,a) = two_e_ints_iiaa(i,a) &
        /(2d0 * fock_matrix_aa(a) - 2d0 * fock_matrix_ii(i))
      !print*,i,a,t2(i,a)
    enddo
  enddo

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine update_amplitudes_pccd(fock_matrix_aa, fock_matrix_ii, residue, t2)
  
  implicit none

  double precision, intent(in) :: fock_matrix_aa(dim_list_virt_orb), fock_matrix_ii(dim_list_act_orb)
  double precision, intent(in) :: residue(dim_list_act_orb, dim_list_virt_orb) 
  double precision, intent(out) :: t2(dim_list_act_orb, dim_list_virt_orb)
  integer :: i, a
  
  ! New amplitudes
  do a = 1, dim_list_virt_orb
    do i = 1, dim_list_act_orb
      t2(i,a) = t2(i,a) - residue(i,a)/(2d0 * fock_matrix_aa(a) - 2d0 * fock_matrix_ii(i))
    enddo
  enddo

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine residue_pccd(fock_matrix_aa, fock_matrix_ii, t2, U1, U2, U3, U4, U5, residue)
  
  implicit none

  double precision, intent(in)  :: fock_matrix_aa(dim_list_virt_orb), fock_matrix_ii(dim_list_act_orb)
  double precision, intent(in)  :: U1(dim_list_virt_orb), U2(dim_list_act_orb)
  double precision, intent(in)  :: U3(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(in)  :: U4(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(in)  :: U5(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(out) :: residue(dim_list_act_orb, dim_list_virt_orb)
  integer                       :: i,a

  do a = 1, dim_list_virt_orb
     do i = 1, dim_list_act_orb
        residue(i,a) = two_e_ints_iiaa(i,a) &
          + 2d0 *(fock_matrix_aa(a) - fock_matrix_ii(i) - U1(a) - U2(i)) * t2(i,a) &
          - 2d0*(2d0 * two_e_ints_iaia(i,a) &
          - two_e_ints_aiia(a,i) &
          - two_e_ints_aaii(a,i) * t2(i,a)) * t2(i,a) &
          + U3(i,a) + U4(i,a) + U5(i,a)
     enddo
   enddo
  
end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine U1_pccd(t2, U1)
  
  implicit none

  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(out) :: U1(dim_list_virt_orb)
  integer                       :: j,a

  ! U1(a) = \sum_j t_j^a v_{aa}^{jj}
  U1 = 0d0
  do a = 1, dim_list_virt_orb
    do j = 1, dim_list_act_orb
      U1(a) = U1(a) + t2(j,a) * two_e_ints_aaii(a,j)
    enddo
  enddo

  

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine U2_pccd(t2, U2)
  
  implicit none

  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(out) :: U2(dim_list_act_orb)
  integer                       :: i,b

  ! U2(i) = \sum_b t_i^b v_{bb}^{ii} 
  U2 = 0d0
  do i = 1, dim_list_act_orb
    do b = 1, dim_list_virt_orb
      U2(i) = U2(i) + t2(i,b) * two_e_ints_aaii(b,i)
    enddo
  enddo

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine U3_pccd(t2, U3)
  
  implicit none

  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(out) :: U3(dim_list_act_orb, dim_list_virt_orb)
  integer                       :: i,a,b

  ! U3(i,a) = \sum_b t_i^b v_{bb}^{aa}
  U3 = 0d0
  do a = 1, dim_list_virt_orb
    do i = 1, dim_list_act_orb
      do b = 1, dim_list_virt_orb
         U3(i,a) = U3(i,a) + t2(i,b) * two_e_ints_aabb(b,a)
      enddo
    enddo
  enddo

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine U4_pccd(t2, U4)
  
  implicit none
  
  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(out) :: U4(dim_list_act_orb, dim_list_virt_orb)
  integer                       :: i,j,a

  ! U4(i,a) = \sum_j t_j^a v_{ii}^{jj}
  !         = \sum_j v_{ii}^{jj} t_j^a
  
  !U4 = 0d0
  !do a = 1, dim_list_virt_orb
  !  do i = 1, dim_list_act_orb
  !    do j = 1, dim_list_act_orb
  !      U4(i,a) = U4(i,a) + t2(j,a) * two_e_ints_iijj(i,j)
  !    enddo
  !  enddo
  !enddo

  call dgemm('N','N', dim_list_act_orb, dim_list_virt_orb, dim_list_act_orb, &
             1d0, two_e_ints_iijj, size(two_e_ints_iijj, 1), &
                  t2, size(t2,1), &
             0d0, U4, size(U4,1))
  
end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine U5_pccd(t2, X, U5)
  
  implicit none

  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(in)  :: X(dim_list_act_orb, dim_list_act_orb)
  double precision, intent(out) :: U5(dim_list_act_orb, dim_list_virt_orb)
  integer                       :: i,j,a

  ! U5(i,a) = \sum_{jb} t_j^a t_i^b v_{bb}^{jj}
  !         = \sum_j X(i,j) t_j^a
  !U5 = 0d0
  !do a = 1, dim_list_virt_orb
  !  do i = 1, dim_list_act_orb
  !    do j = 1, dim_list_act_orb
  !      U5(i,a) = U5(i,a) + t2(j,a) * X(i,j)
  !    enddo
  !  enddo
  !enddo

  call dgemm('N','N', dim_list_act_orb, dim_list_virt_orb, dim_list_act_orb, &
             1d0, X, size(X,1), t2, size(t2,1), 0d0, U5, size(U5,1))

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine X_pccd(t2,X)
  
  implicit none

  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(out)  :: X(dim_list_act_orb, dim_list_act_orb)
  integer                       :: i,j,b

  ! X(i,j) = \sum_b t_i^b v_{bb}^{jj}
  X = 0d0
  do b = 1, dim_list_virt_orb
    do i = 1, dim_list_act_orb
      do j = 1, dim_list_act_orb
        X(i,j) = X(i,j) + t2(i,b) * two_e_ints_aaii(b,j)
      enddo
    enddo
  enddo  

end  
#+END_SRC

