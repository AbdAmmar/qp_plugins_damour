* pCCD

cite Henderson 2014

i,j,k,l: occupied
a,b,c,d: virtual
p,q,r,s: general

pCCD energy:
\begin{align*}
E= <0|H|0> + \sum_{ia} t_i^a v_{ii}^{aa}
\end{align*}

\begin{align*}
r_i^a &= v_{ii}^{aa} + 2(f_a^a - f_i^i - \sum_{j} t_j^a v_{aa}^{jj}
- \sum_{b} t_i^b v_{bb}^{ii})t_i^a \\
&-2(2 v_{ia}^{ia} - v_{ai}^{ia} - v_{aa}^{ii} t_i^a) t_i^a \\
&+ \sum_{b} t_i^b v_{bb}^{aa} +  \sum_{j} t_j^a v_{ii}^{jj}
+ \sum_{jb} v_{bb}^{jj} t_j^a t_i^b
\end{align*}
\begin{align*}
&= v_{ii}^{aa} + 2(f_a^a - f_i^i - U_{1_a} - U_{2_i}) t_i^a \\
&- 2(2v_{ia}^{ia} - v_{ai}^{ia} - v_{aa}^{ii} t_i^a) t_i^a \\
&+ U_{3_i}^a + U_{4_i}^a + U_{5_i}^a
\end{align*}

$$\sum_j t_j^a v_{aa}^{jj} = U_{1_a}$$
$$\sum_b t_i^b v_{bb}^{ii} = U_{2_i}$$
$$\sum_b t_i^b v_{bb}^{aa}=U_{3_i}^a$$
$$\sum_j t_j^a v_{ii}^{jj} = U_{4_i}^a$$
$$\sum_{b} v_{bb}^{jj} t_i^b = X_{i}^{j}$$
$$\sum_{jb} v_{bb}^{jj} t_j^a t_i^b=\sum_j X_i^j t_j^a = U_{5_i}^a$$
with $f_q^p$ an element of the Fock operator and $v_{rs}^{pq}$ is a
bi-electronic integral.

Guess for $t$
$$t_i^a = \frac{v_{ii}^{aa}}{(2f_a^a - 2f_i^i)}$$

Update:
$$t_i^a \leftarrow t_i^a - \frac{r_i^a}{2f_a^a - 2f_i^i}$$
** S-pCCD
*** Naive way
  - criterion (<ii|aa> integrals, divided or not by the f elements) in
    a list (must be normalized in order to have to max value = 1)
  - sort the list
  - cut with respect to the threshold
  - compute the indexes vec -> mat for the back transformation
  - store the indexes in a n (depends of the threshold) by 2 array
  - use the list to keep at zero the zero values after each operation

*** Sparse matrix
  - Same but use a sparse matrix for the t2
  - create a new sparse array with true non-zero elements after each
    operation 
    
** Bottleneck 

$$\sum_b t_i^b v_{bb}^{aa}=U_{3_i}^a \rightarrow OV^2 $$ 

** Prog
#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
program pCCD
  implicit none

  double precision :: energy
  call run_pCCD_v2(energy)
  print*,'#######################################################'
  double precision :: epsilon
  epsilon = 0d0
  call run_S1pCCD(epsilon, energy)
  
  !call run_S2pCCD(epsilon, energy)
  !epsilon = 1d-1
  !call run_S2pCCD(epsilon, energy)
  !epsilon = 5d-2
  !call run_S2pCCD(epsilon, energy)
  !epsilon = 1d-2
  !call run_S2pCCD(epsilon, energy)
  !epsilon = 1d-3
  !call run_S2pCCD(epsilon, energy)
  
  epsilon = 1d0
  do while (epsilon > 1d-8)
    call run_S1pCCD(epsilon, energy)
    epsilon = epsilon * 0.9d0
  enddo
  
end program
#+END_SRC

** first code
#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine run_pCCD_v2(energy)
  
  implicit none

  double precision, allocatable :: t2(:,:), residue(:,:)
  double precision, allocatable :: U1(:), U2(:), U3(:,:), U4(:,:), U5(:,:), X(:,:), t2_jacobian(:,:,:,:), inv_t2_jacobian(:,:,:,:)
  integer :: p,q,i,j,a,b,tmp_a,tmp_b
  integer :: nb_iter
  double precision :: max_residue, ta, tb !, energy
  double precision, intent(out) :: energy
  double precision :: accu1, accu2, accu3, accu4, accu5
  logical :: not_converged

  print*,''
  print*,'---run_pCCD_v2---'
  call wall_time(ta)
  
  allocate(t2(dim_list_act_orb, dim_list_virt_orb), residue(dim_list_act_orb, dim_list_virt_orb))!, fock_matrix_pp(dim_list_act_virt_orb))
!  allocate(fock_matrix_ii(dim_list_act_orb), fock_matrix_aa(dim_list_virt_orb))
  allocate(U1(dim_list_virt_orb), U2(dim_list_act_orb), U3(dim_list_act_orb, dim_list_virt_orb))
  allocate(U4(dim_list_act_orb, dim_list_virt_orb), U5(dim_list_act_orb, dim_list_virt_orb), X(dim_list_act_orb, dim_list_act_orb))
  allocate(t2_jacobian(dim_list_act_orb, dim_list_virt_orb,dim_list_act_orb, dim_list_virt_orb))
  allocate(inv_t2_jacobian(dim_list_act_orb, dim_list_virt_orb,dim_list_act_orb, dim_list_virt_orb))
  
  if (dim_list_act_orb == mo_num) then
     print*,'Set the mo classes before, abort'
     call abort
  endif

  ! Init 
  t2 = 0d0
  
  !call pCCD_energy(t2, energy)
  print*,'HF energy', hf_energy

  call guess_amplitudes_pccd(t2)

  print*,''
  print*,'     Nb iter        Energy                  Residue'

  nb_iter = 0
  not_converged = .True.
  
  do while (not_converged)
     
    ! tmp arrays
    call U1_pccd(t2, U1)
    call U2_pccd(t2, U2)
    call U3_pccd(t2, U3)
    call U4_pccd(t2, U4)
    call X_pccd(t2,X)
    call U5_pccd(t2, X, U5)
    
    ! Residue
    residue = 0d0

    do a = 1, dim_list_virt_orb
      do i = 1, dim_list_act_orb
         residue(i,a) = two_e_ints_iiaa(i,a) + 2d0*(fock_matrix_aa(a) - fock_matrix_ii(i) - U1(a) - U2(i)) * t2(i,a) &
              - 2d0*(2d0 * two_e_ints_iaia(i,a) - two_e_ints_aiia(a,i) - two_e_ints_aaii(a,i) * t2(i,a)) * t2(i,a) &
              + U3(i,a) + U4(i,a) + U5(i,a)
      enddo
    enddo
    
    ! New amplitudes
    !call update_amplitudes_pccd(residue, t2)
    call pccd_jacobian(t2, t2_jacobian)
    call inverse_jacobian(t2_jacobian, inv_t2_jacobian)
    call update_amplitudes_pccd_w_J(residue, inv_t2_jacobian, t2)
   
    nb_iter = nb_iter + 1

    ! New energy
    call pCCD_energy(t2,energy)

    ! max element in residue
    max_residue = 0d0
    do a = 1, dim_list_virt_orb
      do i = 1, dim_list_act_orb
        if (dabs(residue(i,a)) > max_residue) then
          max_residue = dabs(residue(i,a))
        endif
      enddo
    enddo
    
    print*, nb_iter, energy, max_residue

    ! Exit criterion
    if (max_residue < 1e-6) then
       not_converged = .False.
       print*,''
       print*,'******************************'
       print*,' E_pCCD:', energy
       print*,'******************************' 
    endif

    if (nb_iter >= 100) then
       print*,'#########################'
       print*,'   Convergence failed'
       print*,'#########################'
       exit
    endif

  enddo

  deallocate(t2,residue,X,U1,U2,U3,U4,U5,t2_jacobian,inv_t2_jacobian)

  call wall_time(tb)
  print*,'Time in run_pCCD_v2:', tb-ta
  print*,''
  print*,'---End run_pCCD_v2---'
  print*,''
  
end
#+END_SRC

** Routines
#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine pCCD_energy(t2,energy)

  implicit none

  ! in
  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)

  ! out
  double precision, intent(out) :: energy

  ! internal
  integer                       :: i,a
  integer                       :: nO, nV

  nO = dim_list_act_orb
  nV = dim_list_virt_orb

  ! Final energy
  energy = 0d0
  do a = 1, nV
    do i = 1, nO
      energy = energy + t2(i,a) * two_e_ints_aaii(a,i)
    enddo
  enddo 
  
  ! Add <0|H|0>
  energy = energy + hf_energy

end
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine guess_amplitudes_pccd(t2)
  
  implicit none

  ! out
  double precision, intent(out) :: t2(dim_list_act_orb, dim_list_virt_orb)

  ! internal
  integer                       :: i, a
  integer                       :: nO, nV

  nO = dim_list_act_orb
  nV = dim_list_virt_orb

  ! Guess for t2 = t_i^a / (2f_a^a - 2f_i^i)
  do a = 1, nV
    do i = 1, nO
      t2(i,a) = - two_e_ints_iiaa(i,a) &
        /(2d0 * fock_matrix_aa(a) - 2d0 * fock_matrix_ii(i))
      !print*,i,a,t2(i,a)
    enddo
  enddo

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine update_amplitudes_pccd(residue, t2)
  
  implicit none

  ! in
  double precision, intent(in)  :: residue(dim_list_act_orb, dim_list_virt_orb)

  ! out
  double precision, intent(out) :: t2(dim_list_act_orb, dim_list_virt_orb)

  ! internal
  integer                       :: i, a
  integer                       :: nO, nV

  nO = dim_list_act_orb
  nV = dim_list_virt_orb
  
  ! New amplitudes
  do a = 1, nV
    do i = 1, nO
      t2(i,a) = t2(i,a) - residue(i,a)/(2d0 * fock_matrix_aa(a) - 2d0 * fock_matrix_ii(i))
    enddo
  enddo

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine update_amplitudes_pccd_w_J(residue, inv_t2_jacobian, t2)
  
  implicit none

  ! in
  double precision, intent(in)  :: residue(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(in)  :: inv_t2_jacobian(dim_list_act_orb, dim_list_virt_orb,dim_list_act_orb, dim_list_virt_orb)

  ! out
  double precision, intent(out) :: t2(dim_list_act_orb, dim_list_virt_orb)

  ! internal
  integer                       :: i,a,j,b
  integer                       :: nO, nV

  nO = dim_list_act_orb
  nV = dim_list_virt_orb
  
  ! New amplitudes
  do b = 1, nV
    do j = 1, nO
      do a = 1, nV
        do i = 1, nO
          t2(i,a) = t2(i,a) - inv_t2_jacobian(i,a,j,b) * residue(j,b)
        enddo
      enddo
    enddo
  enddo

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine residue_pccd(t2, U1, U2, U3, U4, U5, residue)
  
  implicit none

  ! in
  double precision, intent(in)  :: U1(dim_list_virt_orb), U2(dim_list_act_orb)
  double precision, intent(in)  :: U3(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(in)  :: U4(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(in)  :: U5(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)

  ! out
  double precision, intent(out) :: residue(dim_list_act_orb, dim_list_virt_orb)

  ! internal
  integer                       :: i,a
  integer                       :: nO, nV

  nO = dim_list_act_orb
  nV = dim_list_virt_orb

  do a = 1, nV
     do i = 1, nO
        residue(i,a) = two_e_ints_iiaa(i,a) &
          + 2d0 *(fock_matrix_aa(a) - fock_matrix_ii(i) - U1(a) - U2(i)) * t2(i,a) &
          - 2d0*(2d0 * two_e_ints_iaia(i,a) &
          - two_e_ints_aiia(a,i) &
          - two_e_ints_aaii(a,i) * t2(i,a)) * t2(i,a) &
          + U3(i,a) + U4(i,a) + U5(i,a)
     enddo
   enddo
  
end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine U1_pccd(t2, U1)
  
  implicit none

  ! in
  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)

  ! out
  double precision, intent(out) :: U1(dim_list_virt_orb)

  ! internal
  integer                       :: j,a
  integer                       :: nO, nV

  nO = dim_list_act_orb
  nV = dim_list_virt_orb
  
  ! U1(a) = \sum_j t_j^a v_{aa}^{jj}
  U1 = 0d0
  do a = 1, nV
    do j = 1, nO
      U1(a) = U1(a) + t2(j,a) * two_e_ints_aaii(a,j)
    enddo
  enddo

  

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine U2_pccd(t2, U2)
  
  implicit none

  ! in
  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)

  ! out
  double precision, intent(out) :: U2(dim_list_act_orb)

  ! internal
  integer                       :: i,b
  integer                       :: nO, nV

  nO = dim_list_act_orb
  nV = dim_list_virt_orb
  
  ! U2(i) = \sum_b t_i^b v_{bb}^{ii} 
  U2 = 0d0
  do i = 1, nO
    do b = 1, nV
      U2(i) = U2(i) + t2(i,b) * two_e_ints_aaii(b,i)
    enddo
  enddo

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine U3_pccd(t2, U3)
  
  implicit none

  ! in
  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)

  ! out
  double precision, intent(out) :: U3(dim_list_act_orb, dim_list_virt_orb)

  ! internal
  integer                       :: i,a,b
  integer                       :: nO, nV

  nO = dim_list_act_orb
  nV = dim_list_virt_orb

  ! U3(i,a) = \sum_b t_i^b v_{bb}^{aa}
  !U3 = 0d0
  !do a = 1, dim_list_virt_orb
  !  do i = 1, dim_list_act_orb
  !    do b = 1, dim_list_virt_orb
  !       U3(i,a) = U3(i,a) + t2(i,b) * two_e_ints_aabb(b,a)
  !    enddo
  !  enddo
  !enddo

  call dgemm('N','N', nO, nV, nV, &
             1d0, t2, size(t2,1), &
                  two_e_ints_aabb, size(two_e_ints_aabb,1), &
             0d0, U3, size(U3,1))
  
end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine U4_pccd(t2, U4)
  
  implicit none

  ! in
  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)

  ! out
  double precision, intent(out) :: U4(dim_list_act_orb, dim_list_virt_orb)

  ! internal
  integer                       :: i,j,a
  integer                       :: nO, nV

  nO = dim_list_act_orb
  nV = dim_list_virt_orb    

  ! U4(i,a) = \sum_j t_j^a v_{ii}^{jj}
  !         = \sum_j v_{ii}^{jj} t_j^a
  
  !U4 = 0d0
  !do a = 1, dim_list_virt_orb
  !  do i = 1, dim_list_act_orb
  !    do j = 1, dim_list_act_orb
  !      U4(i,a) = U4(i,a) + t2(j,a) * two_e_ints_iijj(i,j)
  !    enddo
  !  enddo
  !enddo

  call dgemm('N','N', nO, nV, nO, &
             1d0, two_e_ints_iijj, size(two_e_ints_iijj,1), &
                  t2, size(t2,1), &
             0d0, U4, size(U4,1))

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine U5_pccd(t2, X, U5)
  
  implicit none

  ! in
  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(in)  :: X(dim_list_act_orb, dim_list_act_orb)

  ! out
  double precision, intent(out) :: U5(dim_list_act_orb, dim_list_virt_orb)

  ! internal
  integer                       :: i,j,a
  integer                       :: nO, nV

  nO = dim_list_act_orb
  nV = dim_list_virt_orb    

  ! U5(i,a) = \sum_{jb} t_j^a t_i^b v_{bb}^{jj}
  !         = \sum_j X(i,j) t_j^a
  !U5 = 0d0
  !do a = 1, dim_list_virt_orb
  !  do i = 1, dim_list_act_orb
  !    do j = 1, dim_list_act_orb
  !      U5(i,a) = U5(i,a) + t2(j,a) * X(i,j)
  !    enddo
  !  enddo
  !enddo

  call dgemm('N','N', nO, nV, nO, &
             1d0, X, size(X,1), t2, size(t2,1), 0d0, U5, size(U5,1))

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine X_pccd(t2,X)
  
  implicit none

  ! in
  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)

  ! out
  double precision, intent(out)  :: X(dim_list_act_orb, dim_list_act_orb)

  ! internal
  integer                       :: i,j,b
  integer                       :: nO, nV

  nO = dim_list_act_orb
  nV = dim_list_virt_orb    

  ! X(i,j) = \sum_b t_i^b v_{bb}^{jj}
  !X = 0d0
  !do i = 1, dim_list_act_orb
  !  do j = 1, dim_list_act_orb
  !    do b = 1, dim_list_virt_orb
  !      X(i,j) = X(i,j) + t2(i,b) * two_e_ints_aaii(b,j)
  !    enddo
  !  enddo
  !enddo

  call dgemm('N','N', nO, nO, nV, &
             1d0, t2, size(t2,1), two_e_ints_aaii, size(two_e_ints_aaii,1), &
             0d0, X, size(X,1))

end  
#+END_SRC

** Jacobian

Full jacobian:
\begin{align*}
J_{ia,jb} &= [ 2(f_a^a - f_i^i) - 4 v_{ia}^{ia} + 2v_{ia}^{ai}] \delta_{ij} \delta_{ab} \\
&+ [ v_{aa}^{bb} - v_{jj}^{aa} t_i^a + (1 - 2 \delta_{ab}) \sum_{k \neq i} v_{kk}^{bb} t_k^a ] \delta_{ij} \\
&+ [ v_{ii}^{jj} - v_{ii}^{bb} t_i^a + (1 - 2 \delta_{ij}) \sum_{c \neq a} v_{jj}^{cc} t_i^c ] \delta_{ab} \\
&= [ 2(f_a^a - f_i^i) - 4 v_{ia}^{ia} + 2v_{ia}^{ai}] \delta_{ij} \delta_{ab} \\
&+ [ v_{aa}^{bb} - v_{ii}^{aa} t_i^a + (1 - 2 \delta_{ab}) \sum_{k \neq i} v_{kk}^{bb} t_k^a ] \delta_{ij} \\
&+ [ v_{ii}^{jj} - v_{ii}^{aa} t_i^a + (1 - 2 \delta_{ij}) \sum_{c \neq a} v_{jj}^{cc} t_i^c ] \delta_{ab}
\end{align*}

Update of the amplitudes:
$$ t_i^a \leftarrow t_i^a - \sum_{jb} (J^{-1})_{ia,jb} r_j^b$$

Diagonal:
\begin{align*}
J_{ia,ia} &= [ 2(f_a^a - f_i^i) - 4 v_{ia}^{ai} + 2v_{ia}^{ai}]  \\
&+ [ v_{aa}^{aa} - v_{ii}^{aa} t_i^a + (1 - 2) \sum_{k \neq i} v_{kk}^{aa} t_k^a ] \\
&+ [ v_{ii}^{ii} - v_{ii}^{aa} t_i^a + (1 - 2) \sum_{c \neq a} v_{ii}^{cc} t_i^c ] \\
&= [ 2(f_a^a - f_i^i) - 4 v_{ia}^{ai} + 2v_{ia}^{ai}]  \\
&+ [ v_{aa}^{aa} - \sum_{k} v_{kk}^{aa} t_k^a ] \\
&+ [ v_{ii}^{ii} - \sum_{c} v_{ii}^{cc} t_i^c ]
\end{align*}

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine pccd_jacobian_v2(t2, t2_jacobian)

  implicit none

  ! in
  double precision,intent(in)   :: t2(dim_list_act_orb, dim_list_virt_orb)

  ! out
  double precision,intent(out)  :: t2_jacobian(dim_list_act_orb, dim_list_virt_orb, dim_list_act_orb, dim_list_virt_orb)

  ! internal
  integer                       :: i,j,k,l
  integer                       :: a,b,c,d
  integer                       :: nV, nO

  nO = dim_list_act_orb
  nV = dim_list_virt_orb

  t2_jacobian = 0d0
  
  ! [ 2(f_a^a - f_i^i) - 4 v_{ia}^{ia} + 2v_{ia}^{ai} ] \delta_{ij} \delta_{ab}
  do a = 1, nV
    do i = 1, nO
      t2_jacobian(i,a,i,a) = t2_jacobian(i,a,i,a) + 2d0 * (fock_matrix_aa(a) - fock_matrix_ii(i)) &
                  - 4d0 * two_e_ints_iaia(i,a) + 2d0 * two_e_ints_iaai(i,a)
    enddo
  enddo

  ! [ v_{aa}^{bb} - v_{ii}^{aa} t_i^a ]  \delta_{ij}
  do b = 1, nV
    do a = 1, nV
      do i = 1, nO
         t2_jacobian(i,a,i,b) = t2_jacobian(i,a,i,b) + two_e_ints_aabb(a,b) - two_e_ints_iiaa(i,b) * t2(i,a)
         !                                                                                      a
      enddo
    enddo
  enddo

 ! [ (1 - 2 \delta_{ab}) \sum_{k \neq i} v_{kk}^{bb} t_k^a with a = b ] \delta_{ij}
 do a = 1, nV
   do i = 1, nO
     do k = 1, nO
       if (k /= i) then
         t2_jacobian(i,a,i,a) = t2_jacobian(i,a,i,a) - two_e_ints_iiaa(k,a) * t2(k,a)
       endif
     enddo
   enddo
 enddo

  ! [ (1 - 2 \delta_{ab}) \sum_{k \neq i} v_{kk}^{bb} t_k^a with a /= b ] \delta_{ij}
  do b = 1, nV
    do a = 1, nV
      do i = 1, nO
        do k = 1, nO
          if (k /= i .and. a /= b ) then
            t2_jacobian(i,a,i,b) = t2_jacobian(i,a,i,b) + two_e_ints_iiaa(k,b) * t2(k,a)
          endif
        enddo
      enddo
    enddo
  enddo

  ! [ v_{ii}^{jj} - v_{ii}^{aa} t_i^a ] \delta_{ab}
  do a = 1, nV
    do j = 1, nO
      do i = 1, nO
        t2_jacobian(i,a,j,a) = t2_jacobian(i,a,j,a) + two_e_ints_iijj(i,j) - two_e_ints_iiaa(j,a) * t2(i,a)
        !                                                                                    i
      enddo
    enddo
  enddo
  
  ! [ (1 - 2 \delta_{ij}) \sum_{c \neq a} v_{jj}^{cc} t_i^c with i = j ] \delta_{ab}
  do a = 1, nV
    do i = 1, nO
      do c = 1, nV
        if (c /= a) then
          t2_jacobian(i,a,i,a) = t2_jacobian(i,a,i,a) - two_e_ints_iiaa(i,c) * t2(i,c)
        endif
      enddo
    enddo
  enddo

  ! [ (1 - 2 \delta_{ij}) \sum_{c \neq a} v_{jj}^{cc} t_i^c with i /= j ] \delta_{ab}
  do a = 1, nV
    do j = 1, nO
      do i = 1, nO
        do c = 1, nV
          if (c /= a .and. i /= j) then
            t2_jacobian(i,a,j,a) = t2_jacobian(i,a,j,a) + two_e_ints_iiaa(j,c) * t2(i,c)
          endif
        enddo
      enddo
    enddo
  enddo
  
end
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine pccd_jacobian(t2,t2_jacobian)

  implicit none

  ! in
  double precision,intent(in)   :: t2(dim_list_act_orb,dim_list_virt_orb)

  ! out
  double precision,intent(out)  :: t2_jacobian(dim_list_act_orb,dim_list_virt_orb,dim_list_act_orb,dim_list_virt_orb)

  ! internal
  integer                       :: i,j,k,l
  integer                       :: a,b,c,d
  double precision,allocatable  :: yO1(:)
  double precision,allocatable  :: yV1(:)
  double precision,allocatable  :: yO2(:,:)
  double precision,allocatable  :: yV2(:,:)
  integer                       :: nV, nO

  nO = dim_list_act_orb
  nV = dim_list_virt_orb
  
  t2_jacobian = 0d0

  ! \sum_a v_ii^aa t_i^a
  allocate( yO1(nO) )
  yO1 = 0d0
  do a = 1, nV
    do i = 1, nO
      yO1(i) = yO1(i) + two_e_ints_iiaa(i,a) * t2(i,a)
    !yO1(i) = sum( two_e_ints_iiaa(i,:) * t2(i,:) )
    enddo
  enddo
  !print*,'yo1', yO1(:)

  ! \sum_i v_ii^aa t_i^a
  allocate( yV1(nV) )
  yV1 = 0d0
  do a = 1, nV
    do i = 1, nO
      yV1(a) = yV1(a) + two_e_ints_iiaa(i,a) * t2(i,a)
    enddo
    !yV1(a) = sum( two_e_ints_iiaa(:,a) * t2(:,a) )
  enddo
  !print*,'yv1', yv1(:)

  ! \sum_b v_jj^bb * t_ii^bb
  allocate( yO2(nO, nO) )
  yO2 = 0d0
  do j = 1, nO
    do i = 1, nO
      do b = 1, nV
        yO2(i,j) = yO2(i,j) + two_e_ints_iiaa(j,b) * t2(i,b)
      enddo
    enddo
  enddo
  !print*,'yO2', yO2(:,:)

  ! \sum_i v_jj^bb t_j^a
  allocate( yV2(nV, nV) )
  yV2 = 0d0
  do b = 1, nV
    do a = 1, nV
      do j = 1, nO
        yV2(a,b) = yV2(a,b) + two_e_ints_iiaa(j,b) * t2(j,a)
      enddo
    enddo
  enddo
  !print*,'yV2', yV2(:,:)

  ! 2 (f_a^a - f_i^i) - 4 v_ia^ia + 2 v_ia^ai + v_aa^aa + v_ii^ii - \sum_k v_kk^aa t_k^a - \sum_c v_ii^cc t_i^c
  do a = 1, nV
    do i = 1, nO
      t2_jacobian(i,a,i,a) = 2d0*(fock_matrix_aa(a) - fock_matrix_ii(i)) &
      - 4.0d0*two_e_ints_iaia(i,a) + 2.0d0*two_e_ints_iaai(i,a) + two_e_ints_aabb(a,a) + two_e_ints_iijj(i,i) &
      - yV1(a) - yO1(i) 
    enddo
  enddo

  ! v_aa^bb - 2 v_ii^bb * t_i^a + \sum_k v_kk^bb t_k^a
  do b = 1, nV
    do a = 1, nV
    if( a.eq.b ) cycle
      do i = 1, nO
        t2_jacobian(i,a,i,b) = two_e_ints_aabb(a,b) - 2.0d0 * two_e_ints_iiaa(i,b) * t2(i,a) + yV2(a,b)
      enddo
    enddo
  enddo

  ! v_ii^jj - 2 v_jj^aa * t_i^a + \sum_c v_jj^cc * t_i^c
  do j = 1, nO
    do i = 1, nO
    if( i.eq.j ) cycle
      do a = 1, nV
        t2_jacobian(i,a,j,a) = two_e_ints_iijj(i,j) - 2.0d0 * two_e_ints_iiaa(j,a) * t2(i,a) + yO2(i,j)
      enddo
    enddo
  enddo

  deallocate(yO1,yO2,yV1,yV2)

end
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine inverse_jacobian(t2_jacobian, Jm1)

  implicit none
  
  ! in
  double precision, intent(in)  :: t2_jacobian(dim_list_act_orb,dim_list_virt_orb,dim_list_act_orb,dim_list_virt_orb)

  ! out
  double precision, intent(out) :: Jm1(dim_list_act_orb,dim_list_virt_orb,dim_list_act_orb,dim_list_virt_orb)

  ! internal
  double precision, allocatable :: e_val(:), W(:,:), e_val_2d(:,:), accu(:,:), Jm1_2d(:,:)
  double precision, allocatable :: work(:,:)
  integer                       :: info, lwork, i,j,k,l
  integer                       :: nV, nO

  nO = dim_list_act_orb
  nV = dim_list_virt_orb
  
  ! For Lapack
  lwork=3*(nO*nV)-1

  allocate(work(lwork,nO*nV), e_val(nO*nV), W(nO*nV,nO*nV))
  allocate(e_val_2d(nO*nV, nO*nV), accu(nO*nV, nO*nV), Jm1_2d(nO*nV, nO*nV))

  ! Calculation
  call convert_4d_to_2d(nO, nV, nO, nV, t2_jacobian, nO*nV, nO*nV, W)

  ! Debug
  !call get_inverse(W, nO*nV, nO*nV, Jm1_2d, nO*nV)
  !
  !print*,'2d'
  !do i = 1, nO*nV
  !  write(*,'(I2,100(1pE12.5))') i, Jm1_2d(i,:)
  !enddo

  ! Diagonalization of the hessian
  call dsyev('V','U', nO*nV, W, size(W,1), e_val, work, lwork, info)

  if (info /= 0) then
      print*, 'Error diagonalization : diagonalization_hessian'
      print*, 'info = ', info
      call ABORT
  endif

  do i = 1, nO*nV
    if (dabs(e_val(i)) >= 1d-6) then
      e_val(i) = 1d0/e_val(i)
    else
      e_val(i) = 0d0
    endif
  enddo
  
  e_val_2d = 0d0
  do i = 1, nO*nV
     e_val_2d(i,i) = e_val(i)
  enddo

  call dgemm('N','N',nO*nV, nO*nV, nO*nV, 1d0, W, size(W,1), e_val_2d, size(e_val_2d,1), 0d0, accu, size(accu,1))
  call dgemm('N','T',nO*nV, nO*nV, nO*nV, 1d0, accu, size(accu,1), W, size(W,1), 0d0, Jm1_2d, size(Jm1_2d,1))
  
! Debug
!  print*,'Jm1_2d'
!  do i = 1, dim_list_act_orb*dim_list_virt_orb
!    write(*,'(I2,100(1pE12.5))') i, Jm1_2d(i,:)
!  enddo

  call convert_2d_to_4d(nO*nV, nO*nV, Jm1_2d, nO, nV, nO, nV, Jm1)
  
  deallocate(work,e_val,W,e_val_2d,accu,Jm1_2d)
end
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine index_4d_to_2d(nj,nl,i,j,k,l,p,q)

  implicit none

  ! in
  integer, intent(in)  :: nj,nl,i,j,k,l

  ! out
  integer, intent(out) :: p,q

  ! (i,j,k,l) -> (p,q)
  ! p -> i j
  ! 1 -> 1 1
  ! 2 -> 1 2
  ! 3 -> 1 3
  ! ...
  ! ? -> 2 1
  ! ...
  ! Same for q with k and l
  
  p = (i-1) * nj + j
  q = (k-1) * nl + l

end
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine index_2d_to_4d(nj,nl,p,q,i,j,k,l)

  implicit none

  ! in
  integer, intent(in)  :: nj,nl,p,q

  ! out
  integer, intent(out) :: i,j,k,l

  ! (p,q) -> (i,j,k,l)
  ! (i,j,k,l) -> (p,q)
  ! p -> i j
  ! 1 -> 1 1
  ! 2 -> 1 2
  ! 3 -> 1 3
  ! ...
  ! ? -> 2 1
  ! ...
  ! Same for q with k and l

  i = (p-1)/nj + 1
  j = p - (i-1) * nj

  k = (q-1)/nl + 1
  l = q - (k-1) * nl

end
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine convert_2d_to_4d(dim1_A2, dim2_A2, A2, dim1_A4, dim2_A4, dim3_A4, dim4_A4, A4)

  implicit none

  ! in
  integer, intent(in)           :: dim1_A2, dim2_A2, dim1_A4, dim2_A4, dim3_A4, dim4_A4
  double precision, intent(in)  :: A2(dim1_A2, dim2_A2)
  
  ! out
  double precision, intent(out) :: A4(dim1_A4, dim2_A4, dim3_A4, dim4_A4)

  ! internal
  integer                       :: i,j,k,l,nj,nl,p,q

  nj = dim2_A4
  nl = dim4_A4
  
  do q = 1, dim2_A2
    do p = 1, dim1_A2
      call index_2d_to_4d(nj,nl, p,q, i,j,k,l)
      A4(i,j,k,l) = A2(p,q)
    enddo
  enddo

end
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine convert_4d_to_2d(dim1_A4, dim2_A4, dim3_A4, dim4_A4, A4,dim1_A2, dim2_A2, A2)

  implicit none

  ! in
  integer, intent(in)  :: dim1_A2, dim2_A2, dim1_A4, dim2_A4, dim3_A4, dim4_A4
  double precision, intent(in) :: A4(dim1_A4, dim2_A4, dim3_A4, dim4_A4)
  
  ! out
  double precision, intent(out)  :: A2(dim1_A2, dim2_A2)

  ! internal
  integer :: i,j,k,l,nj,nl,p,q

  nj = dim2_A4
  nl = dim4_A4

  do l = 1, dim4_A4
    do k = 1, dim3_A4
      do j = 1, dim2_A4
        do i = 1, dim1_A4
          call index_4d_to_2d(nj,nl,i,j,k,l,p,q)
          A2(p,q) = A4(i,j,k,l)
        enddo
      enddo
    enddo
  enddo
  
end
#+END_SRC

* Naive way
#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine run_S1pCCD(epsilon,real_e)

  implicit none

  double precision, intent(in) :: epsilon, real_e
  double precision, allocatable :: list_crit(:)
  integer, allocatable :: list_key(:)
  integer, allocatable :: list_2d_key(:,:)
  integer :: i,j,a,b,p,q,nb_t2

  double precision, allocatable :: t2(:,:), residue(:,:), tmp_residue(:,:)
  double precision, allocatable :: t2_jacobian(:,:,:,:), inv_t2_jacobian(:,:,:,:), t2_jacobian2(:,:,:,:)
  double precision, allocatable :: U1(:), U2(:), U3(:,:), U4(:,:), U5(:,:), X(:,:)
  integer :: nb_iter, nb_error
  double precision :: energy, max_residue, ta, tb, normalization_factor 
  logical :: not_converged
  integer :: nO, nV

  print*,''
  print*,'---run_S1pCCD_v2---'
  call wall_time(ta)

  nO = dim_list_act_orb
  nV = dim_list_virt_orb
  
  allocate(t2(nO, nV), residue(nO, nV), tmp_residue(nO, nV))
  allocate(U1(nV), U2(nO), U3(nO, dim_list_virt_orb))
  allocate(U4(nO, nV), U5(nO, nV), X(nO, nO))
  allocate(t2_jacobian(nO, nV, nO, nV))
  allocate(inv_t2_jacobian(nO, nV, nO, nV),t2_jacobian2(nO, nV, nO, nV))

  if (dim_list_act_orb == mo_num) then
     print*,'Set the mo classes before, abort'
     call abort
  endif

  allocate(list_crit(nO * nV), list_key(nO * nV))
  
  ! 2D -> 1D
  p = 1
  do a = 1, nV
    do i = 1, nO
       if (sccd_method == 'bi_int') then
         list_crit(p) = dabs(two_e_ints_iiaa(i,a))
       elseif (sccd_method == 'guess_mp2') then
         list_crit(p) = dabs(two_e_ints_iiaa(i,a)/(2d0 * fock_matrix_aa(a) - 2d0 * fock_matrix_ii(i)))
       elseif (sccd_method == 'estimated_e') then
         list_crit(p) = dabs(two_e_ints_iiaa(i,a)**2/(2d0 * fock_matrix_aa(a) - 2d0 * fock_matrix_ii(i)))
       else
          print*,'Select the selection method, abort'
          call abort
       endif
       list_key(p) = p
       p = p + 1
    enddo
  enddo
  ! -, to change the ordering after the sort
  list_crit = - list_crit

  ! Sort by ascending order
  call dsort(list_crit, list_key, nO * nV)
  
  ! Normalization of the biggest criterion
  normalization_factor = 1d0/list_crit(1) !(dim_list_act_orb * dim_list_virt_orb)

  ! Normalized and sorted list
  list_crit = list_crit * normalization_factor

  ! Number of selected elements
  !p = dim_list_act_orb * dim_list_virt_orb
  !do while ((list_crit(p) >= epsilon) .and. (p >= 1))
  !   p = p-1
  !enddo
  !nb_t2 = dim_list_act_orb * dim_list_virt_orb - p
  p = 1
  do while ((p <= nO * nV) .and. (list_crit(min(p, nO * nV)) >= epsilon))
    p = p + 1
  enddo
  nb_t2 = p - 1 

  ! Debug
  !do p = 1, dim_list_act_orb * dim_list_virt_orb
  !  print*, list_crit(p)
  !enddo
  !print*,'nb',nb_t2
  
  allocate(list_2d_key(nb_t2,2))

  ! Row indexes
  do p = 1, nb_t2
    !q = list_key(dim_list_act_orb * dim_list_virt_orb -p+1)
    q = list_key(p)
    call index_1d_to_2d(dim_list_act_orb, q, i, a)
    list_2d_key(p,1) = i
  enddo

  ! Column indexes
  do p = 1, nb_t2
    !q = list_key(dim_list_act_orb * dim_list_virt_orb -p+1)
    q = list_key(p)
    call index_1d_to_2d(dim_list_act_orb, q, i, a)
    list_2d_key(p,2) = a
  enddo

  ! Guess t2
  t2 = 0d0
  do p = 1, nb_t2
     i = list_2d_key(p,1)
     a = list_2d_key(p,2)
     t2(i,a) = - two_e_ints_iiaa(i,a) &
        /(2d0 * fock_matrix_aa(a) - 2d0 * fock_matrix_ii(i))
     !print*,i,a,t2(i,a), t2(i,a)*normalization_factor
  enddo

  print*,''
  print*,'Epsilon:', epsilon
  print*,'     Nb iter        Energy                  Residue'

  nb_iter = 0
  not_converged = .True.
  
  do while (not_converged)
    
    ! tmp arrays
    call U1_pccd(t2, U1)
    call U2_pccd(t2, U2)
    call U3_pccd(t2, U3)
    call U4_pccd(t2, U4)
    call X_pccd(t2,X)
    call U5_pccd(t2, X, U5)

    ! Residue
    residue = 0d0

    do a = 1, nV
      do i = 1, nO
         tmp_residue(i,a) = two_e_ints_iiaa(i,a) + 2d0*(fock_matrix_aa(a) - fock_matrix_ii(i) - U1(a) - U2(i)) * t2(i,a) &
              - 2d0*(2d0 * two_e_ints_iaia(i,a) - two_e_ints_aiia(a,i) - two_e_ints_aaii(a,i) * t2(i,a)) * t2(i,a) &
              + U3(i,a) + U4(i,a) + U5(i,a)
         !print*,'r',i,a,tmp_residue(i,a)
      enddo
    enddo

    ! Put to 0 the non selected amplitudes
    residue = 0d0
    do p = 1, nb_t2
      i = list_2d_key(p,1)
      a = list_2d_key(p,2)
      residue(i,a) = tmp_residue(i,a)
    enddo
    
    ! New amplitudes
    if (pccd_update_t2 == 'full') then
      ! Use the full jacobian to update the amplitudes
      call pccd_jacobian(t2, t2_jacobian)
      !call pccd_jacobian_v2(t2, t2_jacobian)
      !nb_error = 0
      !do i = 1, nO
      !  do a = 1, nV
      !    do j = 1, nO
      !      do b = 1, nV
      !        if (dabs(t2_jacobian2(i,a,j,b) - t2_jacobian(i,a,j,b)) >= 1d-12) then
      !          write(*,'(4I3,2(1pE12.3))') i,a,j,b, t2_jacobian2(i,a,j,b), t2_jacobian(i,a,j,b)
      !          nb_error = nb_error + 1
      !        endif
      !      enddo
      !    enddo
      !  enddo
      !enddo
      !print*,'nb_error',nb_error
      !call abort
      call inverse_jacobian(t2_jacobian, inv_t2_jacobian)
      call update_amplitudes_pccd_w_J(residue, inv_t2_jacobian, t2)
    elseif (pccd_update_t2 == 'diag') then
      ! Use the diagonal jacobian to update the amplitudes
      ! TODO
      print*,'Not yet available'
      call abort
    else
      ! Normal update of the amplitudes
      call update_amplitudes_pccd(residue, t2)
    endif
    
    nb_iter = nb_iter + 1

    ! New energy
    call pCCD_energy(t2, energy)

    ! max element in residue
    max_residue = 0d0
    do a = 1, nV
      do i = 1, nO
        if (dabs(residue(i,a)) > max_residue) then
          max_residue = dabs(residue(i,a))
        endif
      enddo
    enddo
    
    print*, nb_iter, energy, max_residue

    ! Exit criterion
    if (max_residue < 1e-6) then
       not_converged = .False.
       print*,''
       print*,'******************************'
       write(*,'(A7,1pE15.5,I10,1pE15.5,1pE15.5,1pE15.5)'),' E_pCCD:', epsilon, nb_t2, dble(nb_t2)/dble(dim_list_virt_orb*dim_list_act_orb), &
                                                           energy, energy - real_e
       print*,'******************************'
    endif

    if (nb_iter >= 100) then
       print*,'#########################'
       print*,'   Convergence failed'
       print*,'#########################'
       exit
    endif

  enddo

  deallocate(t2,residue,tmp_residue,X,U1,U2,U3,U4,U5,list_2d_key,list_key,list_crit,t2_jacobian,inv_t2_jacobian)

  call wall_time(tb)
  print*,'Time in run_S1pCCD:', tb-ta
  print*,''
  print*,'---End run_S1pCCD---'
  print*,''
  
end
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine index_1d_to_2d(n,k,i,j)

  implicit none

  integer, intent(in) :: n,k
  integer, intent(out) :: i,j

  ! k index in the list, list ordered column
  ! 1  p   ...
  ! 2  p+1 ...
  ! 3  p+2 ...
  ! :  :   ...  

  j = ((k-1)/n) + 1
  i = modulo((k-1),n) + 1
  
end
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine sort_2d_key(nb_t2, list_2d_key, list_t2)

  implicit none

  integer, intent(in)    :: nb_t2
  integer, intent(inout) :: list_2d_key(nb_t2,2)
  double precision, intent(inout) :: list_t2(nb_t2)
  integer, allocatable   :: tmp_list(:,:), index(:), key(:)
  double precision, allocatable :: tmp_t2(:)
  integer :: i,j,k,l

  allocate(tmp_list(nb_t2,2), index(nb_t2), key(nb_t2), tmp_t2(nb_t2))

  ! index to sort by (i,j) by ascending order (1,1), (1,2),...,(2,1), (2,2), ..., (n,n)
  do k = 1, nb_t2
    index(k) = (list_2d_key(k,1)-1) * dim_list_virt_orb + list_2d_key(k,2)
  enddo

  ! sort
  call isort(index, key, nb_t2)

  ! tmp array contening the sorted key 
  do k = 1, nb_t2
    l = key(k)
    tmp_list(k,1) = list_2d_key(l,1)
    tmp_list(k,2) = list_2d_key(l,2)
    tmp_t2(k) = list_t2(l)
  enddo

  ! and put them in the array
  do k = 1, nb_t2
    list_2d_key(k,1) = tmp_list(k,1)  
    list_2d_key(k,2) = tmp_list(k,2)
    list_t2(k) = tmp_t2(k)
  enddo
  
  deallocate(tmp_list,index,key,tmp_t2)
  
end
#+END_SRC

* Sparse way
#+BEGIN_SRC f90 :comments org
!:tangle pCCD_v2.irp.f
subroutine run_S2pCCD(epsilon,real_e)

  use mkl_spblas
  use iso_c_binding, only :c_int, c_double
  implicit none

  double precision, intent(in) :: epsilon, real_e
  double precision, allocatable :: list_crit(:)
  integer, allocatable :: list_key(:)
  integer, allocatable :: list_2d_key(:,:)
  integer :: i,j,a,b,p,q,nb_t2

  double precision, allocatable :: t2(:,:), residue(:,:), tmp_residue(:,:), list_t2(:), Id(:,:)
  double precision, allocatable :: U1(:), U2(:), U3(:,:), U4(:,:), U5(:,:), X(:,:)
  integer :: nb_iter, info
  double precision :: energy, max_residue, ta, tb, normalization_factor
  logical :: not_converged

  type(sparse_matrix_t) :: sp_t2
  type(matrix_descr) :: descr
  
  integer                       :: nV, nO

  nO = dim_list_act_orb
  nV = dim_list_virt_orb

  print*,''
  print*,'---run_S2pCCD_v2---'
  call wall_time(ta)
  
  allocate(t2(nO, nV), residue(nO, nV), tmp_residue(nO, nV))
  allocate(U1(nV), U2(nO), U3(nO, nV))
  allocate(U4(nO, nV), U5(nO, nV), X(nO, nO))

  if (dim_list_act_orb == mo_num) then
     print*,'Set the mo classes before, abort'
     call abort
  endif

  allocate(list_crit(nO*nV), list_key(nO*nV))
  
  ! 2D -> 1D
  p = 1
  do a = 1, nV
    do i = 1, nO
       if (sccd_method == 'bi_int') then
         list_crit(p) = dabs(two_e_ints_iiaa(i,a))
       elseif (sccd_method == 'guess_mp2') then
         list_crit(p) = dabs(two_e_ints_iiaa(i,a)/(2d0 * fock_matrix_aa(a) - 2d0 * fock_matrix_ii(i)))
       elseif (sccd_method == 'estimated_e') then
         list_crit(p) = dabs(two_e_ints_iiaa(i,a)**2/(2d0 * fock_matrix_aa(a) - 2d0 * fock_matrix_ii(i)))
       else
          print*,'Nothing to do, abort'
          call abort
       endif
       list_key(p) = p
       p = p + 1
    enddo
  enddo
  ! -, to change the ordering after the sort
  list_crit = - list_crit

  ! Sort by ascending order
  call dsort(list_crit, list_key, dim_list_act_orb * dim_list_virt_orb)
  
  ! Normalization of the biggest criterion
  normalization_factor = 1d0/list_crit(1) !(dim_list_act_orb * dim_list_virt_orb)

  ! Normalized and sorted list
  list_crit = list_crit * normalization_factor

  ! Number of selected elements
  p = 1
  do while ((p <= dim_list_act_orb * dim_list_virt_orb) .and. list_crit(min(p, dim_list_act_orb * dim_list_virt_orb)) >= epsilon)
    p = p + 1
  enddo
  nb_t2 = p - 1 

  ! Debug
  !do p = 1, dim_list_act_orb * dim_list_virt_orb
  !  print*, list_crit(p)
  !enddo
  !print*,'nb',nb_t2
  
  allocate(list_2d_key(nb_t2,2),list_t2(nb_t2))

  ! Row indexes
  do p = 1, nb_t2
    q = list_key(p)
    call index_1d_to_2d(dim_list_act_orb, q, i, a)
    list_2d_key(p,1) = i
  enddo

  ! Column indexes
  do p = 1, nb_t2
    q = list_key(p)
    call index_1d_to_2d(dim_list_act_orb, q, i, a)
    list_2d_key(p,2) = a
  enddo
      
  ! Guess t2
  t2 = 0d0
  do p = 1, nb_t2
     i = list_2d_key(p,1)
     a = list_2d_key(p,2)
     t2(i,a) = two_e_ints_iiaa(i,a) &
        /(2d0 * fock_matrix_aa(a) - 2d0 * fock_matrix_ii(i))
     !print*,i,a,t2(i,a), t2(i,a)*normalization_factor
     list_t2(p) =  two_e_ints_iiaa(i,a) &
        /(2d0 * fock_matrix_aa(a) - 2d0 * fock_matrix_ii(i))
  enddo

  ! Sort the t2 by ascending order of indexes
  call sort_2d_key(nb_t2, list_2d_key, list_t2)

!! ### TEST ###
!!  ! list of rows with non-zero elements
!!  list_row = 0
!!  do p = 1, nb_t2
!!    i = list_2d_key(p,1)
!!    tmp_list_row(i) = i
!!  enddo
!!
!!  nb_row = 0
!!  do i = 1, dim_list_act_orb
!!    if (tmp_list_row(i) /= 0) then
!!       nb_row = nb_row + 1
!!    endif
!!  enddo
!!
!!  allocate(list_row(nb_row), nb_val_row(nb_row), list_index_row(nb_row))
!!  j = 1
!!  do i = 1, dim_list_act_orb
!!    if (tmp_list_row(i) /= 0) then
!!      list_row(j) = tmp_list_row(i)
!!      j = j + 1
!!    endif
!!  enddo
!!
!!  ! Number of non-zero elements per row
!!  i = 1
!!  nb_val_row = 0
!!  do p = 1, nb_t2
!!    if (list_2d_key(p,1) == list_row(i)) then
!!      nb_val_row(i) = nb_val_row(i) + 1
!!    else
!!      i = i + 1
!!      nb_val_row(i) = nb_val_row(i) + 1
!!    endif
!!  enddo
!!
!!  ! Index of each row in the vector
!!  list_index_row(1) = 1
!!  do i = 2, nb_row
!!    list_index_row(i) = list_index_row(i-1) + nb_val_row(i-1)
!!  enddo
  
  ! debug
  !do p = 1, nb_t2
  !  i = list_2d_key(p,1)
  !  a = list_2d_key(p,2)
  !  print*, i,a
  !   print*,list_t2(p)
  !enddo
  !call abort

  ! info = mkl_sparse_d_create_coo(A, SPARSE_INDEX_BASE_ONE, rows, cols, nnz, row_indx, col_indx, values)
  !info = mkl_sparse_d_create_coo(sp_t2, SPARSE_INDEX_BASE_ONE, dim_list_act_orb, dim_list_virt_orb, nb_t2, list_2d_key(:,1), list_2d_key(:,2), list_t2)

  !allocate(Id(dim_list_virt_orb,dim_list_virt_orb))
  !Id = 0d0
  !do i = 1, dim_list_virt_orb
  !  Id(i,i) = 1d0
  !enddo
  !print*,'Before'
  !do i = 1, dim_list_act_orb
  !  write(*,'(100(1pE14.5))') t2(i,:)
  !enddo

  !descr%type = SPARSE_MATRIX_TYPE_GENERAL
  ! info = mkl_sparse_d_mm (operation, alpha, A, descr, layout, B, columns, ldb, beta, C, ldc)
  !info = mkl_sparse_d_mm (SPARSE_OPERATION_NON_TRANSPOSE, 1d0, sp_t2, descr, SPARSE_LAYOUT_ROW_MAJOR, Id, dim_list_virt_orb, size(Id,1), 0d0, t2, size(t2,1))
  !deallocate(Id)

  !print*,'After'
  !do i = 1, dim_list_act_orb
  !  write(*,'(100(1pE14.5))') t2(i,:)
  !enddo
  !return
  
  print*,''
  print*,'Epsilon:', epsilon
  print*,'     Nb iter        Energy                  Residue'

  nb_iter = 0
  not_converged = .True.
  
  do while (not_converged)

    t2 = 0d0
    do p = 1, nb_t2
      i = list_2d_key(p,1)
      a = list_2d_key(p,2)
      t2(i,a) = list_t2(p)
    enddo
      
    ! tmp arrays
    call U1_pccd(t2, U1)
    call U2_pccd(t2, U2)
    call U3_sp_pccd(nb_t2, list_2d_key, list_t2, U3)
    call U4_sp_pccd(nb_t2, list_2d_key, list_t2, U4)
    call X_sp_pccd(nb_t2, list_2d_key, list_t2, X)
    call U5_sp_pccd(nb_t2, list_2d_key, list_t2, X, U5)

    ! Residue
    tmp_residue = 0d0
    do a = 1, nV
      do i = 1, nO
         tmp_residue(i,a) = two_e_ints_iiaa(i,a) + 2d0*(fock_matrix_aa(a) - fock_matrix_ii(i) - U1(a) - U2(i)) * t2(i,a) &
              - 2d0*(2d0 * two_e_ints_iaia(i,a) - two_e_ints_aiia(a,i) - two_e_ints_aaii(a,i) * t2(i,a)) * t2(i,a) &
              + U3(i,a) + U4(i,a) + U5(i,a)
         !print*,'r',i,a,tmp_residue(i,a)
      enddo
    enddo

    ! Put to 0 the non selected amplitudes
    residue = 0d0
    do p = 1, nb_t2
      i = list_2d_key(p,1)
      a = list_2d_key(p,2)
      residue(i,a) = tmp_residue(i,a)
    enddo
    
    ! New amplitudes
    call update_amplitudes_pccd(residue, t2)
   
    nb_iter = nb_iter + 1

    ! New energy
    call pCCD_energy(t2,energy)

    ! list of updated amplitudes
    do p = 1, nb_t2
      i = list_2d_key(p,1)
      a = list_2d_key(p,2)
      list_t2(p) = t2(i,a)
    enddo

    ! max element in residue
    max_residue = 0d0
    do a = 1, nV
      do i = 1, nO
        if (dabs(residue(i,a)) > max_residue) then
          max_residue = dabs(residue(i,a))
        endif
      enddo
    enddo
    
    print*, nb_iter, energy, max_residue

    ! Exit criterion
    if (max_residue < 1e-6) then
       not_converged = .False.
       print*,''
       print*,'******************************'
       write(*,'(A7,1pE15.5,I10,1pE15.5,1pE15.5)'),' E_pCCD:', epsilon, nb_t2, energy, energy - real_e
       print*,'******************************' 
    endif

    if (nb_iter >= 100) then
       print*,'#########################'
       print*,'   Convergence failed'
       print*,'#########################'
       exit
    endif

  enddo

  deallocate(t2,residue,tmp_residue,X,U1,U2,U3,U4,U5,list_2d_key,list_key,list_crit,list_t2)

  call wall_time(tb)
  print*,'Time in run_S2pCCD:', tb-ta
  print*,''
  print*,'---End run_S2pCCD---'
  print*,''
  
end
#+END_SRC

#+BEGIN_SRC f90 :comments org
!:tangle idk.irp.f
program test_spblas

  use mkl_spblas
  use iso_c_binding, only :c_int, c_double
  
  implicit none

  integer, parameter :: rows = 4
  integer, parameter :: cols = 6

  integer, parameter :: nnz = 8

  integer :: ia(rows+1), ja(nnz), stat
  real :: values(nnz), x(6), y(4)

  type(sparse_matrix_t) :: a
  type(matrix_descr) :: descr


  ! Matrix example taken from: 
  ! https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format)
  !
  !     | 10  20  0  0  0  0 |
  ! A = |  0  30  0 40  0  0 |
  !     |  0   0 50 60 70  0 |
  !     |  0   0  0  0  0 80 | 
 
  ia = [1,3,5,8,9]
  ja = [1,2,2,4,3,4,5,6]
  values = [10, 20, 30, 40, 50, 60, 70, 80]

  stat = mkl_sparse_s_create_csr(a,SPARSE_INDEX_BASE_ONE,rows,cols,ia(1:4),ia(2:5),ja,values)
  print *, "stat create = ", stat

  descr%type = SPARSE_MATRIX_TYPE_GENERAL

  x = [1,1,1,1,1,1]
  stat = mkl_sparse_s_mv(SPARSE_OPERATION_NON_TRANSPOSE,1.0,a,descr,x,0.0,y)
  print *, "stat mv = ", stat

  print *, "result   = ", y
  print *, "expected = ", [30., 70., 180., 80.]

end program
#+END_SRC

** Routines
#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine U1_sp_pccd(nb_t2, nb_col, list_index_col, nb_val_col, list_t2, U1)
  
  implicit none

  ! in
  integer, intent(in)           :: nb_t2, nb_col
  double precision, intent(in)  :: list_t2(nb_t2)
  integer, intent(in)           :: list_index_col(nb_col), nb_val_col(nb_col)

  ! out
  double precision, intent(out) :: U1(dim_list_virt_orb)

  ! internal
  integer                       :: j,a

  ! U1(a) = \sum_j t_j^a v_{aa}^{jj}
  call abort ! need the good ordering of t2
  U1 = 0d0
  do a = 1, nb_col
    do j = list_index_col(a), list_index_col(a) + nb_val_col(a)
      U1(a) = U1(a) + list_t2(j) * two_e_ints_aaii(a,j)
    enddo
  enddo

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine list_U2_pccd(nb_t2, nb_row, list_index_row, nb_val_row,list_t2, U2)
  
  implicit none

  ! in
  integer, intent(in)           :: nb_t2, nb_row
  double precision, intent(in)  :: list_t2(nb_t2)
  integer, intent(in)           :: list_index_row(nb_row), nb_val_row(nb_row)

  ! out
  double precision, intent(out) :: U2(dim_list_act_orb)

  ! internal
  integer                       :: i,b

  ! U2(i) = \sum_b t_i^b v_{bb}^{ii}
  call abort ! need the good ordering of t2
  U2 = 0d0
  do i = 1, nb_row
    do b = list_index_row(i), list_index_row(i) + nb_val_row(i)
      U2(i) = U2(i) + list_t2(b) * two_e_ints_aaii(b,i)
    enddo
  enddo

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org
!:tangle pCCD_v2.irp.f
subroutine U3_sp_pccd(nb_t2, list_2d_key, list_t2, U3)
  
  use mkl_spblas
  use iso_c_binding, only :c_int, c_double
  implicit none

  ! in
  integer, intent(in)           :: nb_t2
  integer, intent(in)           :: list_2d_key(nb_t2,2)
  double precision, intent(in)  :: list_t2(nb_t2)

  ! out
  double precision, intent(out) :: U3(dim_list_act_orb, dim_list_virt_orb)

  ! internal
  integer                       :: i,a,b,info
  type(sparse_matrix_t)         :: sp_t2
  type(matrix_descr)            :: descr

  ! U3(i,a) = \sum_b t_i^b v_{bb}^{aa}
  !U3 = 0d0
  !do a = 1, dim_list_virt_orb
  !  do i = 1, dim_list_act_orb
  !    do b = 1, dim_list_virt_orb
  !       U3(i,a) = U3(i,a) + t2(i,b) * two_e_ints_aabb(b,a)
  !    enddo
  !  enddo
  !enddo
  !call dgemm('N','N', dim_list_act_orb, dim_list_virt_orb, dim_list_virt_orb, &
  !           1d0, t2, size(t2,1), &
  !                two_e_ints_aabb, size(two_e_ints_aabb,1), &
  !           0d0, U3, size(U3,1))

  ! vec -> sparse COO
  info = mkl_sparse_d_create_coo(sp_t2, SPARSE_INDEX_BASE_ONE, dim_list_act_orb, dim_list_virt_orb, nb_t2, list_2d_key(:,1), list_2d_key(:,2), list_t2)
  descr%type = SPARSE_MATRIX_TYPE_GENERAL

  ! Sparse-dense matrix multiplication
  info = mkl_sparse_d_mm(SPARSE_OPERATION_NON_TRANSPOSE, 1d0, sp_t2, descr, SPARSE_LAYOUT_ROW_MAJOR, two_e_ints_aabb, dim_list_virt_orb, size(two_e_ints_aabb,1), 0d0, U3, size(U3,1))

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org
!:tangle pCCD_v2.irp.f
subroutine U4_sp_pccd(nb_t2, list_2d_key, list_t2, U4)
  
  use mkl_spblas
  use iso_c_binding, only :c_int, c_double
  implicit none

  ! in
  integer, intent(in)           :: nb_t2
  integer, intent(in)           :: list_2d_key(nb_t2,2)
  double precision, intent(in)  :: list_t2(nb_t2)

  ! out
  double precision, intent(out) :: U4(dim_list_act_orb, dim_list_virt_orb)

  ! internal
  integer                       :: i,j,a,info
  double precision, allocatable :: two_e_ints_iijj_T(:,:), U4_T(:,:)
  type(sparse_matrix_t)         :: sp_t2
  type(matrix_descr)            :: descr

  allocate(two_e_ints_iijj_T(dim_list_act_orb, dim_list_act_orb),U4_T(dim_list_virt_orb, dim_list_act_orb))

  two_e_ints_iijj_T = transpose(two_e_ints_iijj)
  
  ! U4(i,a) = \sum_j t_j^a v_{ii}^{jj}
  !         = \sum_j v_{ii}^{jj} t_j^a
  
  !U4 = 0d0
  !do a = 1, dim_list_virt_orb
  !  do i = 1, dim_list_act_orb
  !    do j = 1, dim_list_act_orb
  !      U4(i,a) = U4(i,a) + t2(j,a) * two_e_ints_iijj(i,j)
  !    enddo
  !  enddo
  !enddo

  !call dgemm('N','N', dim_list_act_orb, dim_list_virt_orb, dim_list_act_orb, &
  !           1d0, two_e_ints_iijj, size(two_e_ints_iijj,1), &
  !                t2, size(t2,1), &
  !           0d0, U4, size(U4,1))

  ! vec -> sparse COO
  info = mkl_sparse_d_create_coo(sp_t2, SPARSE_INDEX_BASE_ONE, dim_list_act_orb, dim_list_virt_orb, nb_t2, list_2d_key(:,1), list_2d_key(:,2), list_t2)
  descr%type = SPARSE_MATRIX_TYPE_GENERAL

  ! Sparse-dense matrix multiplication
  info = mkl_sparse_d_mm(SPARSE_OPERATION_TRANSPOSE, 1d0, sp_t2, descr, SPARSE_LAYOUT_ROW_MAJOR, two_e_ints_iijj_T, dim_list_act_orb, size(two_e_ints_iijj_T,1), 0d0, U4_T, size(U4_T,1))

  U4 = transpose(U4_T)
  
  deallocate(two_e_ints_iijj_T,U4_T)
  
end  
#+END_SRC

#+BEGIN_SRC f90 :comments org
!:tangle pCCD_v2.irp.f
subroutine U5_sp_pccd(nb_t2, list_2d_key, list_t2, X, U5)

  use mkl_spblas
  use iso_c_binding, only :c_int, c_double
  implicit none

  ! in
  integer, intent(in)           :: nb_t2
  double precision, intent(in)  :: list_t2(nb_t2)
  integer, intent(in)           :: list_2d_key(nb_t2,2)
  double precision, intent(in)  :: X(dim_list_act_orb, dim_list_act_orb)

  ! out
  double precision, intent(out) :: U5(dim_list_act_orb, dim_list_virt_orb)

  ! internal
  integer                       :: i,j,a,info
  double precision, allocatable :: X_T(:,:), U5_T(:,:)
  type(sparse_matrix_t)         :: sp_t2
  type(matrix_descr)            :: descr

  allocate(X_T(dim_list_act_orb,dim_list_act_orb), U5_T(dim_list_virt_orb, dim_list_act_orb))

  X_T = transpose(X)

  ! U5(i,a) = \sum_{jb} t_j^a t_i^b v_{bb}^{jj}
  !         = \sum_j X(i,j) t_j^a
  !U5 = 0d0
  !do a = 1, dim_list_virt_orb
  !  do i = 1, dim_list_act_orb
  !    do j = 1, dim_list_act_orb
  !      U5(i,a) = U5(i,a) + t2(j,a) * X(i,j)
  !    enddo
  !  enddo
  !enddo

  !call dgemm('N','N', dim_list_act_orb, dim_list_virt_orb, dim_list_act_orb, &
  !           1d0, X, size(X,1), t2, size(t2,1), 0d0, U5, size(U5,1))

  ! vec -> sparse COO
  info = mkl_sparse_d_create_coo(sp_t2, SPARSE_INDEX_BASE_ONE, dim_list_act_orb, dim_list_virt_orb, nb_t2, list_2d_key(:,1), list_2d_key(:,2), list_t2)
  descr%type = SPARSE_MATRIX_TYPE_GENERAL

  ! Sparse-dense matrix multiplication
  info = mkl_sparse_d_mm(SPARSE_OPERATION_TRANSPOSE, 1d0, sp_t2, descr, SPARSE_LAYOUT_ROW_MAJOR, X_T, dim_list_act_orb, size(X_T,1), 0d0, U5_T, size(U5_T,1))

  U5 = transpose(U5_T)

  deallocate(X_T,U5_T)

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org
!:tangle pCCD_v2.irp.f
subroutine X_sp_pccd(nb_t2, list_2d_key, list_t2, X)

  use mkl_spblas
  use iso_c_binding, only :c_int, c_double
  implicit none

  ! in
  integer, intent(in)           :: nb_t2
  double precision, intent(in)  :: list_t2(nb_t2)
  integer, intent(in)           :: list_2d_key(nb_t2,2)

  ! out
  double precision, intent(out) :: X(dim_list_act_orb, dim_list_act_orb)

  ! internal
  integer                       :: i,j,b,info
  type(sparse_matrix_t)         :: sp_t2
  type(matrix_descr)            :: descr

  ! X(i,j) = \sum_b t_i^b v_{bb}^{jj}
  ! call dgemm('N','N', dim_list_act_orb, dim_list_act_orb, dim_list_virt_orb, &
  !            1d0, t2, size(t2,1), two_e_ints_aaii, size(two_e_ints_aaii,1), &
  !            0d0, X, size(X,1))

  ! vec -> sparse COO
  info = mkl_sparse_d_create_coo(sp_t2, SPARSE_INDEX_BASE_ONE, dim_list_act_orb, dim_list_virt_orb, nb_t2, list_2d_key(:,1), list_2d_key(:,2), list_t2)
  descr%type = SPARSE_MATRIX_TYPE_GENERAL

  ! Sparse-dense matrix multiplication
  info = mkl_sparse_d_mm(SPARSE_OPERATION_NON_TRANSPOSE, 1d0, sp_t2, descr, SPARSE_LAYOUT_ROW_MAJOR, two_e_ints_aaii, dim_list_act_orb, size(two_e_ints_aaii,1), 0d0, X, size(X,1))
   
end  
#+END_SRC
