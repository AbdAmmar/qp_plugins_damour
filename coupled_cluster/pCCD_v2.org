* pCCD

cite Henderson 2014

i,j,k,l: occupied
a,b,c,d: virtual
p,q,r,s: general

pCCD energy:
\begin{align*}
E= <0|H|0> + \sum_{ia} t_i^a v_{ii}^{aa}
\end{align*}

\begin{align*}
r_i^a &= v_{ii}^{aa} + 2(f_a^a - f_i^i - \sum_{j} t_j^a v_{aa}^{jj}
- \sum_{b} t_i^b v_{bb}^{ii})t_i^a \\
&-2(2 v_{ia}^{ia} - v_{ai}^{ia} - v_{aa}^{ii} t_i^a) t_i^a \\
&+ \sum_{b} t_i^b v_{bb}^{aa} +  \sum_{j} t_j^a v_{ii}^{jj}
+ \sum_{jb} v_{bb}^{jj} t_j^a t_i^b
\end{align*}
\begin{align*}
&= v_{ii}^{aa} + 2(f_a^a - f_i^i - U_{1_a} - U_{2_i}) t_i^a \\
&- 2(2v_{ia}^{ia} - v_{ai}^{ia} - v_{aa}^{ii} t_i^a) t_i^a \\
&+ U_{3_i}^a + U_{4_i}^a + U_{5_i}^a
\end{align*}

$$\sum_j t_j^a v_{aa}^{jj} = U_{1_a}$$
$$\sum_b t_i^b v_{bb}^{ii} = U_{2_i}$$
$$\sum_b t_i^b v_{bb}^{aa}=U_{3_i}^a$$
$$\sum_j t_j^a v_{ii}^{jj} = U_{4_i}^a$$
$$\sum_{b} v_{bb}^{jj} t_i^b = X_{i}^{j}$$
$$\sum_{jb} v_{bb}^{jj} t_j^a t_i^b=\sum_j X_i^j t_j^a = U_{5_i}^a$$
with $f_q^p$ an element of the Fock operator and $v_{rs}^{pq}$ is a
bi-electronic integral.

Guess for $t$
$$t_i^a = \frac{v_{ii}^{aa}}{(2f_a^a - 2f_i^i)}$$

Update:
$$t_i^a \leftarrow t_i^a - \frac{r_i^a}{2f_a^a - 2f_i^i}$$
** S-pCCD
*** Naive way
  - criterion (<ii|aa> integrals, divided or not by the f elements) in
    a list (must be normalized in order to have to max value = 1)
  - sort the list
  - cut with respect to the threshold
  - compute the indexes vec -> mat for the back transformation
  - store the indexes in a n (depends of the threshold) by 2 array
  - use the list to keep at zero the zero values after each operation

*** Sparse matrix
  - Same but use a sparse matrix for the t2
  - create a new sparse array with true non-zero elements after each
    operation 
    
** Bottleneck 

$$\sum_b t_i^b v_{bb}^{aa}=U_{3_i}^a \rightarrow OV^2 $$ 

** 4D -> 2D:
(i,j,k,l) -> (ij,kl)
   11 12 13 14 21 22 23 24 31 32 33 34 41 42 43 44
1 1
1 2
1 3
1 4
2 1
2 2
2 3
2 4
3 1
3 2
3 3
3 4
4 1
4 2
4 3
4 4

** SVD

Matrix multiplication:
C = A.B
$$c_{ij} = \sum_k a_{ik} b_{kj}$$
k multiplications
k-1 summations
(2k-1)mn flops

svd A: O(mn^2), m >= n

ref tomoko 2003
Consider a $m$ by $n$ matrix $\textbf{A}$ with $m \leq n$ s.t. $A_{ij} \in \mathbb{R}$
$\forall \quad i \in (1,...,m), \quad j \in (1,...,n)$
The SVD of this matrix is
$\textbf{A} = \textbf{U} \textbf{S} \textbf{V}^T$

with $\textbf{U}$ is a $m$ by $m$ matrix and $\textbf{V}^T$ is a $m$ by
$n$ matrix
Columns of $\texbf{U}$, $\left\{\textbf{u}_k\right\}_{k=1}^m$: left
singular vectors of size $m$
Rows of $\texbf{V}^T$, $\left\{\textbf{v}^T_k\right\}_{k=1}^m$: right
singular vectors of size $n$

Then
\begin{align*}
\textbf{A}=\sum_{k=1}^m \textbf{u}_k \textbf{s}_k \textbf{v}_k^T
\end{align*}
\begin{align*}
\textbf{A}^{(l)}=\sum_{k=1}^l \textbf{u}_k \textbf{s}_k \textbf{v}_k^T, \quad l \leq r
\end{align*}
Matrix of rank $p$: $p$ non-zero eigenvalues
$\textbf{A}^{(l)}$ is the closest matrix of rank $l$ to $\textbf{A}$
If the eigenvalues $\left\{s_k\right\}_{k=l+1}^m$ are small enought
$\textbf{A}^{(l)}$ is a good approximation of $\textbf{A}$



$T_2 = \frac{1}{2} \sum_{ia} t_{ii}^{aa} a^\dagger a^\dagger i i$

** Code
#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
program pCCD
  implicit none

  double precision :: energy
  call run_pCCD_v2(energy)
  print*,'#######################################################'
  double precision :: epsilon
  epsilon = 0d0
  call run_S1pCCD(epsilon, energy)
  !call run_S2pCCD(epsilon, energy)
  !epsilon = 1d-1
  !call run_S2pCCD(epsilon, energy)
  !epsilon = 5d-2
  !call run_S2pCCD(epsilon, energy)
  !epsilon = 1d-2
  !call run_S2pCCD(epsilon, energy)
  !epsilon = 1d-3
  !call run_S2pCCD(epsilon, energy)

  epsilon = 1d0
  do while (epsilon > 1d-8)
    call run_S1pCCD(epsilon, energy)
    epsilon = epsilon * 0.9d0
  enddo
  
end program
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine run_pCCD_v2(energy)
  
  implicit none

  double precision, allocatable :: t2(:,:), residue(:,:)
  double precision, allocatable :: U1(:), U2(:), U3(:,:), U4(:,:), U5(:,:), X(:,:)
  integer :: p,q,i,j,a,b,tmp_a,tmp_b
  integer :: nb_iter
  double precision :: max_residue, ta, tb !, energy
  double precision, intent(out) :: energy
  double precision :: accu1, accu2, accu3, accu4, accu5
  logical :: not_converged

  print*,''
  print*,'---run_pCCD_v2---'
  call wall_time(ta)
  
  allocate(t2(dim_list_act_orb, dim_list_virt_orb), residue(dim_list_act_orb, dim_list_virt_orb))!, fock_matrix_pp(dim_list_act_virt_orb))
!  allocate(fock_matrix_ii(dim_list_act_orb), fock_matrix_aa(dim_list_virt_orb))
  allocate(U1(dim_list_virt_orb), U2(dim_list_act_orb), U3(dim_list_act_orb, dim_list_virt_orb))
  allocate(U4(dim_list_act_orb, dim_list_virt_orb), U5(dim_list_act_orb, dim_list_virt_orb), X(dim_list_act_orb, dim_list_act_orb))

  if (dim_list_act_orb == mo_num) then
     print*,'Set the mo classes before, abort'
     call abort
  endif

  ! Init 
  t2 = 0d0
  !print*,dim_list_act_orb,dim_list_virt_orb
  call pCCD_energy(t2, energy)
  print*,'HF energy', energy

!  ! f_p^p, tmp matrix for the diagonal element of the fock matrix
!  fock_matrix_pp = 0d0
!  do p = 1, dim_list_act_virt_orb
!    fock_matrix_pp(p) = fock_matrix_mo(p,p)
!  enddo
!
!  fock_matrix_ii= 0d0
!  do i = 1, dim_list_act_orb
!    fock_matrix_ii(i) = fock_matrix_mo(i,i)
!  enddo
!
!  fock_matrix_aa = 0d0
!  do a = 1, dim_list_virt_orb
!    tmp_a = a + dim_list_act_orb
!    fock_matrix_aa(a) = fock_matrix_mo(tmp_a,tmp_a)
!  enddo

  ! Guess for t2 = t_i^a / (2f_a^a - 2f_i^i)
  !print*,dim_list_act_orb, dim_list_virt_orb
  !do a = 1, dim_list_virt_orb
  !  tmp_a = a + dim_list_act_orb
  !  do i = 1, dim_list_act_orb
  !    t2(i,a) = two_e_ints_ppqq(i,tmp_a) &
  !      /(2d0 * fock_matrix_pp(tmp_a) - 2d0 * fock_matrix_pp(i))
  !    !print*,i,a,t2(i,a)
  !  enddo
  !enddo

  call guess_amplitudes_pccd(t2)

  print*,''
  print*,'     Nb iter        Energy                  Residue'

  nb_iter = 0
  not_converged = .True.
  
  do while (not_converged)
     
    ! tmp arrays
    call U1_pccd(t2, U1)
    call U2_pccd(t2, U2)
    call U3_pccd(t2, U3)
    call U4_pccd(t2, U4)
    call X_pccd(t2,X)
    call U5_pccd(t2, X, U5)
    
    ! Residue
    residue = 0d0

    do a = 1, dim_list_virt_orb
      do i = 1, dim_list_act_orb
         residue(i,a) = two_e_ints_iiaa(i,a) + 2d0*(fock_matrix_aa(a) - fock_matrix_ii(i) - U1(a) - U2(i)) * t2(i,a) &
              - 2d0*(2d0 * two_e_ints_iaia(i,a) - two_e_ints_aiia(a,i) - two_e_ints_aaii(a,i) * t2(i,a)) * t2(i,a) &
              + U3(i,a) + U4(i,a) + U5(i,a)
         !print*,'r',i,a,residue(i,a)
      enddo
    enddo
    
    !do a = 1, dim_list_virt_orb
    !tmp_a = a + dim_list_act_orb
    !  do i = 1, dim_list_act_orb
    !     
    !    ! U1(a) = \sum_j t_j^a v_{aa}^{jj}
    !    accu1 = 0d0
    !    do j = 1, dim_list_act_orb
    !      accu1 = accu1 + t2(j,a) * two_e_ints_ppqq(tmp_a,j)
    !    enddo

    !    ! U2(i) = \sum_b t_i^b v_{bb}^{ii} 
    !    accu2 = 0d0
    !    do b = 1, dim_list_virt_orb
    !      tmp_b = b + dim_list_act_orb
    !      accu2 = accu2 + t2(i,b) * two_e_ints_ppqq(tmp_b,i)
    !    enddo

    !    ! U3(i,a) = \sum_b t_i^b v_{bb}^{aa}
    !    accu3 = 0d0
    !    do b = 1, dim_list_virt_orb
    !      tmp_b = b + dim_list_act_orb
    !      accu3 = accu3 + t2(i,b) * two_e_ints_ppqq(tmp_b,tmp_a)
    !    enddo

    !    ! U4(i,a) = \sum_j t_j^a v_{ii}^{jj}
    !    accu4 = 0d0
    !    do j = 1, dim_list_act_orb
    !      accu4 = accu4 + t2(j,a) * two_e_ints_ppqq(i,j)
    !    enddo

    !    ! U5(i,a) = \sum_{jb} t_j^a t_i^b v_{bb}^{jj} 
    !    accu5 = 0d0
    !    do j = 1, dim_list_act_orb
    !      do b = 1, dim_list_virt_orb
    !        tmp_b = b + dim_list_act_orb
    !        accu5 = accu5 + t2(j,a) * t2(i,b) * two_e_ints_ppqq(tmp_b,j)
    !      enddo
    !    enddo
  
    !    residue(i,a) = two_e_ints_ppqq(i,tmp_a) &
    !      + 2d0 *(fock_matrix_pp(tmp_a) - fock_matrix_pp(i) - accu1 - accu2) * t2(i,a) &
    !      - 2d0*(2d0 * two_e_ints(i,tmp_a,i,tmp_a) &
    !             - two_e_ints(tmp_a,i,i,tmp_a) &
    !             - two_e_ints(tmp_a,tmp_a,i,i) * t2(i,a)) * t2(i,a) &
    !      + accu3 + accu4 + accu5

    !    !print*,'r',i,a,residue(i,a)
    !    
    !  enddo
    !enddo
    
    !! New amplitudes
    !do a = 1, dim_list_virt_orb
    !  tmp_a = a + dim_list_act_orb
    !  do i = 1, dim_list_act_orb
    !    t2(i,a) = t2(i,a) - residue(i,a)/(2d0 * fock_matrix_pp(tmp_a) - 2d0 * fock_matrix_pp(i))
    !  enddo
    !enddo

    ! New amplitudes
    call update_amplitudes_pccd(residue, t2)
   
    nb_iter = nb_iter + 1

    ! New energy
    call pCCD_energy(t2,energy)

    ! max element in residue
    max_residue = 0d0
    do a = 1, dim_list_virt_orb
      do i = 1, dim_list_act_orb
        if (dabs(residue(i,a)) > max_residue) then
          max_residue = dabs(residue(i,a))
        endif
      enddo
    enddo
    
    print*, nb_iter, energy, max_residue

    ! Exit criterion
    if (max_residue < 1e-6) then
       not_converged = .False.
       print*,''
       print*,'******************************'
       print*,' E_pCCD:', energy
       print*,'******************************' 
    endif

    if (nb_iter >= 100) then
       print*,'#########################'
       print*,'   Convergence failed'
       print*,'#########################'
       exit
    endif

  enddo

  deallocate(t2,residue,X,U1,U2,U3,U4,U5)

  call wall_time(tb)
  print*,'Time in run_pCCD_v2:', tb-ta
  print*,''
  print*,'---End run_pCCD_v2---'
  print*,''
  
end
#+END_SRC

** Routines
#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine pCCD_energy(t2,energy)

  implicit none

  double precision, intent(in) :: t2(dim_list_act_orb, dim_list_virt_orb)
  double precision :: energy
  integer :: i,a,tmp_a,tmp_b

  ! Final energy
  energy = 0d0
  do a = 1, dim_list_virt_orb
    tmp_a = a + dim_list_act_orb
    do i = 1, dim_list_act_orb
      energy = energy + t2(i,a) * two_e_ints_ppqq(tmp_a,i)
    enddo
  enddo 
  
  ! Add <0|H|0>
  energy = energy + hf_energy

end
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine guess_amplitudes_pccd(t2)
  
  implicit none

  double precision, intent(out) :: t2(dim_list_act_orb, dim_list_virt_orb)
  integer :: i, a

  ! Guess for t2 = t_i^a / (2f_a^a - 2f_i^i)
  do a = 1, dim_list_virt_orb
    do i = 1, dim_list_act_orb
      t2(i,a) = two_e_ints_iiaa(i,a) &
        /(2d0 * fock_matrix_aa(a) - 2d0 * fock_matrix_ii(i))
      !print*,i,a,t2(i,a)
    enddo
  enddo

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine update_amplitudes_pccd(residue, t2)
  
  implicit none

  double precision, intent(in) :: residue(dim_list_act_orb, dim_list_virt_orb) 
  double precision, intent(out) :: t2(dim_list_act_orb, dim_list_virt_orb)
  integer :: i, a
  
  ! New amplitudes
  do a = 1, dim_list_virt_orb
    do i = 1, dim_list_act_orb
      t2(i,a) = t2(i,a) - residue(i,a)/(2d0 * fock_matrix_aa(a) - 2d0 * fock_matrix_ii(i))
    enddo
  enddo

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine residue_pccd(t2, U1, U2, U3, U4, U5, residue)
  
  implicit none

  double precision, intent(in)  :: U1(dim_list_virt_orb), U2(dim_list_act_orb)
  double precision, intent(in)  :: U3(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(in)  :: U4(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(in)  :: U5(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(out) :: residue(dim_list_act_orb, dim_list_virt_orb)
  integer                       :: i,a

  do a = 1, dim_list_virt_orb
     do i = 1, dim_list_act_orb
        residue(i,a) = two_e_ints_iiaa(i,a) &
          + 2d0 *(fock_matrix_aa(a) - fock_matrix_ii(i) - U1(a) - U2(i)) * t2(i,a) &
          - 2d0*(2d0 * two_e_ints_iaia(i,a) &
          - two_e_ints_aiia(a,i) &
          - two_e_ints_aaii(a,i) * t2(i,a)) * t2(i,a) &
          + U3(i,a) + U4(i,a) + U5(i,a)
     enddo
   enddo
  
end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine U1_pccd(t2, U1)
  
  implicit none

  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(out) :: U1(dim_list_virt_orb)
  integer                       :: j,a

  ! U1(a) = \sum_j t_j^a v_{aa}^{jj}
  U1 = 0d0
  do a = 1, dim_list_virt_orb
    do j = 1, dim_list_act_orb
      U1(a) = U1(a) + t2(j,a) * two_e_ints_aaii(a,j)
    enddo
  enddo

  

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine U2_pccd(t2, U2)
  
  implicit none

  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(out) :: U2(dim_list_act_orb)
  integer                       :: i,b

  ! U2(i) = \sum_b t_i^b v_{bb}^{ii} 
  U2 = 0d0
  do i = 1, dim_list_act_orb
    do b = 1, dim_list_virt_orb
      U2(i) = U2(i) + t2(i,b) * two_e_ints_aaii(b,i)
    enddo
  enddo

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine U3_pccd(t2, U3)
  
  implicit none

  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(out) :: U3(dim_list_act_orb, dim_list_virt_orb)
  integer                       :: i,a,b

  ! U3(i,a) = \sum_b t_i^b v_{bb}^{aa}
  !U3 = 0d0
  !do a = 1, dim_list_virt_orb
  !  do i = 1, dim_list_act_orb
  !    do b = 1, dim_list_virt_orb
  !       U3(i,a) = U3(i,a) + t2(i,b) * two_e_ints_aabb(b,a)
  !    enddo
  !  enddo
  !enddo

  call dgemm('N','N', dim_list_act_orb, dim_list_virt_orb, dim_list_virt_orb, &
             1d0, t2, size(t2,1), &
                  two_e_ints_aabb, size(two_e_ints_aabb,1), &
             0d0, U3, size(U3,1))
  
end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine U4_pccd(t2, U4)
  
  implicit none
  
  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(out) :: U4(dim_list_act_orb, dim_list_virt_orb)
  integer                       :: i,j,a

  ! U4(i,a) = \sum_j t_j^a v_{ii}^{jj}
  !         = \sum_j v_{ii}^{jj} t_j^a
  
  !U4 = 0d0
  !do a = 1, dim_list_virt_orb
  !  do i = 1, dim_list_act_orb
  !    do j = 1, dim_list_act_orb
  !      U4(i,a) = U4(i,a) + t2(j,a) * two_e_ints_iijj(i,j)
  !    enddo
  !  enddo
  !enddo

  call dgemm('N','N', dim_list_act_orb, dim_list_virt_orb, dim_list_act_orb, &
             1d0, two_e_ints_iijj, size(two_e_ints_iijj,1), &
                  t2, size(t2,1), &
             0d0, U4, size(U4,1))

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine U5_pccd(t2, X, U5)
  
  implicit none

  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(in)  :: X(dim_list_act_orb, dim_list_act_orb)
  double precision, intent(out) :: U5(dim_list_act_orb, dim_list_virt_orb)
  integer                       :: i,j,a

  ! U5(i,a) = \sum_{jb} t_j^a t_i^b v_{bb}^{jj}
  !         = \sum_j X(i,j) t_j^a
  !U5 = 0d0
  !do a = 1, dim_list_virt_orb
  !  do i = 1, dim_list_act_orb
  !    do j = 1, dim_list_act_orb
  !      U5(i,a) = U5(i,a) + t2(j,a) * X(i,j)
  !    enddo
  !  enddo
  !enddo

  call dgemm('N','N', dim_list_act_orb, dim_list_virt_orb, dim_list_act_orb, &
             1d0, X, size(X,1), t2, size(t2,1), 0d0, U5, size(U5,1))

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine X_pccd(t2,X)
  
  implicit none

  double precision, intent(in)  :: t2(dim_list_act_orb, dim_list_virt_orb)
  double precision, intent(out)  :: X(dim_list_act_orb, dim_list_act_orb)
  integer                       :: i,j,b

  ! X(i,j) = \sum_b t_i^b v_{bb}^{jj}
  !X = 0d0
  !do i = 1, dim_list_act_orb
  !  do j = 1, dim_list_act_orb
  !    do b = 1, dim_list_virt_orb
  !      X(i,j) = X(i,j) + t2(i,b) * two_e_ints_aaii(b,j)
  !    enddo
  !  enddo
  !enddo

  call dgemm('N','N', dim_list_act_orb, dim_list_act_orb, dim_list_virt_orb, &
             1d0, t2, size(t2,1), two_e_ints_aaii, size(two_e_ints_aaii,1), &
             0d0, X, size(X,1))

end  
#+END_SRC

* Naive way
#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine run_S1pCCD(epsilon,real_e)

  implicit none

  double precision, intent(in) :: epsilon, real_e
  double precision, allocatable :: list_crit(:)
  integer, allocatable :: list_key(:)
  integer, allocatable :: list_2d_key(:,:)
  integer :: i,j,a,b,p,q,nb_t2

  double precision, allocatable :: t2(:,:), residue(:,:), tmp_residue(:,:)
  double precision, allocatable :: U1(:), U2(:), U3(:,:), U4(:,:), U5(:,:), X(:,:)
  integer :: nb_iter
  double precision :: energy, max_residue, ta, tb, normalization_factor
  logical :: not_converged

  print*,''
  print*,'---run_S1pCCD_v2---'
  call wall_time(ta)
  
  allocate(t2(dim_list_act_orb, dim_list_virt_orb), residue(dim_list_act_orb, dim_list_virt_orb), tmp_residue(dim_list_act_orb, dim_list_virt_orb))
  allocate(U1(dim_list_virt_orb), U2(dim_list_act_orb), U3(dim_list_act_orb, dim_list_virt_orb))
  allocate(U4(dim_list_act_orb, dim_list_virt_orb), U5(dim_list_act_orb, dim_list_virt_orb), X(dim_list_act_orb, dim_list_act_orb))

  if (dim_list_act_orb == mo_num) then
     print*,'Set the mo classes before, abort'
     call abort
  endif

  allocate(list_crit(dim_list_act_orb * dim_list_virt_orb), list_key(dim_list_act_orb * dim_list_virt_orb))
  
  ! 2D -> 1D
  p = 1
  do a = 1, dim_list_virt_orb
    do i = 1, dim_list_act_orb
       if (sccd_method == 'bi_int') then
         list_crit(p) = dabs(two_e_ints_iiaa(i,a))
       elseif (sccd_method == 'guess_mp2') then
         list_crit(p) = dabs(two_e_ints_iiaa(i,a)/(2d0 * fock_matrix_aa(a) - 2d0 * fock_matrix_ii(i)))
       elseif (sccd_method == 'estimated_e') then
         list_crit(p) = dabs(two_e_ints_iiaa(i,a)**2/(2d0 * fock_matrix_aa(a) - 2d0 * fock_matrix_ii(i)))
       else
          print*,'Select the selection method, abort'
          call abort
       endif
       list_key(p) = p
       p = p + 1
    enddo
  enddo
  ! -, to change the ordering after the sort
  list_crit = - list_crit

  ! Sort by ascending order
  call dsort(list_crit, list_key, dim_list_act_orb * dim_list_virt_orb)
  
  ! Normalization of the biggest criterion
  normalization_factor = 1d0/list_crit(1) !(dim_list_act_orb * dim_list_virt_orb)

  ! Normalized and sorted list
  list_crit = list_crit * normalization_factor

  ! Number of selected elements
  !p = dim_list_act_orb * dim_list_virt_orb
  !do while ((list_crit(p) >= epsilon) .and. (p >= 1))
  !   p = p-1
  !enddo
  !nb_t2 = dim_list_act_orb * dim_list_virt_orb - p
  p = 1
  do while ((p <= dim_list_act_orb * dim_list_virt_orb) .and. (list_crit(min(p, dim_list_act_orb * dim_list_virt_orb)) >= epsilon))
    p = p + 1
  enddo
  nb_t2 = p - 1 

  ! Debug
  !do p = 1, dim_list_act_orb * dim_list_virt_orb
  !  print*, list_crit(p)
  !enddo
  !print*,'nb',nb_t2
  
  allocate(list_2d_key(nb_t2,2))

  ! Row indexes
  do p = 1, nb_t2
    !q = list_key(dim_list_act_orb * dim_list_virt_orb -p+1)
    q = list_key(p)
    call index_1d_to_2d(dim_list_act_orb, q, i, a)
    list_2d_key(p,1) = i
  enddo

  ! Column indexes
  do p = 1, nb_t2
    !q = list_key(dim_list_act_orb * dim_list_virt_orb -p+1)
    q = list_key(p)
    call index_1d_to_2d(dim_list_act_orb, q, i, a)
    list_2d_key(p,2) = a
  enddo

  ! Guess t2
  t2 = 0d0
  do p = 1, nb_t2
     i = list_2d_key(p,1)
     a = list_2d_key(p,2)
     t2(i,a) = two_e_ints_iiaa(i,a) &
        /(2d0 * fock_matrix_aa(a) - 2d0 * fock_matrix_ii(i))
     !print*,i,a,t2(i,a), t2(i,a)*normalization_factor
  enddo

  print*,''
  print*,'Epsilon:', epsilon
  print*,'     Nb iter        Energy                  Residue'

  nb_iter = 0
  not_converged = .True.
  
  do while (not_converged)
     
    ! tmp arrays
    call U1_pccd(t2, U1)
    call U2_pccd(t2, U2)
    call U3_pccd(t2, U3)
    call U4_pccd(t2, U4)
    call X_pccd(t2,X)
    call U5_pccd(t2, X, U5)

    ! Residue
    residue = 0d0

    do a = 1, dim_list_virt_orb
      do i = 1, dim_list_act_orb
         tmp_residue(i,a) = two_e_ints_iiaa(i,a) + 2d0*(fock_matrix_aa(a) - fock_matrix_ii(i) - U1(a) - U2(i)) * t2(i,a) &
              - 2d0*(2d0 * two_e_ints_iaia(i,a) - two_e_ints_aiia(a,i) - two_e_ints_aaii(a,i) * t2(i,a)) * t2(i,a) &
              + U3(i,a) + U4(i,a) + U5(i,a)
         !print*,'r',i,a,tmp_residue(i,a)
      enddo
    enddo

    ! Put to 0 the non selected amplitudes
    residue = 0d0
    do p = 1, nb_t2
      i = list_2d_key(p,1)
      a = list_2d_key(p,2)
      residue(i,a) = tmp_residue(i,a)
    enddo
    
    ! New amplitudes
    call update_amplitudes_pccd(residue, t2)
   
    nb_iter = nb_iter + 1

    ! New energy
    call pCCD_energy(t2,energy)

    ! max element in residue
    max_residue = 0d0
    do a = 1, dim_list_virt_orb
      do i = 1, dim_list_act_orb
        if (dabs(residue(i,a)) > max_residue) then
          max_residue = dabs(residue(i,a))
        endif
      enddo
    enddo
    
    print*, nb_iter, energy, max_residue

    ! Exit criterion
    if (max_residue < 1e-6) then
       not_converged = .False.
       print*,''
       print*,'******************************'
       write(*,'(A7,1pE15.5,I10,1pE15.5,1pE15.5,1pE15.5)'),' E_pCCD:', epsilon, nb_t2, dble(nb_t2)/dble(dim_list_virt_orb*dim_list_act_orb), &
                                                           energy, energy - real_e
       print*,'******************************'
    endif

    if (nb_iter >= 100) then
       print*,'#########################'
       print*,'   Convergence failed'
       print*,'#########################'
       exit
    endif

  enddo

  deallocate(t2,residue,tmp_residue,X,U1,U2,U3,U4,U5,list_2d_key,list_key,list_crit)

  call wall_time(tb)
  print*,'Time in run_S1pCCD:', tb-ta
  print*,''
  print*,'---End run_S1pCCD---'
  print*,''
  
end
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine index_1d_to_2d(n,k,i,j)

  implicit none

  integer, intent(in) :: n,k
  integer, intent(out) :: i,j

  ! k index in the list, list ordered column
  ! 1  p   ...
  ! 2  p+1 ...
  ! 3  p+2 ...
  ! :  :   ...  

  j = ((k-1)/n) + 1
  i = modulo((k-1),n) + 1
  
end
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine sort_2d_key(nb_t2, list_2d_key, list_t2)

  implicit none

  integer, intent(in)    :: nb_t2
  integer, intent(inout) :: list_2d_key(nb_t2,2)
  double precision, intent(inout) :: list_t2(nb_t2)
  integer, allocatable   :: tmp_list(:,:), index(:), key(:)
  double precision, allocatable :: tmp_t2(:)
  integer :: i,j,k,l

  allocate(tmp_list(nb_t2,2), index(nb_t2), key(nb_t2), tmp_t2(nb_t2))

  ! index to sort by (i,j) by ascending order (1,1), (1,2),...,(2,1), (2,2), ..., (n,n)
  do k = 1, nb_t2
    index(k) = (list_2d_key(k,1)-1) * dim_list_virt_orb + list_2d_key(k,2)
  enddo

  ! sort
  call isort(index, key, nb_t2)

  ! tmp array contening the sorted key 
  do k = 1, nb_t2
    l = key(k)
    tmp_list(k,1) = list_2d_key(l,1)
    tmp_list(k,2) = list_2d_key(l,2)
    tmp_t2(k) = list_t2(l)
  enddo

  ! and put them in the array
  do k = 1, nb_t2
    list_2d_key(k,1) = tmp_list(k,1)  
    list_2d_key(k,2) = tmp_list(k,2)
    list_t2(k) = tmp_t2(k)
  enddo
  
  deallocate(tmp_list,index,key,tmp_t2)
  
end
#+END_SRC

* Sparse way
#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine run_S2pCCD(epsilon,real_e)

  use mkl_spblas
  use iso_c_binding, only :c_int, c_double
  implicit none

  double precision, intent(in) :: epsilon, real_e
  double precision, allocatable :: list_crit(:)
  integer, allocatable :: list_key(:)
  integer, allocatable :: list_2d_key(:,:)
  integer :: i,j,a,b,p,q,nb_t2

  double precision, allocatable :: t2(:,:), residue(:,:), tmp_residue(:,:), list_t2(:), Id(:,:)
  double precision, allocatable :: U1(:), U2(:), U3(:,:), U4(:,:), U5(:,:), X(:,:)
  integer :: nb_iter, info
  double precision :: energy, max_residue, ta, tb, normalization_factor
  logical :: not_converged

  type(sparse_matrix_t) :: sp_t2
  type(matrix_descr) :: descr


  print*,''
  print*,'---run_S2pCCD_v2---'
  call wall_time(ta)
  
  allocate(t2(dim_list_act_orb, dim_list_virt_orb), residue(dim_list_act_orb, dim_list_virt_orb), tmp_residue(dim_list_act_orb, dim_list_virt_orb))
  allocate(U1(dim_list_virt_orb), U2(dim_list_act_orb), U3(dim_list_act_orb, dim_list_virt_orb))
  allocate(U4(dim_list_act_orb, dim_list_virt_orb), U5(dim_list_act_orb, dim_list_virt_orb), X(dim_list_act_orb, dim_list_act_orb))

  if (dim_list_act_orb == mo_num) then
     print*,'Set the mo classes before, abort'
     call abort
  endif

  allocate(list_crit(dim_list_act_orb * dim_list_virt_orb), list_key(dim_list_act_orb * dim_list_virt_orb))
  
  ! 2D -> 1D
  p = 1
  do a = 1, dim_list_virt_orb
    do i = 1, dim_list_act_orb
       if (sccd_method == 'bi_int') then
         list_crit(p) = dabs(two_e_ints_iiaa(i,a))
       elseif (sccd_method == 'guess_mp2') then
         list_crit(p) = dabs(two_e_ints_iiaa(i,a)/(2d0 * fock_matrix_aa(a) - 2d0 * fock_matrix_ii(i)))
       elseif (sccd_method == 'estimated_e') then
         list_crit(p) = dabs(two_e_ints_iiaa(i,a)**2/(2d0 * fock_matrix_aa(a) - 2d0 * fock_matrix_ii(i)))
       else
          print*,'Nothing to do, abort'
          call abort
       endif
       list_key(p) = p
       p = p + 1
    enddo
  enddo
  ! -, to change the ordering after the sort
  list_crit = - list_crit

  ! Sort by ascending order
  call dsort(list_crit, list_key, dim_list_act_orb * dim_list_virt_orb)
  
  ! Normalization of the biggest criterion
  normalization_factor = 1d0/list_crit(1) !(dim_list_act_orb * dim_list_virt_orb)

  ! Normalized and sorted list
  list_crit = list_crit * normalization_factor

  ! Number of selected elements
  p = 1
  do while ((p <= dim_list_act_orb * dim_list_virt_orb) .and. list_crit(min(p, dim_list_act_orb * dim_list_virt_orb)) >= epsilon)
    p = p + 1
  enddo
  nb_t2 = p - 1 

  ! Debug
  !do p = 1, dim_list_act_orb * dim_list_virt_orb
  !  print*, list_crit(p)
  !enddo
  !print*,'nb',nb_t2
  
  allocate(list_2d_key(nb_t2,2),list_t2(nb_t2))

  ! Row indexes
  do p = 1, nb_t2
    q = list_key(p)
    call index_1d_to_2d(dim_list_act_orb, q, i, a)
    list_2d_key(p,1) = i
  enddo

  ! Column indexes
  do p = 1, nb_t2
    q = list_key(p)
    call index_1d_to_2d(dim_list_act_orb, q, i, a)
    list_2d_key(p,2) = a
  enddo
      
  ! Guess t2
  t2 = 0d0
  do p = 1, nb_t2
     i = list_2d_key(p,1)
     a = list_2d_key(p,2)
     t2(i,a) = two_e_ints_iiaa(i,a) &
        /(2d0 * fock_matrix_aa(a) - 2d0 * fock_matrix_ii(i))
     !print*,i,a,t2(i,a), t2(i,a)*normalization_factor
     list_t2(p) =  two_e_ints_iiaa(i,a) &
        /(2d0 * fock_matrix_aa(a) - 2d0 * fock_matrix_ii(i))
  enddo

  ! Sort the t2 by ascending order of indexes
  call sort_2d_key(nb_t2, list_2d_key, list_t2)

!! ### TEST ###
!!  ! list of rows with non-zero elements
!!  list_row = 0
!!  do p = 1, nb_t2
!!    i = list_2d_key(p,1)
!!    tmp_list_row(i) = i
!!  enddo
!!
!!  nb_row = 0
!!  do i = 1, dim_list_act_orb
!!    if (tmp_list_row(i) /= 0) then
!!       nb_row = nb_row + 1
!!    endif
!!  enddo
!!
!!  allocate(list_row(nb_row), nb_val_row(nb_row), list_index_row(nb_row))
!!  j = 1
!!  do i = 1, dim_list_act_orb
!!    if (tmp_list_row(i) /= 0) then
!!      list_row(j) = tmp_list_row(i)
!!      j = j + 1
!!    endif
!!  enddo
!!
!!  ! Number of non-zero elements per row
!!  i = 1
!!  nb_val_row = 0
!!  do p = 1, nb_t2
!!    if (list_2d_key(p,1) == list_row(i)) then
!!      nb_val_row(i) = nb_val_row(i) + 1
!!    else
!!      i = i + 1
!!      nb_val_row(i) = nb_val_row(i) + 1
!!    endif
!!  enddo
!!
!!  ! Index of each row in the vector
!!  list_index_row(1) = 1
!!  do i = 2, nb_row
!!    list_index_row(i) = list_index_row(i-1) + nb_val_row(i-1)
!!  enddo
  
  ! debug
  !do p = 1, nb_t2
  !  i = list_2d_key(p,1)
  !  a = list_2d_key(p,2)
  !  print*, i,a
  !   print*,list_t2(p)
  !enddo
  !call abort

  ! info = mkl_sparse_d_create_coo(A, SPARSE_INDEX_BASE_ONE, rows, cols, nnz, row_indx, col_indx, values)
  !info = mkl_sparse_d_create_coo(sp_t2, SPARSE_INDEX_BASE_ONE, dim_list_act_orb, dim_list_virt_orb, nb_t2, list_2d_key(:,1), list_2d_key(:,2), list_t2)

  !allocate(Id(dim_list_virt_orb,dim_list_virt_orb))
  !Id = 0d0
  !do i = 1, dim_list_virt_orb
  !  Id(i,i) = 1d0
  !enddo
  !print*,'Before'
  !do i = 1, dim_list_act_orb
  !  write(*,'(100(1pE14.5))') t2(i,:)
  !enddo

  !descr%type = SPARSE_MATRIX_TYPE_GENERAL
  ! info = mkl_sparse_d_mm (operation, alpha, A, descr, layout, B, columns, ldb, beta, C, ldc)
  !info = mkl_sparse_d_mm (SPARSE_OPERATION_NON_TRANSPOSE, 1d0, sp_t2, descr, SPARSE_LAYOUT_ROW_MAJOR, Id, dim_list_virt_orb, size(Id,1), 0d0, t2, size(t2,1))
  !deallocate(Id)

  !print*,'After'
  !do i = 1, dim_list_act_orb
  !  write(*,'(100(1pE14.5))') t2(i,:)
  !enddo
  !return
  
  print*,''
  print*,'Epsilon:', epsilon
  print*,'     Nb iter        Energy                  Residue'

  nb_iter = 0
  not_converged = .True.
  
  do while (not_converged)

    t2 = 0d0
    do p = 1, nb_t2
      i = list_2d_key(p,1)
      a = list_2d_key(p,2)
      t2(i,a) = list_t2(p)
    enddo
      
    ! tmp arrays
    call U1_pccd(t2, U1)
    call U2_pccd(t2, U2)
    call U3_sp_pccd(nb_t2, list_2d_key, list_t2, U3)
    call U4_sp_pccd(nb_t2, list_2d_key, list_t2, U4)
    call X_sp_pccd(nb_t2, list_2d_key, list_t2, X)
    call U5_sp_pccd(nb_t2, list_2d_key, list_t2, X, U5)

    ! Residue
    tmp_residue = 0d0
    do a = 1, dim_list_virt_orb
      do i = 1, dim_list_act_orb
         tmp_residue(i,a) = two_e_ints_iiaa(i,a) + 2d0*(fock_matrix_aa(a) - fock_matrix_ii(i) - U1(a) - U2(i)) * t2(i,a) &
              - 2d0*(2d0 * two_e_ints_iaia(i,a) - two_e_ints_aiia(a,i) - two_e_ints_aaii(a,i) * t2(i,a)) * t2(i,a) &
              + U3(i,a) + U4(i,a) + U5(i,a)
         !print*,'r',i,a,tmp_residue(i,a)
      enddo
    enddo

    ! Put to 0 the non selected amplitudes
    residue = 0d0
    do p = 1, nb_t2
      i = list_2d_key(p,1)
      a = list_2d_key(p,2)
      residue(i,a) = tmp_residue(i,a)
    enddo
    
    ! New amplitudes
    call update_amplitudes_pccd(residue, t2)
   
    nb_iter = nb_iter + 1

    ! New energy
    call pCCD_energy(t2,energy)

    ! list of updated amplitudes
    do p = 1, nb_t2
      i = list_2d_key(p,1)
      a = list_2d_key(p,2)
      list_t2(p) = t2(i,a)
    enddo

    ! max element in residue
    max_residue = 0d0
    do a = 1, dim_list_virt_orb
      do i = 1, dim_list_act_orb
        if (dabs(residue(i,a)) > max_residue) then
          max_residue = dabs(residue(i,a))
        endif
      enddo
    enddo
    
    print*, nb_iter, energy, max_residue

    ! Exit criterion
    if (max_residue < 1e-6) then
       not_converged = .False.
       print*,''
       print*,'******************************'
       write(*,'(A7,1pE15.5,I10,1pE15.5,1pE15.5)'),' E_pCCD:', epsilon, nb_t2, energy, energy - real_e
       print*,'******************************' 
    endif

    if (nb_iter >= 100) then
       print*,'#########################'
       print*,'   Convergence failed'
       print*,'#########################'
       exit
    endif

  enddo

  deallocate(t2,residue,tmp_residue,X,U1,U2,U3,U4,U5,list_2d_key,list_key,list_crit,list_t2)

  call wall_time(tb)
  print*,'Time in run_S2pCCD:', tb-ta
  print*,''
  print*,'---End run_S2pCCD---'
  print*,''
  
end
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle idk.irp.f
program test_spblas

  use mkl_spblas
  use iso_c_binding, only :c_int, c_double
  
  implicit none

  integer, parameter :: rows = 4
  integer, parameter :: cols = 6

  integer, parameter :: nnz = 8

  integer :: ia(rows+1), ja(nnz), stat
  real :: values(nnz), x(6), y(4)

  type(sparse_matrix_t) :: a
  type(matrix_descr) :: descr


  ! Matrix example taken from: 
  ! https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format)
  !
  !     | 10  20  0  0  0  0 |
  ! A = |  0  30  0 40  0  0 |
  !     |  0   0 50 60 70  0 |
  !     |  0   0  0  0  0 80 | 
 
  ia = [1,3,5,8,9]
  ja = [1,2,2,4,3,4,5,6]
  values = [10, 20, 30, 40, 50, 60, 70, 80]

  stat = mkl_sparse_s_create_csr(a,SPARSE_INDEX_BASE_ONE,rows,cols,ia(1:4),ia(2:5),ja,values)
  print *, "stat create = ", stat

  descr%type = SPARSE_MATRIX_TYPE_GENERAL

  x = [1,1,1,1,1,1]
  stat = mkl_sparse_s_mv(SPARSE_OPERATION_NON_TRANSPOSE,1.0,a,descr,x,0.0,y)
  print *, "stat mv = ", stat

  print *, "result   = ", y
  print *, "expected = ", [30., 70., 180., 80.]

end program
#+END_SRC

** Routines
#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine U1_sp_pccd(nb_t2, nb_col, list_index_col, nb_val_col, list_t2, U1)
  
  implicit none

  ! in
  integer, intent(in)           :: nb_t2, nb_col
  double precision, intent(in)  :: list_t2(nb_t2)
  integer, intent(in)           :: list_index_col(nb_col), nb_val_col(nb_col)

  ! out
  double precision, intent(out) :: U1(dim_list_virt_orb)

  ! internal
  integer                       :: j,a

  ! U1(a) = \sum_j t_j^a v_{aa}^{jj}
  call abort ! need the good ordering of t2
  U1 = 0d0
  do a = 1, nb_col
    do j = list_index_col(a), list_index_col(a) + nb_val_col(a)
      U1(a) = U1(a) + list_t2(j) * two_e_ints_aaii(a,j)
    enddo
  enddo

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine list_U2_pccd(nb_t2, nb_row, list_index_row, nb_val_row,list_t2, U2)
  
  implicit none

  ! in
  integer, intent(in)           :: nb_t2, nb_row
  double precision, intent(in)  :: list_t2(nb_t2)
  integer, intent(in)           :: list_index_row(nb_row), nb_val_row(nb_row)

  ! out
  double precision, intent(out) :: U2(dim_list_act_orb)

  ! internal
  integer                       :: i,b

  ! U2(i) = \sum_b t_i^b v_{bb}^{ii}
  call abort ! need the good ordering of t2
  U2 = 0d0
  do i = 1, nb_row
    do b = list_index_row(i), list_index_row(i) + nb_val_row(i)
      U2(i) = U2(i) + list_t2(b) * two_e_ints_aaii(b,i)
    enddo
  enddo

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine U3_sp_pccd(nb_t2, list_2d_key, list_t2, U3)
  
  use mkl_spblas
  use iso_c_binding, only :c_int, c_double
  implicit none

  ! in
  integer, intent(in)           :: nb_t2
  integer, intent(in)           :: list_2d_key(nb_t2,2)
  double precision, intent(in)  :: list_t2(nb_t2)

  ! out
  double precision, intent(out) :: U3(dim_list_act_orb, dim_list_virt_orb)

  ! internal
  integer                       :: i,a,b,info
  type(sparse_matrix_t)         :: sp_t2
  type(matrix_descr)            :: descr

  ! U3(i,a) = \sum_b t_i^b v_{bb}^{aa}
  !U3 = 0d0
  !do a = 1, dim_list_virt_orb
  !  do i = 1, dim_list_act_orb
  !    do b = 1, dim_list_virt_orb
  !       U3(i,a) = U3(i,a) + t2(i,b) * two_e_ints_aabb(b,a)
  !    enddo
  !  enddo
  !enddo
  !call dgemm('N','N', dim_list_act_orb, dim_list_virt_orb, dim_list_virt_orb, &
  !           1d0, t2, size(t2,1), &
  !                two_e_ints_aabb, size(two_e_ints_aabb,1), &
  !           0d0, U3, size(U3,1))

  ! vec -> sparse COO
  info = mkl_sparse_d_create_coo(sp_t2, SPARSE_INDEX_BASE_ONE, dim_list_act_orb, dim_list_virt_orb, nb_t2, list_2d_key(:,1), list_2d_key(:,2), list_t2)
  descr%type = SPARSE_MATRIX_TYPE_GENERAL

  ! Sparse-dense matrix multiplication
  info = mkl_sparse_d_mm(SPARSE_OPERATION_NON_TRANSPOSE, 1d0, sp_t2, descr, SPARSE_LAYOUT_ROW_MAJOR, two_e_ints_aabb, dim_list_virt_orb, size(two_e_ints_aabb,1), 0d0, U3, size(U3,1))

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine U4_sp_pccd(nb_t2, list_2d_key, list_t2, U4)
  
  use mkl_spblas
  use iso_c_binding, only :c_int, c_double
  implicit none

  ! in
  integer, intent(in)           :: nb_t2
  integer, intent(in)           :: list_2d_key(nb_t2,2)
  double precision, intent(in)  :: list_t2(nb_t2)

  ! out
  double precision, intent(out) :: U4(dim_list_act_orb, dim_list_virt_orb)

  ! internal
  integer                       :: i,j,a,info
  double precision, allocatable :: two_e_ints_iijj_T(:,:), U4_T(:,:)
  type(sparse_matrix_t)         :: sp_t2
  type(matrix_descr)            :: descr

  allocate(two_e_ints_iijj_T(dim_list_act_orb, dim_list_act_orb),U4_T(dim_list_virt_orb, dim_list_act_orb))

  two_e_ints_iijj_T = transpose(two_e_ints_iijj)
  
  ! U4(i,a) = \sum_j t_j^a v_{ii}^{jj}
  !         = \sum_j v_{ii}^{jj} t_j^a
  
  !U4 = 0d0
  !do a = 1, dim_list_virt_orb
  !  do i = 1, dim_list_act_orb
  !    do j = 1, dim_list_act_orb
  !      U4(i,a) = U4(i,a) + t2(j,a) * two_e_ints_iijj(i,j)
  !    enddo
  !  enddo
  !enddo

  !call dgemm('N','N', dim_list_act_orb, dim_list_virt_orb, dim_list_act_orb, &
  !           1d0, two_e_ints_iijj, size(two_e_ints_iijj,1), &
  !                t2, size(t2,1), &
  !           0d0, U4, size(U4,1))

  ! vec -> sparse COO
  info = mkl_sparse_d_create_coo(sp_t2, SPARSE_INDEX_BASE_ONE, dim_list_act_orb, dim_list_virt_orb, nb_t2, list_2d_key(:,1), list_2d_key(:,2), list_t2)
  descr%type = SPARSE_MATRIX_TYPE_GENERAL

  ! Sparse-dense matrix multiplication
  info = mkl_sparse_d_mm(SPARSE_OPERATION_TRANSPOSE, 1d0, sp_t2, descr, SPARSE_LAYOUT_ROW_MAJOR, two_e_ints_iijj_T, dim_list_act_orb, size(two_e_ints_iijj_T,1), 0d0, U4_T, size(U4_T,1))

  U4 = transpose(U4_T)
  
  deallocate(two_e_ints_iijj_T,U4_T)
  
end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine U5_sp_pccd(nb_t2, list_2d_key, list_t2, X, U5)

  use mkl_spblas
  use iso_c_binding, only :c_int, c_double
  implicit none

  ! in
  integer, intent(in)           :: nb_t2
  double precision, intent(in)  :: list_t2(nb_t2)
  integer, intent(in)           :: list_2d_key(nb_t2,2)
  double precision, intent(in)  :: X(dim_list_act_orb, dim_list_act_orb)

  ! out
  double precision, intent(out) :: U5(dim_list_act_orb, dim_list_virt_orb)

  ! internal
  integer                       :: i,j,a,info
  double precision, allocatable :: X_T(:,:), U5_T(:,:)
  type(sparse_matrix_t)         :: sp_t2
  type(matrix_descr)            :: descr

  allocate(X_T(dim_list_act_orb,dim_list_act_orb), U5_T(dim_list_virt_orb, dim_list_act_orb))

  X_T = transpose(X)

  ! U5(i,a) = \sum_{jb} t_j^a t_i^b v_{bb}^{jj}
  !         = \sum_j X(i,j) t_j^a
  !U5 = 0d0
  !do a = 1, dim_list_virt_orb
  !  do i = 1, dim_list_act_orb
  !    do j = 1, dim_list_act_orb
  !      U5(i,a) = U5(i,a) + t2(j,a) * X(i,j)
  !    enddo
  !  enddo
  !enddo

  !call dgemm('N','N', dim_list_act_orb, dim_list_virt_orb, dim_list_act_orb, &
  !           1d0, X, size(X,1), t2, size(t2,1), 0d0, U5, size(U5,1))

  ! vec -> sparse COO
  info = mkl_sparse_d_create_coo(sp_t2, SPARSE_INDEX_BASE_ONE, dim_list_act_orb, dim_list_virt_orb, nb_t2, list_2d_key(:,1), list_2d_key(:,2), list_t2)
  descr%type = SPARSE_MATRIX_TYPE_GENERAL

  ! Sparse-dense matrix multiplication
  info = mkl_sparse_d_mm(SPARSE_OPERATION_TRANSPOSE, 1d0, sp_t2, descr, SPARSE_LAYOUT_ROW_MAJOR, X_T, dim_list_act_orb, size(X_T,1), 0d0, U5_T, size(U5_T,1))

  U5 = transpose(U5_T)

  deallocate(X_T,U5_T)

end  
#+END_SRC

#+BEGIN_SRC f90 :comments org :tangle pCCD_v2.irp.f
subroutine X_sp_pccd(nb_t2, list_2d_key, list_t2, X)

  use mkl_spblas
  use iso_c_binding, only :c_int, c_double
  implicit none

  ! in
  integer, intent(in)           :: nb_t2
  double precision, intent(in)  :: list_t2(nb_t2)
  integer, intent(in)           :: list_2d_key(nb_t2,2)

  ! out
  double precision, intent(out) :: X(dim_list_act_orb, dim_list_act_orb)

  ! internal
  integer                       :: i,j,b,info
  type(sparse_matrix_t)         :: sp_t2
  type(matrix_descr)            :: descr

  ! X(i,j) = \sum_b t_i^b v_{bb}^{jj}
  ! call dgemm('N','N', dim_list_act_orb, dim_list_act_orb, dim_list_virt_orb, &
  !            1d0, t2, size(t2,1), two_e_ints_aaii, size(two_e_ints_aaii,1), &
  !            0d0, X, size(X,1))

  ! vec -> sparse COO
  info = mkl_sparse_d_create_coo(sp_t2, SPARSE_INDEX_BASE_ONE, dim_list_act_orb, dim_list_virt_orb, nb_t2, list_2d_key(:,1), list_2d_key(:,2), list_t2)
  descr%type = SPARSE_MATRIX_TYPE_GENERAL

  ! Sparse-dense matrix multiplication
  info = mkl_sparse_d_mm(SPARSE_OPERATION_NON_TRANSPOSE, 1d0, sp_t2, descr, SPARSE_LAYOUT_ROW_MAJOR, two_e_ints_aaii, dim_list_act_orb, size(two_e_ints_aaii,1), 0d0, X, size(X,1))
   
end  
#+END_SRC
