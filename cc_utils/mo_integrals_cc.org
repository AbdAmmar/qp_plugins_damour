* mo two e integrals
** Space
*** F
#+BEGIN_SRC f90 :comments org :tangle mo_integrals_cc.irp.f
subroutine gen_f_space(det,n1,n2,list1,list2,f)

  implicit none

  integer, intent(in)           :: n1,n2
  integer, intent(in)           :: list1(n1),list2(n2)
  integer(bit_kind), intent(in) :: det(N_int,2)
  double precision, intent(out) :: f(n1,n2)

  double precision, allocatable :: tmp_F(:,:)
  integer                       :: i1,i2,idx1,idx2

  allocate(tmp_F(mo_num,mo_num))
  
  call get_fock_matrix_spin(det,1,tmp_F)

  !$OMP PARALLEL &
  !$OMP SHARED(tmp_F,f,n1,n2,list1,list2) &
  !$OMP PRIVATE(idx1,idx2,i1,i2)&
  !$OMP DEFAULT(NONE)
  !$OMP DO collapse(1)
  do i2 = 1, n2
    do i1 = 1, n1
      idx2 = list2(i2)
      idx1 = list1(i1)
      f(i1,i2) = tmp_F(idx1,idx2)
    enddo
  enddo
  !$OMP END DO
  !$OMP END PARALLEL

  deallocate(tmp_F)
  
end
#+end_src

*** V
#+BEGIN_SRC f90 :comments org :tangle mo_integrals_cc.irp.f
subroutine gen_v_space(n1,n2,n3,n4,list1,list2,list3,list4,v)

  implicit none

  integer, intent(in)           :: n1,n2,n3,n4
  integer, intent(in)           :: list1(n1),list2(n2),list3(n3),list4(n4)
  double precision, intent(out) :: v(n1,n2,n3,n4)

  integer                       :: i1,i2,i3,i4,idx1,idx2,idx3,idx4
  double precision              :: get_two_e_integral
  
  PROVIDE mo_two_e_integrals_in_map

  !$OMP PARALLEL &
  !$OMP SHARED(n1,n2,n3,n4,list1,list2,list3,list4,v,mo_integrals_map) &
  !$OMP PRIVATE(i1,i2,i3,i4,idx1,idx2,idx3,idx4)&
  !$OMP DEFAULT(NONE)
  !$OMP DO collapse(3)
  do i4 = 1, n4
    do i3 = 1, n3
      do i2 = 1, n2
        do i1 = 1, n1
          idx4 = list4(i4)
          idx3 = list3(i3)
          idx2 = list2(i2)
          idx1 = list1(i1)
          v(i1,i2,i3,i4) = get_two_e_integral(idx1,idx2,idx3,idx4,mo_integrals_map)
        enddo
      enddo
    enddo
  enddo
  !$OMP END DO
  !$OMP END PARALLEL
  
end
#+end_src

** Provider space
*** V
**** full
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v, (mo_num,mo_num,mo_num,mo_num)]

  implicit none

  integer          :: i,j,k,l
  double precision :: get_two_e_integral
  
  PROVIDE mo_two_e_integrals_in_map

  !$OMP PARALLEL &
  !$OMP SHARED(cc_space_v,mo_num,mo_integrals_map) &
  !$OMP PRIVATE(i,j,k,l) &
  !$OMP DEFAULT(NONE)
  
  !$OMP DO collapse(3)
  do l = 1, mo_num
    do k = 1, mo_num
      do j = 1, mo_num
        do i = 1, mo_num
          cc_space_v(i,j,k,l) = get_two_e_integral(i,j,k,l,mo_integrals_map)
        enddo
      enddo
    enddo
  enddo
  !$OMP END DO
  !$OMP END PARALLEL
       
END_PROVIDER
#+end_src
**** oooo
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_oooo, (cc_nOa, cc_nOa, cc_nOa, cc_nOa)]

  implicit none

  call gen_v_space(cc_nOa,cc_nOa,cc_nOa,cc_nOa, cc_list_occ,cc_list_occ,cc_list_occ,cc_list_occ, cc_space_v_oooo)

END_PROVIDER
#+end_src

**** vooo
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_vooo, (cc_nVa, cc_nOa, cc_nOa, cc_nOa)]

  implicit none

  call gen_v_space(cc_nVa,cc_nOa,cc_nOa,cc_nOa, cc_list_vir,cc_list_occ,cc_list_occ,cc_list_occ, cc_space_v_vooo)

END_PROVIDER
#+end_src

**** ovoo
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_ovoo, (cc_nOa, cc_nVa, cc_nOa, cc_nOa)]

  implicit none

  call gen_v_space(cc_nOa,cc_nVa,cc_nOa,cc_nOa, cc_list_occ,cc_list_vir,cc_list_occ,cc_list_occ, cc_space_v_ovoo)

END_PROVIDER
#+end_src

**** oovo
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_oovo, (cc_nOa, cc_nOa, cc_nVa, cc_nOa)]

  implicit none

  call gen_v_space(cc_nOa,cc_nOa,cc_nVa,cc_nOa, cc_list_occ,cc_list_occ,cc_list_vir,cc_list_occ, cc_space_v_oovo)

END_PROVIDER
#+end_src

**** ooov
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_ooov, (cc_nOa, cc_nOa, cc_nOa, cc_nVa)]

  implicit none

  call gen_v_space(cc_nOa,cc_nOa,cc_nOa,cc_nVa, cc_list_occ,cc_list_occ,cc_list_occ,cc_list_vir, cc_space_v_ooov)

END_PROVIDER
#+end_src

**** vvoo
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_vvoo, (cc_nVa, cc_nVa, cc_nOa, cc_nOa)]

  implicit none

  call gen_v_space(cc_nVa,cc_nVa,cc_nOa,cc_nOa, cc_list_vir,cc_list_vir,cc_list_occ,cc_list_occ, cc_space_v_vvoo)

END_PROVIDER
#+end_src

**** vovo
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_vovo, (cc_nVa, cc_nOa, cc_nVa, cc_nOa)]

  implicit none

  call gen_v_space(cc_nVa,cc_nOa,cc_nVa,cc_nOa, cc_list_vir,cc_list_occ,cc_list_vir,cc_list_occ, cc_space_v_vovo)

END_PROVIDER
#+end_src

**** voov
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_voov, (cc_nVa, cc_nOa, cc_nOa, cc_nVa)]

  implicit none

  call gen_v_space(cc_nVa,cc_nOa,cc_nOa,cc_nVa, cc_list_vir,cc_list_occ,cc_list_occ,cc_list_vir, cc_space_v_voov)

END_PROVIDER
#+end_src

**** ovvo
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_ovvo, (cc_nOa, cc_nVa, cc_nVa, cc_nOa)]

  implicit none

  call gen_v_space(cc_nOa,cc_nVa,cc_nVa,cc_nOa, cc_list_occ,cc_list_vir,cc_list_vir,cc_list_occ, cc_space_v_ovvo)

END_PROVIDER
#+end_src

**** ovov
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_ovov, (cc_nOa, cc_nVa, cc_nOa, cc_nVa)]

  implicit none

  call gen_v_space(cc_nOa,cc_nVa,cc_nOa,cc_nVa, cc_list_occ,cc_list_vir,cc_list_occ,cc_list_vir, cc_space_v_ovov)

END_PROVIDER
#+end_src

**** oovv
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_oovv, (cc_nOa, cc_nOa, cc_nVa, cc_nVa)]

  implicit none

  call gen_v_space(cc_nOa,cc_nOa,cc_nVa,cc_nVa, cc_list_occ,cc_list_occ,cc_list_vir,cc_list_vir, cc_space_v_oovv)

END_PROVIDER
#+end_src

**** vvvo
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_vvvo, (cc_nVa, cc_nVa, cc_nVa, cc_nOa)]

  implicit none

  call gen_v_space(cc_nVa,cc_nVa,cc_nVa,cc_nOa, cc_list_vir,cc_list_vir,cc_list_vir,cc_list_occ, cc_space_v_vvvo)

END_PROVIDER
#+end_src

**** vvov
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_vvov, (cc_nVa, cc_nVa, cc_nOa, cc_nVa)]

  implicit none

  call gen_v_space(cc_nVa,cc_nVa,cc_nOa,cc_nVa, cc_list_vir,cc_list_vir,cc_list_occ,cc_list_vir, cc_space_v_vvov)

END_PROVIDER
#+end_src

**** vovv
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_vovv, (cc_nVa, cc_nOa, cc_nVa, cc_nVa)]

  implicit none

  call gen_v_space(cc_nVa,cc_nOa,cc_nVa,cc_nVa, cc_list_vir,cc_list_occ,cc_list_vir,cc_list_vir, cc_space_v_vovv)

END_PROVIDER
#+end_src

**** ovvv
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_ovvv, (cc_nOa, cc_nVa, cc_nVa, cc_nVa)]

  implicit none

  call gen_v_space(cc_nOa,cc_nVa,cc_nVa,cc_nVa, cc_list_occ,cc_list_vir,cc_list_vir,cc_list_vir, cc_space_v_ovvv)

END_PROVIDER
#+end_src

**** vvvv
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_vvvv, (cc_nVa, cc_nVa, cc_nVa, cc_nVa)]

  implicit none

  call gen_v_space(cc_nVa,cc_nVa,cc_nVa,cc_nVa, cc_list_vir,cc_list_vir,cc_list_vir,cc_list_vir, cc_space_v_vvvv)

END_PROVIDER
#+end_src

**** ppqq
#+BEGIN_SRC f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_ppqq, (cc_n_mo, cc_n_mo)]

  implicit none

  BEGIN_DOC
  ! <pp|qq> integrals for general MOs (excepted core and deleted ones)
  END_DOC

  integer                       :: p,q
  double precision, allocatable :: tmp_v(:,:,:,:)

  allocate(tmp_v(cc_n_mo,cc_n_mo,cc_n_mo,cc_n_mo))

  call gen_v_space(cc_n_mo,cc_n_mo,cc_n_mo,cc_n_mo, cc_list_gen,cc_list_gen,cc_list_gen,cc_list_gen, tmp_v)
  
  do q = 1, cc_n_mo
    do p = 1, cc_n_mo
      cc_space_v_ppqq(p,q) = tmp_v(p,p,q,q)
    enddo
  enddo

  deallocate(tmp_v)

END_PROVIDER
#+END_SRC

**** aaii
#+BEGIN_SRC f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_aaii, (cc_nVa,cc_nOa)]

  implicit none

  BEGIN_DOC
  ! <aa|ii> integrals
  ! a: virtual MO
  ! i: occupied MO
  END_DOC

  integer :: a,i

  do i = 1, cc_nOa
    do a = 1, cc_nVa
      cc_space_v_aaii(a,i) = cc_space_v_vvoo(a,a,i,i)
    enddo
  enddo

  FREE cc_space_v_vvoo

END_PROVIDER
#+END_SRC

**** iiaa
#+BEGIN_SRC f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_iiaa, (cc_nOa,cc_nVa)]

  implicit none

  BEGIN_DOC
  ! <ii|aa> integrals
  ! a: virtual MO
  ! i: occupied MO
  END_DOC

  integer :: a,i

  do a = 1, cc_nVa
    do i = 1, cc_nOa
      cc_space_v_iiaa(i,a) = cc_space_v_oovv(i,i,a,a)
    enddo
  enddo

  FREE cc_space_v_oovv

END_PROVIDER
#+END_SRC

**** iijj
#+BEGIN_SRC f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_iijj, (cc_nOa,cc_nOa)]

  implicit none

  BEGIN_DOC
  ! <ii|jj> integrals
  ! i,j: occupied MO
  END_DOC

  integer :: i,j

  do j = 1, cc_nOa
    do i = 1, cc_nOa
      cc_space_v_iijj(i,j) = cc_space_v_oooo(i,i,j,j)
    enddo
  enddo

  FREE cc_space_v_oooo

END_PROVIDER
#+END_SRC

**** aabb
#+BEGIN_SRC f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_aabb, (cc_nVa,cc_nVa)]

  implicit none

  BEGIN_DOC
  ! <aa|bb> integrals
  ! a,b: virtual MO
  END_DOC

  integer :: a,b

  do b = 1, cc_nVa
    do a = 1, cc_nVa
      cc_space_v_aabb(a,b) = cc_space_v_vvvv(a,a,b,b)
    enddo
  enddo

  FREE cc_space_v_vvvv
  
END_PROVIDER
#+END_SRC

**** iaia
#+BEGIN_SRC f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_iaia, (cc_nOa,cc_nVa)]

  implicit none

  BEGIN_DOC
  ! <ia|ia> integrals
  ! a: virtual MO
  ! i: occupied MO
  END_DOC

  integer :: a,i

  do a = 1, cc_nVa
    do i = 1, cc_nOa
      cc_space_v_iaia(i,a) = cc_space_v_ovov(i,a,i,a)
    enddo
  enddo

  FREE cc_space_v_ovov

END_PROVIDER
#+END_SRC

**** iaai
#+BEGIN_SRC f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_iaai, (cc_nOa,cc_nVa)]

  implicit none

  BEGIN_DOC
  ! <ia|ai> integrals
  ! a: virtual MO
  ! i: inactive MO
  END_DOC

  integer :: a,i

  do a = 1, cc_nVa
    do i = 1, cc_nOa
      cc_space_v_iaai(i,a) = cc_space_v_ovvo(i,a,a,i)
    enddo
  enddo

  FREE cc_space_v_ovvo

END_PROVIDER
#+END_SRC

**** aiia
#+BEGIN_SRC f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_v_aiia, (cc_nVa,cc_nOa)]

  implicit none

  BEGIN_DOC
  ! <ai|ia> integrals
  ! a: virtual MO
  ! i: inactive MO
  END_DOC

  integer :: a,i

  do i = 1, cc_nOa
    do a = 1, cc_nVa
      cc_space_v_aiia(a,i) = cc_space_v_voov(a,i,i,a)
    enddo
  enddo

  FREE cc_space_v_voov

END_PROVIDER
#+END_SRC

*** W
**** oovv
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_w_oovv, (cc_nOa, cc_nOa, cc_nVa, cc_nVa)]

  implicit none

  double precision, allocatable :: tmp_v(:,:,:,:)
  integer :: i,j,a,b

  allocate(tmp_v(cc_nOa,cc_nOa,cc_nVa,cc_nVa))
  
  call gen_v_space(cc_nOa,cc_nOa,cc_nVa,cc_nVa, cc_list_occ,cc_list_occ,cc_list_vir,cc_list_vir, tmp_v)

  !$OMP PARALLEL &
  !$OMP SHARED(cc_nVa,cc_nOa,tmp_v,cc_space_w_oovv) &
  !$OMP PRIVATE(i,j,a,b)&
  !$OMP DEFAULT(NONE)
  !$OMP DO
  do b = 1, cc_nVa
    do a = 1, cc_nVa
      do j = 1, cc_nOa
        do i = 1, cc_nOa
          cc_space_w_oovv(i,j,a,b) = 2d0 * tmp_v(i,j,a,b) - tmp_v(j,i,a,b)
        enddo
      enddo
    enddo
  enddo
  !$OMP END DO
  !$OMP END PARALLEL

  deallocate(tmp_v)

END_PROVIDER
#+end_src

**** vvoo
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_w_vvoo, (cc_nVa, cc_nVa, cc_nOa, cc_nOa)]

  implicit none

  double precision, allocatable :: tmp_v(:,:,:,:)
  integer :: i,j,a,b

  allocate(tmp_v(cc_nVa,cc_nVa,cc_nOa,cc_nOa))
  
  call gen_v_space(cc_nVa,cc_nVa,cc_nOa,cc_nOa, cc_list_vir,cc_list_vir,cc_list_occ,cc_list_occ, tmp_v)

  !$OMP PARALLEL &
  !$OMP SHARED(cc_nVa,cc_nOa,tmp_v,cc_space_w_vvoo) &
  !$OMP PRIVATE(i,j,a,b)&
  !$OMP DEFAULT(NONE)
  !$OMP DO
  do j = 1, cc_nOa
    do i = 1, cc_nOa
      do b = 1, cc_nVa
        do a = 1, cc_nVa
          cc_space_w_vvoo(a,b,i,j) = 2d0 * tmp_v(a,b,i,j) - tmp_v(b,a,i,j)
        enddo
      enddo
    enddo
  enddo
  !$OMP END DO
  !$OMP END PARALLEL

  deallocate(tmp_v)

END_PROVIDER
#+end_src

*** F
**** F_oo
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_f_oo, (cc_nOa, cc_nOa)]

  implicit none

  call gen_f_space(psi_det(1,1,1), cc_nOa,cc_nOa, cc_list_occ,cc_list_occ, cc_space_f_oo)

END_PROVIDER
#+end_src

**** F_ov
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_f_ov, (cc_nOa, cc_nVa)]

  implicit none

  call gen_f_space(psi_det(1,1,1), cc_nOa,cc_nVa, cc_list_occ,cc_list_vir, cc_space_f_ov)

END_PROVIDER
#+end_src

**** F_vo
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_f_vo, (cc_nVa, cc_nOa)]

  implicit none

  call gen_f_space(psi_det(1,1,1), cc_nVa,cc_nOa, cc_list_vir,cc_list_occ, cc_space_f_vo)

END_PROVIDER
#+end_src

**** F_vv
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_f_vv, (cc_nVa, cc_nVa)]

  implicit none

  call gen_f_space(psi_det(1,1,1), cc_nVa,cc_nVa, cc_list_vir,cc_list_vir, cc_space_f_vv)

END_PROVIDER
#+end_src

**** F_o
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_f_o, (cc_nOa)]

  implicit none

  integer :: i

  do i = 1, cc_nOa
    cc_space_f_o(i) = cc_space_f_oo(i,i)
  enddo

END_PROVIDER
#+end_src

**** F_v
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, cc_space_f_v, (cc_nVa)]

  implicit none

  integer :: i

  do i = 1, cc_nVa
    cc_space_f_v(i) = cc_space_f_vv(i,i)
  enddo

END_PROVIDER
#+end_src

** Spin
*** Shift
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
subroutine shift_idx_spin(s,n_S,shift)

  implicit none

  BEGIN_DOC
  ! Shift for the partitionning alpha/beta of the spin orbitals
  ! n_S(1): number of spin alpha in the correspondong list
  ! n_S(2): number of spin beta in the correspondong list
  END_DOC

  integer, intent(in)  :: s, n_S(2)
  integer, intent(out) :: shift

  if (s == 1) then
    shift = 0
  else
    shift = n_S(1)
  endif
  
end
#+end_src

*** F
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
subroutine gen_f_spin(det, n1,n2, n1_S,n2_S, list1,list2, dim1,dim2, f)

  implicit none

  BEGIN_DOC
  ! Compute the Fock matrix corresponding to two lists of spin orbitals.
  ! Ex: occ/occ, occ/vir,...
  END_DOC
  
  integer(bit_kind), intent(in) :: det(N_int,2)
  integer, intent(in)           :: n1,n2, n1_S(2), n2_S(2)
  integer, intent(in)           :: list1(n1,2), list2(n2,2)
  integer, intent(in)           :: dim1, dim2
  
  double precision, intent(out) :: f(dim1, dim2)

  double precision, allocatable :: tmp_F(:,:)
  integer                       :: i,j, idx_i,idx_j,i_shift,j_shift
  integer                       :: tmp_i,tmp_j
  integer                       :: si,sj,s

  allocate(tmp_F(mo_num,mo_num))
  
  do sj = 1, 2
    call shift_idx_spin(sj,n2_S,j_shift)
    do si = 1, 2
      call shift_idx_spin(si,n1_S,i_shift)
      s = si + sj

      if (s == 2 .or. s == 4) then
        call get_fock_matrix_spin(det,sj,tmp_F)
      else
        do j = 1, mo_num
          do i = 1, mo_num
            tmp_F(i,j) = 0d0
          enddo
        enddo
      endif

      do tmp_j = 1, n2_S(sj)
        j = list2(tmp_j,sj)
        idx_j = tmp_j + j_shift
        do tmp_i = 1, n1_S(si)
          i = list1(tmp_i,si)
          idx_i = tmp_i + i_shift
          f(idx_i,idx_j) = tmp_F(i,j)
        enddo
      enddo

    enddo
  enddo
  
  deallocate(tmp_F)
  
end
#+end_src

*** Get F
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
subroutine get_fock_matrix_spin(det,s,f)

  implicit none

  BEGIN_DOC
  ! Fock matrix alpha or beta of an arbitrary det
  END_DOC
  
  integer(bit_kind), intent(in) :: det(N_int,2)
  integer, intent(in)           :: s
  
  double precision, intent(out) :: f(mo_num,mo_num)
  
  integer                       :: p,q,i,s1,s2
  integer(bit_kind)             :: res(N_int,2)
  logical                       :: ok
  double precision              :: mo_two_e_integral

  if (s == 1) then
    s1 = 1
    s2 = 2
  else
    s1 = 2
    s2 = 1
  endif
  
  !$OMP PARALLEL &
  !$OMP SHARED(f,mo_num,s1,s2,N_int,det,mo_one_e_integrals) &
  !$OMP PRIVATE(p,q,ok,i,res)&
  !$OMP DEFAULT(NONE)
  !$OMP DO collapse(1)
  do q = 1, mo_num
    do p = 1, mo_num
      f(p,q) = mo_one_e_integrals(p,q)
      do i = 1, mo_num
        call apply_hole(det, s1, i, res, ok, N_int)
        if (ok) then
          f(p,q) = f(p,q) + mo_two_e_integral(p,i,q,i) - mo_two_e_integral(p,i,i,q)
        endif
      enddo
      do i = 1, mo_num
        call apply_hole(det, s2, i, res, ok, N_int)
        if (ok) then
          f(p,q) = f(p,q) + mo_two_e_integral(p,i,q,i)
        endif
      enddo
    enddo
  enddo
  !$OMP END DO
  !$OMP END PARALLEL
    
end
#+end_src

*** V
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
subroutine gen_v_spin(n1,n2,n3,n4, n1_S,n2_S,n3_S,n4_S, list1,list2,list3,list4, dim1,dim2,dim3,dim4, v)

  implicit none

   BEGIN_DOC
  ! Compute the bi electronic integrals corresponding to four lists of spin orbitals.
  ! Ex: occ/occ/occ/occ, occ/vir/occ/vir, ...
  END_DOC

  integer, intent(in)           :: n1,n2,n3,n4,n1_S(2),n2_S(2),n3_S(2),n4_S(2)
  integer, intent(in)           :: list1(n1,2), list2(n2,2), list3(n3,2), list4(n4,2)
  integer, intent(in)           :: dim1, dim2, dim3, dim4
  double precision, intent(out) :: v(dim1,dim2,dim3,dim4)

  double precision              :: mo_two_e_integral
  integer                       :: i,j,k,l,idx_i,idx_j,idx_k,idx_l
  integer                       :: i_shift,j_shift,k_shift,l_shift
  integer                       :: tmp_i,tmp_j,tmp_k,tmp_l
  integer                       :: si,sj,sk,sl,s

  PROVIDE cc_space_v
  
  !$OMP PARALLEL &
  !$OMP SHARED(cc_space_v,n1_S,n2_S,n3_S,n4_S,list1,list2,list3,list4,v) &
  !$OMP PRIVATE(s,si,sj,sk,sl,i_shift,j_shift,k_shift,l_shift, &
  !$OMP i,j,k,l,idx_i,idx_j,idx_k,idx_l,&
  !$OMP tmp_i,tmp_j,tmp_k,tmp_l)&
  !$OMP DEFAULT(NONE)
  
  do sl = 1, 2
    call shift_idx_spin(sl,n4_S,l_shift)
    do sk = 1, 2
      call shift_idx_spin(sk,n3_S,k_shift)
      do sj = 1, 2
        call shift_idx_spin(sj,n2_S,j_shift)
        do si = 1, 2
          call shift_idx_spin(si,n1_S,i_shift)
    
          s = si+sj+sk+sl
          ! <aa||aa> or <bb||bb>
          if (s == 4 .or. s == 8) then
            !$OMP DO collapse(3)
            do tmp_l = 1, n4_S(sl)
              do tmp_k = 1, n3_S(sk)
                do tmp_j = 1, n2_S(sj)
                  do tmp_i = 1, n1_S(si)  
                    l = list4(tmp_l,sl)
                    idx_l = tmp_l + l_shift
                    k = list3(tmp_k,sk)
                    idx_k = tmp_k + k_shift
                    j = list2(tmp_j,sj)
                    idx_j = tmp_j + j_shift
                    i = list1(tmp_i,si)
                    idx_i = tmp_i + i_shift
                       !v(idx_i,idx_j,idx_k,idx_l) = mo_two_e_integral(i,j,k,l) - mo_two_e_integral(j,i,k,l)
                       v(idx_i,idx_j,idx_k,idx_l) = cc_space_v(i,j,k,l) - cc_space_v(j,i,k,l)
                  enddo
                enddo
              enddo
            enddo
            !$OMP END DO
            
          ! <ab||ab> or <ba||ba>
          elseif (si == sk .and. sj == sl) then
            !$OMP DO collapse(3)
            do tmp_l = 1, n4_S(sl)
              do tmp_k = 1, n3_S(sk)
                do tmp_j = 1, n2_S(sj)
                  do tmp_i = 1, n1_S(si)  
                    l = list4(tmp_l,sl)
                    idx_l = tmp_l + l_shift
                    k = list3(tmp_k,sk)
                    idx_k = tmp_k + k_shift
                    j = list2(tmp_j,sj)
                    idx_j = tmp_j + j_shift
                    i = list1(tmp_i,si)
                    idx_i = tmp_i + i_shift
                       !v(idx_i,idx_j,idx_k,idx_l) = mo_two_e_integral(i,j,k,l)
                       v(idx_i,idx_j,idx_k,idx_l) = cc_space_v(i,j,k,l)
                  enddo
                enddo
              enddo
            enddo
            !$OMP END DO
            
          ! <ab||ba> or <ba||ab>
          elseif (si == sl .and. sj == sk) then
            !$OMP DO collapse(3)
            do tmp_l = 1, n4_S(sl)
              do tmp_k = 1, n3_S(sk)
                do tmp_j = 1, n2_S(sj)
                  do tmp_i = 1, n1_S(si)  
                    l = list4(tmp_l,sl)
                    idx_l = tmp_l + l_shift
                    k = list3(tmp_k,sk)
                    idx_k = tmp_k + k_shift
                    j = list2(tmp_j,sj)
                    idx_j = tmp_j + j_shift
                    i = list1(tmp_i,si)
                    idx_i = tmp_i + i_shift
                       !v(idx_i,idx_j,idx_k,idx_l) = - mo_two_e_integral(j,i,k,l)
                       v(idx_i,idx_j,idx_k,idx_l) = - cc_space_v(j,i,k,l)
                  enddo
                enddo
              enddo
            enddo
            !$OMP END DO
          else
             !$OMP DO collapse(3)
            do tmp_l = 1, n4_S(sl)
              do tmp_k = 1, n3_S(sk)
                do tmp_j = 1, n2_S(sj)
                  do tmp_i = 1, n1_S(si)  
                    l = list4(tmp_l,sl)
                    idx_l = tmp_l + l_shift
                    k = list3(tmp_k,sk)
                    idx_k = tmp_k + k_shift
                    j = list2(tmp_j,sj)
                    idx_j = tmp_j + j_shift
                    i = list1(tmp_i,si)
                    idx_i = tmp_i + i_shift
                       v(idx_i,idx_j,idx_k,idx_l) = 0d0
                  enddo
                enddo
              enddo
            enddo
            !$OMP END DO
          endif
          
        enddo
      enddo
    enddo
  enddo
  !$OMP END PARALLEL
  
end
#+end_src

*** V_3idx
#+begin_src f90 :comments org :tangle mo_integrals_cc.irp.f
subroutine gen_v_spin_3idx(n1,n2,n3,n4, idx_l, n1_S,n2_S,n3_S,n4_S, list1,list2,list3,list4, dim1,dim2,dim3, v_l)

  implicit none

   BEGIN_DOC
  ! Compute the bi electronic integrals corresponding to four lists of spin orbitals.
  ! Ex: occ/occ/occ/occ, occ/vir/occ/vir, ...
  END_DOC

  integer, intent(in)           :: n1,n2,n3,n4,idx_l,n1_S(2),n2_S(2),n3_S(2),n4_S(2)
  integer, intent(in)           :: list1(n1,2), list2(n2,2), list3(n3,2), list4(n4,2)
  integer, intent(in)           :: dim1, dim2, dim3
  double precision, intent(out) :: v_l(dim1,dim2,dim3)

  double precision              :: mo_two_e_integral
  integer                       :: i,j,k,l,idx_i,idx_j,idx_k
  integer                       :: i_shift,j_shift,k_shift,l_shift
  integer                       :: tmp_i,tmp_j,tmp_k,tmp_l
  integer                       :: si,sj,sk,sl,s

  PROVIDE cc_space_v

  if (idx_l <= n4_S(1)) then
    sl = 1
  else
    sl = 2
  endif
  call shift_idx_spin(sl,n4_S,l_shift)
  tmp_l = idx_l - l_shift
  l = list4(tmp_l,sl)
  
  !$OMP PARALLEL &
  !$OMP SHARED(l,sl,idx_l,cc_space_v,n1_S,n2_S,n3_S,n4_S,list1,list2,list3,list4,v_l) &
  !$OMP PRIVATE(s,si,sj,sk,i_shift,j_shift,k_shift, &
  !$OMP i,j,k,idx_i,idx_j,idx_k,&
  !$OMP tmp_i,tmp_j,tmp_k)&
  !$OMP DEFAULT(NONE)
  
  do sk = 1, 2
    call shift_idx_spin(sk,n3_S,k_shift)
    do sj = 1, 2
      call shift_idx_spin(sj,n2_S,j_shift)
      do si = 1, 2
        call shift_idx_spin(si,n1_S,i_shift)
  
        s = si+sj+sk+sl
        ! <aa||aa> or <bb||bb>
        if (s == 4 .or. s == 8) then
          !$OMP DO collapse(2)
          do tmp_k = 1, n3_S(sk)
            do tmp_j = 1, n2_S(sj)
              do tmp_i = 1, n1_S(si)  
                k = list3(tmp_k,sk)
                idx_k = tmp_k + k_shift
                j = list2(tmp_j,sj)
                idx_j = tmp_j + j_shift
                i = list1(tmp_i,si)
                idx_i = tmp_i + i_shift
                   !v(idx_i,idx_j,idx_k,idx_l) = mo_two_e_integral(i,j,k,l) - mo_two_e_integral(j,i,k,l)
                   v_l(idx_i,idx_j,idx_k) = cc_space_v(i,j,k,l) - cc_space_v(j,i,k,l)
              enddo
            enddo
          enddo
          !$OMP END DO
          
        ! <ab||ab> or <ba||ba>
        elseif (si == sk .and. sj == sl) then
          !$OMP DO collapse(2)
          do tmp_k = 1, n3_S(sk)
            do tmp_j = 1, n2_S(sj)
              do tmp_i = 1, n1_S(si)  
                k = list3(tmp_k,sk)
                idx_k = tmp_k + k_shift
                j = list2(tmp_j,sj)
                idx_j = tmp_j + j_shift
                i = list1(tmp_i,si)
                idx_i = tmp_i + i_shift
                   !v(idx_i,idx_j,idx_k,idx_l) = mo_two_e_integral(i,j,k,l)
                   v_l(idx_i,idx_j,idx_k) = cc_space_v(i,j,k,l)
              enddo
            enddo
          enddo
          !$OMP END DO
          
        ! <ab||ba> or <ba||ab>
        elseif (si == sl .and. sj == sk) then
          !$OMP DO collapse(2)
          do tmp_k = 1, n3_S(sk)
            do tmp_j = 1, n2_S(sj)
              do tmp_i = 1, n1_S(si)  
                k = list3(tmp_k,sk)
                idx_k = tmp_k + k_shift
                j = list2(tmp_j,sj)
                idx_j = tmp_j + j_shift
                i = list1(tmp_i,si)
                idx_i = tmp_i + i_shift
                   !v(idx_i,idx_j,idx_k,idx_l) = - mo_two_e_integral(j,i,k,l)
                   v_l(idx_i,idx_j,idx_k) = - cc_space_v(j,i,k,l)
              enddo
            enddo
          enddo
          !$OMP END DO
        else
          !$OMP DO collapse(2)
          do tmp_k = 1, n3_S(sk)
            do tmp_j = 1, n2_S(sj)
              do tmp_i = 1, n1_S(si)  
                k = list3(tmp_k,sk)
                idx_k = tmp_k + k_shift
                j = list2(tmp_j,sj)
                idx_j = tmp_j + j_shift
                i = list1(tmp_i,si)
                idx_i = tmp_i + i_shift
                   v_l(idx_i,idx_j,idx_k) = 0d0
              enddo
            enddo
          enddo
          !$OMP END DO
        endif
        
      enddo
    enddo
  enddo
  !$OMP END PARALLEL
  
end
#+end_src

* Old
** vcc
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc, (dim_list_inact_virt_no_core_orb, dim_list_inact_virt_no_core_orb, dim_list_inact_virt_no_core_orb, dim_list_inact_virt_no_core_orb)]

  implicit none

  BEGIN_DOC
  ! my <pq|rs> integrals for inactive + virtual orbitals
  END_DOC

  integer :: p,q,r,s,i
  integer :: pa, qa, ra, sa
  integer :: n(2), shift(2), n_max
  integer :: idx_p, idx_q, idx_r, idx_s, pc,qc,rc,sc
  integer, allocatable :: list_orb(:,:)

  ! function
  double precision :: get_two_e_integral

  PROVIDE mo_two_e_integrals_in_map

  n = (/n_inact_orb,n_virt_orb/)
  shift = (/0,n_inact_orb/)
  n_max = max(n_inact_orb,n_virt_orb)
  allocate(list_orb(n_max,2))
  
  do i = 1, n(1)
    list_orb(i,1) = list_inact(i)
  enddo
  do i = 1, n(2)
    list_orb(i,2) = list_virt(i)
  enddo
  do sc = 1, 2
    do rc = 1, 2
      do qc = 1, 2
        do pc = 1, 2
          do sa = 1, n(sc)
            s = list_orb(sa,sc)
            idx_s = sa + shift(sc)
            do ra = 1, n(rc)
              r = list_orb(ra,rc)
              idx_r = ra + shift(rc)
              do qa = 1, n(qc)
                q = list_orb(qa,qc)
                idx_q = qa + shift(qc)
                do pa = 1, n(pc)
                  p = list_orb(pa,pc)
                  idx_p = pa + shift(pc)
                   
                  vcc(idx_p,idx_q,idx_r,idx_s) = get_two_e_integral(p,q,r,s,mo_integrals_map)
                  
                enddo
              enddo
            enddo
          enddo
        enddo
      enddo
    enddo
  enddo

  deallocate(list_orb)

END_PROVIDER
#+END_SRC

** ppqq
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_ppqq, (dim_list_inact_virt_no_core_orb, dim_list_inact_virt_no_core_orb)]

  implicit none

  BEGIN_DOC
  ! my <pp|qq> integrals for inactive + virtual MOs
  END_DOC

  integer :: p,q
  double precision :: get_two_e_integral

  do q = 1, dim_list_inact_virt_no_core_orb
    do p = 1, dim_list_inact_virt_no_core_orb
      vcc_ppqq(p,q) = vcc(p,p,q,q)
      !print*,p,q,get_two_e_integral(p,p,q,q,mo_integrals_map), vcc_ppqq(p,q)
    enddo
  enddo

END_PROVIDER
#+END_SRC

** aaii
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_aaii, (dim_list_virt_orb, dim_list_inact_orb)]

  implicit none

  BEGIN_DOC
  ! my <aa|ii> integrals for inactive + virtual MOs
  ! a: virtual MO
  ! i: inactive MO
  END_DOC

  integer :: a,tmp_a,i
  double precision :: get_two_e_integral

  do i = 1, dim_list_inact_orb
    do a = 1, dim_list_virt_orb
      tmp_a = a + dim_list_inact_orb
      vcc_aaii(a,i) = vcc(tmp_a,tmp_a,i,i)
      !print*,a,i,get_two_e_integral(tmp_a,tmp_a,i,i,mo_integrals_map), vcc_aaii(a,i)
    enddo
  enddo

END_PROVIDER
#+END_SRC

** iiaa
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_iiaa, (dim_list_inact_orb, dim_list_virt_orb)]

  implicit none

  BEGIN_DOC
  ! my <ii|aa> integrals for inactive + virtual MOs
  ! a: virtual MO
  ! i: inactive MO
  END_DOC

  integer :: a,tmp_a,i
  double precision :: get_two_e_integral

  do a = 1, dim_list_virt_orb
    tmp_a = a + dim_list_inact_orb
    do i = 1, dim_list_inact_orb
      vcc_iiaa(i,a) = vcc(i,i,tmp_a,tmp_a)
      !print*,i,a,get_two_e_integral(i,i,tmp_a,tmp_a,mo_integrals_map), vcc_iiaa(i,a)
    enddo
  enddo

END_PROVIDER
#+END_SRC

** iijj
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_iijj, (dim_list_inact_orb, dim_list_inact_orb)]

  implicit none

  BEGIN_DOC
  ! my <ii|jj> integrals for inactive MOs
  ! i,j: inactive MO
  END_DOC

  integer :: i,j
  double precision :: get_two_e_integral

  do j = 1, dim_list_inact_orb
    do i = 1, dim_list_inact_orb
      vcc_iijj(i,j) = vcc(i,i,j,j)
      !print*,i,j,get_two_e_integral(i,i,j,j,mo_integrals_map), vcc_iijj(i,j)
    enddo
  enddo

END_PROVIDER
#+END_SRC

** aabb
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_aabb, (dim_list_virt_orb, dim_list_virt_orb)]

  implicit none

  BEGIN_DOC
  ! my <aa|bb> integrals for  virtual MOs
  ! a,b: virtual MO
  END_DOC

  integer :: a,b,tmp_a,tmp_b
  double precision :: get_two_e_integral

  do b = 1, dim_list_virt_orb
    tmp_b = b + dim_list_inact_orb
    do a = 1, dim_list_virt_orb
      tmp_a = a + dim_list_inact_orb
      vcc_aabb(a,b) = vcc(tmp_a,tmp_a,tmp_b,tmp_b)
      !print*,a,b,get_two_e_integral(tmp_a,tmp_a,tmp_b,tmp_b,mo_integrals_map), vcc_aabb(a,b)
    enddo
  enddo
END_PROVIDER
#+END_SRC

** iaia
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_iaia, (dim_list_inact_orb, dim_list_virt_orb)]

  implicit none

  BEGIN_DOC
  ! my <ia|ia> integrals for inactive + virtual MOs
  ! a: virtual MO
  ! i: inactive MO
  END_DOC

  integer :: a,tmp_a,i
  double precision :: get_two_e_integral

  do a = 1, dim_list_virt_orb
    tmp_a = a + dim_list_inact_orb
    do i = 1, dim_list_inact_orb
      vcc_iaia(i,a) = vcc(i,tmp_a,i,tmp_a)
      !print*,i,a,get_two_e_integral(i,tmp_a,i,tmp_a,mo_integrals_map), vcc_iaia(i,a)
    enddo
  enddo

END_PROVIDER
#+END_SRC

** iaai
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_iaai, (dim_list_inact_orb, dim_list_virt_orb)]

  implicit none

  BEGIN_DOC
  ! my <ia|ai> integrals for inactive + virtual MOs
  ! a: virtual MO
  ! i: inactive MO
  END_DOC

  integer :: a,tmp_a,i
  double precision :: get_two_e_integral

  do a = 1, dim_list_virt_orb
    tmp_a = a + dim_list_inact_orb
    do i = 1, dim_list_inact_orb
      vcc_iaai(i,a) = vcc(i,tmp_a,tmp_a,i)
      !print*,i,a,get_two_e_integral(i,tmp_a,tmp_a,i,mo_integrals_map), vcc_iaai(i,a)
    enddo
  enddo

END_PROVIDER
#+END_SRC

** aiia
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_aiia, (dim_list_virt_orb, dim_list_inact_orb)]

  implicit none

  BEGIN_DOC
  ! my <ai|ia> integrals for inactive + virtual MOs
  ! a: virtual MO
  ! i: inactive MO
  END_DOC

  integer :: a,tmp_a,i
  double precision :: get_two_e_integral

  do i = 1, dim_list_inact_orb
    do a = 1, dim_list_virt_orb
      tmp_a = a + dim_list_inact_orb
      vcc_aiia(a,i) = vcc(tmp_a,i,i,tmp_a)
      !print*,a,i,get_two_e_integral(tmp_a,i,i,tmp_a,mo_integrals_map), vcc_aiia(a,i)
    enddo
  enddo

END_PROVIDER
#+END_SRC

** integrals

*** vcc_oooo
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_oooo, (dim_list_inact_orb, dim_list_inact_orb, dim_list_inact_orb, dim_list_inact_orb)]

  implicit none

  BEGIN_DOC
  ! my <ij|kl> integrals
  ! i,j,k,l: inactive spatial MOs
  END_DOC

  integer :: i,j,k,l
  integer :: nO

  nO = dim_list_inact_orb

  do l = 1, nO
    do k = 1, nO
      do j = 1, nO
        do i = 1, nO
          vcc_oooo(i,j,k,l) = vcc(i,j,k,l)
        enddo
      enddo
    enddo
  enddo

END_PROVIDER
#+END_SRC

*** vcc_oovv
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_oovv, (dim_list_inact_orb, dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb)]

  implicit none

  BEGIN_DOC
  ! my <ij|ab> integrals
  ! i,j: inactive spatial MOs
  ! a,b: virtual spatial MOs
  END_DOC

  integer :: i,j,k,l,a,b,tmp_a,tmp_b
  integer :: nO, nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  do b = 1, nV
    tmp_b = b + nO
    do a = 1, nV
      tmp_a = a + nO
      do j = 1, nO
        do i = 1, nO
          vcc_oovv(i,j,a,b) = vcc(i,j,tmp_a,tmp_b)
        enddo
      enddo
    enddo
  enddo

END_PROVIDER
#+END_SRC

*** vcc_vvoo
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_vvoo, (dim_list_virt_orb, dim_list_virt_orb, dim_list_inact_orb, dim_list_inact_orb)]

  implicit none

  BEGIN_DOC
  ! my <ab|ij> integrals
  ! i,j: inactive spatial MOs
  ! a,b: virtual spatial MOs
  END_DOC

  integer :: i,j,k,l,a,b,tmp_a,tmp_b
  integer :: nO, nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  do j = 1, nO
    do i = 1, nO
      do b = 1, nV
        tmp_b = b + nO
        do a = 1, nV
          tmp_a = a + nO
          vcc_vvoo(a,b,i,j) = vcc(tmp_a,tmp_b,i,j)
        enddo
      enddo
    enddo
  enddo

END_PROVIDER
#+END_SRC

*** vcc_ovvo
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_ovvo, (dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb, dim_list_inact_orb)]

  implicit none

  BEGIN_DOC
  ! my <ia|bj> integrals
  ! i,j: inactive spatial MOs
  ! a,b: virtual spatial MOs
  END_DOC

  integer :: i,j,k,l,a,b,tmp_a,tmp_b
  integer :: nO, nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  do j = 1, nO
    do b = 1, nV
      tmp_b = b + nO
      do a = 1, nV
        tmp_a = a + nO
        do i = 1, nO
          vcc_ovvo(i,a,b,j) = vcc(i,tmp_a,tmp_b,j)
        enddo
      enddo
    enddo
  enddo

END_PROVIDER
#+END_SRC

*** vcc_ovov
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_ovov, (dim_list_inact_orb, dim_list_virt_orb, dim_list_inact_orb, dim_list_virt_orb)]

  implicit none

  BEGIN_DOC
  ! my <ia|jb> integrals
  ! i,j: inactive spatial MOs
  ! a,b: virtual spatial MOs
  END_DOC

  integer :: i,j,k,l,a,b,tmp_a,tmp_b
  integer :: nO, nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb
  
  do b = 1, nV
    tmp_b = b + nO
    do j = 1, nO
      do a = 1, nV
        tmp_a = a + nO
        do i = 1, nO
          vcc_ovov(i,a,j,b) = vcc(i,tmp_a,j,tmp_b)
        enddo
      enddo
    enddo
  enddo

END_PROVIDER
#+END_SRC

*** vcc_vvvv
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_vvvv, (dim_list_virt_orb, dim_list_virt_orb, dim_list_virt_orb, dim_list_virt_orb)]

  implicit none

  BEGIN_DOC
  ! my <ab|ij> integrals
  ! i,j: inactive spatial MOs
  ! a,b: virtual spatial MOs
  END_DOC

  integer :: a,b,c,d,tmp_a,tmp_b,tmp_c,tmp_d
  integer :: nO, nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  do d = 1, nV
    tmp_d = d + nO
    do c = 1, nV
      tmp_c = c + nO
      do b = 1, nV
        tmp_b = b + nO
        do a = 1, nV
          tmp_a = a + nO
          vcc_vvvv(a,b,c,d) = vcc(tmp_a,tmp_b,tmp_c,tmp_d)
        enddo
      enddo
    enddo
  enddo

END_PROVIDER
#+END_SRC

*** vcc_vooo
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_vooo, (dim_list_virt_orb, dim_list_inact_orb, dim_list_inact_orb, dim_list_inact_orb)]

  implicit none

  BEGIN_DOC
  ! my <ai|jk> integrals
  ! i,j,k: inactive spatial MOs
  ! a: virtual spatial MO
  END_DOC

  integer :: a,b,c,d,tmp_a,tmp_b,tmp_c,tmp_d,i,j,k
  integer :: nO, nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  do k = 1, nO
    do j = 1, nO
      do i = 1, nO
         do a = 1, nV
           tmp_a = a + nO
          vcc_vooo(a,i,j,k) = vcc(tmp_a,i,j,k)
        enddo
      enddo
    enddo
  enddo

END_PROVIDER
#+END_SRC

*** vcc_ovoo
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_ovoo, (dim_list_inact_orb, dim_list_virt_orb, dim_list_inact_orb, dim_list_inact_orb)]

  implicit none

  BEGIN_DOC
  ! my <ia|jk> integrals
  ! i,j,k: inactive spatial MOs
  ! a: virtual spatial MO
  END_DOC

  integer :: a,b,c,d,tmp_a,tmp_b,tmp_c,tmp_d,i,j,k
  integer :: nO, nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  do k = 1, nO
    do j = 1, nO
      do a = 1, nv
        tmp_a = a + nO
        do i = 1, nO
          vcc_ovoo(i,a,j,k) = vcc(i,tmp_a,j,k)
        enddo
      enddo
    enddo
  enddo

END_PROVIDER
#+END_SRC

*** vcc_oovo
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_oovo, (dim_list_inact_orb, dim_list_inact_orb, dim_list_virt_orb, dim_list_inact_orb)]

  implicit none

  BEGIN_DOC
  ! my <ij|ak> integrals
  ! i,j,k: inactive spatial MOs
  ! a: virtual spatial MO
  END_DOC

  integer :: a,b,c,d,tmp_a,tmp_b,tmp_c,tmp_d,i,j,k
  integer :: nO, nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  do k = 1, nO
    do a = 1, nv
      tmp_a = a + nO
      do j = 1, nO
        do i = 1, nO
          vcc_oovo(i,j,a,k) = vcc(i,j,tmp_a,k)
        enddo
      enddo
    enddo
  enddo

END_PROVIDER
#+END_SRC

*** vcc_ooov
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_ooov, (dim_list_inact_orb, dim_list_inact_orb, dim_list_inact_orb, dim_list_virt_orb)]

  implicit none

  BEGIN_DOC
  ! my <ij|ka> integrals
  ! i,j,k: inactive spatial MOs
  ! a: virtual spatial MO
  END_DOC

  integer :: a,b,c,d,tmp_a,tmp_b,tmp_c,tmp_d,i,j,k
  integer :: nO, nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  do a = 1, nv
    tmp_a = a + nO
    do k = 1, nO
      do j = 1, nO
        do i = 1, nO
          vcc_ooov(i,j,k,a) = vcc(i,j,k,tmp_a)
        enddo
      enddo
    enddo
  enddo

END_PROVIDER
#+END_SRC

*** wcc_oovv 
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, wcc_oovv, (dim_list_inact_orb, dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb)]

  implicit none

  BEGIN_DOC
  ! my <ij||ab> integrals
  ! i,j: inactive spatial MOs
  ! a,b: virtual spatial MOs
  END_DOC

  integer :: i,j,k,l,a,b,tmp_a,tmp_b
  integer :: nO, nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  do b = 1, nV
    tmp_b = b + nO
    do a = 1, nV
      tmp_a = a + nO
      do j = 1, nO
        do i = 1, nO
          wcc_oovv(i,j,a,b) = 2d0 * vcc(i,j,tmp_a,tmp_b) - vcc(i,j,tmp_b,tmp_a)
        enddo
      enddo
    enddo
  enddo

END_PROVIDER
#+END_SRC

*** wcc_vvoo
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, wcc_vvoo, (dim_list_virt_orb, dim_list_virt_orb, dim_list_inact_orb, dim_list_inact_orb)]

  implicit none

  BEGIN_DOC
  ! my <ab||ij> integrals
  ! i,j: inactive spatial MOs
  ! a,b: virtual spatial MOs
  END_DOC

  integer :: i,j,k,l,a,b,tmp_a,tmp_b
  integer :: nO, nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  do j = 1, nO
    do i = 1, nO
      do b = 1, nV
        tmp_b = b + nO
        do a = 1, nV
          tmp_a = a + nO
          wcc_vvoo(a,b,i,j) = 2d0 * vcc(tmp_a,tmp_b,i,j) - vcc(tmp_a,tmp_b,j,i) 
        enddo
      enddo
    enddo
  enddo

END_PROVIDER
#+END_SRC

*** vcc_ovvv
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_ovvv, (dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb, dim_list_virt_orb)]

  implicit none

  BEGIN_DOC
  ! my <ia|bc> integrals
  ! i: inactive spatial MO
  ! a,b,c: virtual spatial MOs
  END_DOC

  integer :: a,b,c,d,tmp_a,tmp_b,tmp_c,tmp_d,i
  integer :: nO, nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  do c = 1, nV
    tmp_c = c + nO
    do b = 1, nV
      tmp_b = b + nO
      do a = 1, nV
        tmp_a = a + nO
        do i = 1, nO
          vcc_ovvv(i,a,b,c) = vcc(i,tmp_a,tmp_b,tmp_c)
        enddo
      enddo
    enddo
  enddo

END_PROVIDER
#+END_SRC

*** vcc_vovv
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_vovv, (dim_list_virt_orb, dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb)]

  implicit none

  BEGIN_DOC
  ! my <ai|bc> integrals
  ! i: inactive spatial MO
  ! a,b,c: virtual spatial MOs
  END_DOC

  integer :: a,b,c,d,tmp_a,tmp_b,tmp_c,tmp_d,i
  integer :: nO, nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  do c = 1, nV
    tmp_c = c + nO
    do b = 1, nV
      tmp_b = b + nO
      do i = 1, nO
        do a = 1, nV
          tmp_a = a + nO
          vcc_vovv(a,i,b,c) = vcc(tmp_a,i,tmp_b,tmp_c)
        enddo
      enddo
    enddo
  enddo

END_PROVIDER
#+END_SRC

*** vcc_vvov
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_vvov, (dim_list_virt_orb, dim_list_virt_orb, dim_list_inact_orb, dim_list_virt_orb)]

  implicit none

  BEGIN_DOC
  ! my <ab|ic> integrals
  ! i: inactive spatial MO
  ! a,b,c: virtual spatial MOs
  END_DOC

  integer :: a,b,c,d,tmp_a,tmp_b,tmp_c,tmp_d,i
  integer :: nO, nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  do c = 1, nV
    tmp_c = c + nO
    do i = 1, nO
      do b = 1, nV
      tmp_b = b + nO
        do a = 1, nV
          tmp_a = a + nO
          vcc_vvov(a,b,i,c) = vcc(tmp_a,tmp_b,i,tmp_c)
        enddo
      enddo
    enddo
  enddo

END_PROVIDER
#+END_SRC

*** vcc_vvvo
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_vvvo, (dim_list_virt_orb, dim_list_virt_orb, dim_list_virt_orb, dim_list_inact_orb)]

  implicit none

  BEGIN_DOC
  ! my <ab|ci> integrals
  ! i: inactive spatial MO
  ! a,b,c: virtual spatial MOs
  END_DOC

  integer :: a,b,c,d,tmp_a,tmp_b,tmp_c,tmp_d,i
  integer :: nO, nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  do i = 1, nO
    do c = 1, nV
      tmp_c = c + nO
      do b = 1, nV
        tmp_b = b + nO
        do a = 1, nV
          tmp_a = a + nO
          vcc_vvvo(a,b,c,i) = vcc(tmp_a,tmp_b,tmp_c,i)
        enddo
      enddo
    enddo
  enddo

END_PROVIDER
#+END_SRC

*** vcc_vvov
#+BEGIN_SRC f90 :comments org :notangle mo_integrals_cc.irp.f
BEGIN_PROVIDER [double precision, vcc_voov, (dim_list_virt_orb, dim_list_inact_orb, dim_list_inact_orb, dim_list_virt_orb)]

  implicit none

  BEGIN_DOC
  ! my <ai|jb> integrals
  ! i,j: inactive spatial MOs
  ! a,b: virtual spatial MOs
  END_DOC

  integer :: a,b,c,d,tmp_a,tmp_b,tmp_c,tmp_d,i,j
  integer :: nO, nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  do b = 1, nV
    tmp_b = b + nO
    do j = 1, nO
      do i = 1, nO
        do a = 1, nV
          tmp_a = a + nO
          vcc_voov(a,i,j,b) = vcc(tmp_a,i,j,tmp_b)
        enddo
      enddo
    enddo
  enddo

END_PROVIDER
#+END_SRC

