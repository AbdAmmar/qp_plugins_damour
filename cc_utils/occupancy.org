* N spin orb
#+begin_src f90 :comments org :tangle occupancy.irp.f
subroutine extract_n_spin(det,n)

  implicit none

  BEGIN_DOC
  ! Returns the number of occupied alpha, occupied beta, virtual alpha, virtual beta spin orbitals
  ! in det without counting the core and deleted orbitals in the format n(nOa,nOb,nVa,nVb)
  END_DOC

  integer(bit_kind), intent(in) :: det(N_int,2)
  
  integer, intent(out)          :: n(4)
  
  integer(bit_kind)             :: res(N_int,2)
  integer                       :: i, si
  logical                       :: ok, is_core, is_del

  ! Init
  n = 0

  ! Loop over the spin
  do si = 1, 2
    do i = 1, mo_num
      call apply_hole(det, si, i, res, ok, N_int)
      
      ! in core ?
      if (is_core(i)) cycle
      ! in del ?
      if (is_del(i)) cycle
      
      if (ok) then
        ! particle
        n(si) = n(si) + 1
      else
        ! hole
        n(si+2) = n(si+2) + 1
      endif
    enddo
  enddo

  print*,n(1),n(2),n(3),n(4)

end  
#+end_src

* List_orb
** Spin
#+begin_src f90 :comments org :tangle occupancy.irp.f
subroutine extract_list_orb_spin(det,nO_m,nV_m,list_occ,list_vir)

  implicit none

  BEGIN_DOC
  ! Returns the the list of occupied alpha/beta, virtual alpha/beta spin orbitals
  ! size(nO_m,1) must be max(nOa,nOb) and size(nV_m,1) must be max(nVa,nVb)
  END_DOC
  
  integer, intent(in)           :: nO_m, nV_m
  integer(bit_kind), intent(in) :: det(N_int,2)
  
  integer, intent(out)          :: list_occ(nO_m,2), list_vir(nV_m,2)
  
  integer(bit_kind)             :: res(N_int,2)
  integer                       :: i, si, idx_o, idx_v, idx_i, idx_b
  logical                       :: ok, is_core, is_del

  list_occ = 0
  list_vir = 0

  ! List of occ/vir alpha/beta

  ! occ alpha -> list_occ(:,1)
  ! occ beta -> list_occ(:,2)
  ! vir alpha -> list_vir(:,1)
  ! vir beta -> list_vir(:,2)
  
  ! Loop over the spin 
  do si = 1, 2
    ! tmp idx
    idx_o = 1
    idx_v = 1
    do i = 1, mo_num
      call apply_hole(det, si, i, res, ok, N_int)

      ! in core ?
      if (is_core(i)) cycle
      ! in del ?
      if (is_del(i)) cycle
            
      if (ok) then
        ! particle
        list_occ(idx_o,si) = i
        idx_o = idx_o + 1
      else
        ! hole
        list_vir(idx_v,si) = i
        idx_v = idx_v + 1
      endif
    enddo
  enddo

end
#+end_src

** Space
#+begin_src f90 :comments org :tangle occupancy.irp.f
subroutine extract_list_orb_space(det,nO,nV,list_occ,list_vir)

  implicit none

  BEGIN_DOC
  ! Returns the the list of occupied and virtual alpha spin orbitals
  END_DOC
  
  integer, intent(in)           :: nO, nV
  integer(bit_kind), intent(in) :: det(N_int,2)
  
  integer, intent(out)          :: list_occ(nO), list_vir(nV)
  
  integer(bit_kind)             :: res(N_int,2)
  integer                       :: i, si, idx_o, idx_v, idx_i, idx_b
  logical                       :: ok, is_core, is_del

  list_occ = 0
  list_vir = 0

  ! List of occ/vir alpha

  ! occ alpha -> list_occ(:,1)
  ! vir alpha -> list_vir(:,1)

  ! tmp idx
  idx_o = 1
  idx_v = 1
  do i = 1, mo_num
    call apply_hole(det, 1, i, res, ok, N_int)

    ! in core ?
    if (is_core(i)) cycle
    ! in del ?
    if (is_del(i)) cycle

    if (ok) then
      ! particle
      list_occ(idx_o) = i
      idx_o = idx_o + 1
    else
      ! hole
      list_vir(idx_v) = i
      idx_v = idx_v + 1
    endif
  enddo

end
#+end_src

** is_core
#+begin_src f90 :comments org :tangle occupancy.irp.f
function is_core(i)

  implicit none

  BEGIN_DOC
  ! True if the orbital i is a core orbital
  END_DOC

  integer, intent(in) :: i
  logical             :: is_core

  integer             :: j

  ! Init
  is_core = .False.

  ! Search
  do j = 1, dim_list_core_orb
    if (list_core(j) == i) then
      is_core = .True.
      exit
    endif
  enddo

end
#+end_src

** is_del
#+begin_src f90 :comments org :tangle occupancy.irp.f
function is_del(i)

  implicit none

  BEGIN_DOC
  ! True if the orbital i is a deleted orbital
  END_DOC

  integer, intent(in) :: i
  logical             :: is_del

  integer             :: j

  ! Init
  is_del = .False.

  ! Search
  do j = 1, dim_list_core_orb
    if (list_core(j) == i) then
      is_del = .True.
      exit
    endif
  enddo

end
#+end_src

* Providers
** N orb
#+BEGIN_SRC f90 :comments org :tangle occupancy.irp.f
 BEGIN_PROVIDER [integer, cc_nO]
&BEGIN_PROVIDER [integer, cc_nV]

  implicit none

  BEGIN_DOC
  ! Number of occupied and virtual orbitals without core and deleted ones
  END_DOC

  integer :: n_spin(4)

  ! Extract number of occ/vir alpha/beta spin orbitals
  call extract_n_spin(psi_det(1,1,1),n_spin)

  cc_nO = n_spin(1)
  cc_nV = n_spin(3)

END_PROVIDER
#+end_src

** List orb
#+BEGIN_SRC f90 :comments org :tangle occupancy.irp.f
 BEGIN_PROVIDER [integer, cc_list_occ, (cc_nO)]
&BEGIN_PROVIDER [integer, cc_list_vir, (cc_nV)]

  implicit none

  BEGIN_DOC
  ! List of occupied and virtual orbitals without core and deleted ones
  END_DOC

  call extract_list_orb_space(psi_det(1,1,1),cc_nO,cc_nV,cc_list_occ,cc_list_vir)

END_PROVIDER
#+end_src
