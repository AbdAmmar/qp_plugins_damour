* DIIS
https://hal.archives-ouvertes.fr/hal-02492983/document
Maxime Chupin, Mi-Song Dupuy, Guillaume Legendre, Eric Séré. Convergence analysis of adaptive
DIIS algorithms witerh application to electronic ground state calculations. 
ESAIM: Mathematical Modelling and Numerical Analysis, EDP Sciences, 2021, 55 (6), pp.2785 - 2825. 10.1051/m2an/2021069ff.ffhal-02492983v5

t_{k+1} = g(t_k)
err_k = f(t_k) = t_{k+1} - t_k

m_k = min(m,k)
m maximal depth
t_{k+1} = \sum_{i=0}^{m_k} c_i^k g(t_{k-m_k+i})
\sum_{i=0}^{m_k} c_i^k = 1

b_{ij}^k = < err^{k-m_k+j}, err^{k-m_k+i} >

(b   -1) ( c^k    ) = (  0 )
(-1   0) ( \lambda)   ( -1 )

lambda is used to put the constraint \sum_{i=0}^{m_k} c_i^k = 1

In: t_0, err_0, m
err_0 = g(t_0)
k = 0
m_k = 0
while ||err_k|| > CC
  A.x=b
  t_{k+1} = \sum_{i=0}^{m_k} c_i^k g(t_{k-m_k+i})
  err_{k+1} = f(t_{k+1})
  m_{k+1} = min(m_k+1,m)
  k = k +1
end

* Code
#+begin_src f90 :comments org :tangle diis.irp.f 
subroutine diis_cc(err,all_err,t,all_t,sze,m,iter)

  implicit none

  BEGIN_DOC
  ! DIIS. Take the error vectors and the amplitudes of the previous
  ! iterations to compute the new amplitudes
  END_DOC
  
  ! {err_i}_{i=1}^{m_it} -> B -> c
  ! {t_i}_{i=1}^{m_it}, c, {err_i}_{i=1}^{m_it} -> t_{m_it+1}

  integer, intent(in)             :: m,iter,sze
  double precision, intent(in)    :: err(sze), all_err(sze,m)
  double precision, intent(in)    :: all_t(sze,m)
  double precision, intent(out)   :: t(sze)
  double precision, allocatable   :: B(:,:), c(:), zero(:)
  integer                         :: m_iter
  integer                         :: i,j,k
  integer                         :: info
  integer, allocatable            :: ipiv(:)
  
  m_iter = min(m,iter)
  print*,'m_iter',m_iter
  allocate(B(m_iter+1,m_iter+1), c(m_iter), zero(m_iter+1))
  allocate(ipiv(m+1))

  ! B(i,j) =  < err(iter-m_iter+j),err(iter-m_iter+i) > ! iter-m_iter will be zero for us
  B = 0d0
  do j = 1, m_iter
    do i = 1, m_iter
      do k = 1, sze
        ! the errors of the ith iteration are in all_err(:,m+1-i)
        B(i,j) = B(i,j) + all_err(k,m+1-i) * all_err(k,m+1-j)
      enddo
    enddo
  enddo
  do i = 1, m_iter
    B(i,m_iter+1) = -1
  enddo
  do j = 1, m_iter
    B(m_iter+1,j) = -1
  enddo
  ! Debug
  !print*,'B'
  !do i = 1, m_iter+1
  !  write(*,'(100(F10.6))') B(i,:)
  !enddo

  ! (0 0 .... 0 -1)
  zero = 0d0
  zero(m_iter+1) = -1d0

  ! Solve B.c = zero
  call dgesv(m_iter+1, 1, B, size(B,1), ipiv, zero, size(zero,1), info)
  if (info /= 0) then
    print*,'DIIS error in dgesv:', info
    call abort
  endif
  ! c corresponds to the m_iter first solutions
  c = zero(1:m_iter)
  ! Debug
  !print*,'c',c
  !print*,'all_t' 
  !do i = 1, m
  !  write(*,'(100(F10.6))') all_t(:,i)
  !enddo
  !print*,'all_err' 
  !do i = 1, m
  !  write(*,'(100(F10.6))') all_err(:,i)
  !enddo

  ! update T 
  t(:) = 0d0
  do i = 1, m_iter
    t(:) = t(:) + c(i) * (all_t(:,m+1-i) + all_err(:,m+1-i))
  enddo

  !print*,'new t',t

  deallocate(ipiv,B,c,zero)

end
#+end_src

** Update all err
#+begin_src f90 :comments org :tangle diis.irp.f
subroutine update_all_err(err,all_err,sze,m,iter)

  implicit none

  BEGIN_DOC
  ! Shift all the err vectors of the previous iterations to add the new one
  ! The last err vector is placed in the last position and all the others are
  ! moved toward the first one.
  END_DOC

  integer, intent(in)             :: m, iter, sze
  double precision, intent(in)    :: err(sze)
  double precision, intent(inout) :: all_err(sze,m)
  integer                         :: i,j
  integer                         :: m_iter

  m_iter = min(m,iter)

  ! Shift
  do i = 1, m-1
    all_err(:,i) = all_err(:,i+1)
  enddo
  ! Debug
  !print*,'shift err'
  !do i = 1, m
  !  print*,i, all_err(:,i)
  !enddo

  ! New
  all_err(:,m) = err(:)

  ! Debug
  !print*,'Updated err'
  !do i = 1, m
  !  print*,i, all_err(:,i)
  !enddo

end
#+end_src

** Update all t
#+begin_src f90 :comments org :tangle diis.irp.f
subroutine update_all_t(t,all_t,sze,m,iter)

  implicit none

  BEGIN_DOC
  ! Shift all the t vectors of the previous iterations to add the new one
  ! The last t vector is placed in the last position and all the others are
  ! moved toward the first one.
  END_DOC

  integer, intent(in)             :: m, iter, sze
  double precision, intent(in)    :: t(sze)
  double precision, intent(inout) :: all_t(sze,m)
  integer                         :: i,j
  integer                         :: m_iter

  m_iter = min(m,iter)

  ! Shift
  do i = 1, m-1
    all_t(:,i) = all_t(:,i+1)
  enddo

  ! New
  all_t(:,m) = t(:)

  ! Debug
  !print*,'Updated t'
  !do i = 1, m
  !  print*,i, all_t(:,i)
  !enddo

end
#+end_src

** Err
*** Err1
#+begin_src f90 :comments org :tangle diis.irp.f
subroutine compute_err1(nO,nV,f_o,f_v,r1,err1)

  implicit none

  BEGIN_DOC
  ! Compute the error vector for the t1
  END_DOC

  integer, intent(in)           :: nO, nV
  double precision, intent(in)  :: f_o(nO), f_v(nV), r1(nO,nV)
  
  double precision, intent(out) :: err1(nO,nV)

  integer                       :: i,a
  
  do a = 1, nV
    do i = 1, nO
      err1(i,a) = - r1(i,a) / (f_o(i) - f_v(a))
    enddo
  enddo

end
#+end_src

*** Err2
#+begin_src f90 :comments org :tangle diis.irp.f
subroutine compute_err2(nO,nV,f_o,f_v,r2,err2)

  implicit none

  BEGIN_DOC
  ! Compute the error vector for the t2
  END_DOC

  integer, intent(in)           :: nO, nV
  double precision, intent(in)  :: f_o(nO), f_v(nV), r2(nO,nO,nV,nV)
  
  double precision, intent(out) :: err2(nO,nO,nV,nV)

  integer                       :: i,j,a,b

  do b = 1, nV
    do a = 1, nV
      do j = 1, nO
        do i = 1, nO       
          err2(i,j,a,b) = - r2(i,j,a,b) / (f_o(i) + f_o(j) - f_v(a) - f_v(b))
        enddo
      enddo
    enddo
  enddo

end
#+end_src
