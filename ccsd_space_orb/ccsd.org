* ccsd with spatial orbitals

Scuseria, Gustavo E.; Janssen, Curtis L.; Schaefer, Henry
F. (1988). An efficient reformulation of the closed-shell coupled
cluster single and double excitation (CCSD) equations. The Journal of
Chemical Physics, 89(12), 7382â€“. doi:10.1063/1.455269

* Code

#+BEGIN_SRC f90 :comments org :tangle ccsd.irp.f
program ccsd
  
  implicit none

  integer :: i,j,k,l,a,b,c,d,tmp_a,tmp_b,tmp_c,tmp_d
  integer :: u,v,gam,beta,tmp_gam,tmp_beta
  integer :: nO, nV
  integer :: nb_iter
  double precision :: get_two_e_integral
  double precision :: energy, max_elem, max_r, max_r1, max_r2
  logical :: not_converged

  double precision, allocatable :: t2(:,:,:,:), r2(:,:,:,:), delta(:,:,:,:), tau(:,:,:,:)
  double precision, allocatable :: t1(:,:), r1(:,:)
  
  double precision, allocatable :: all_err2(:,:), all_t2(:,:)
  double precision, allocatable :: err2(:,:,:,:), tmp_err2(:), tmp_t2(:)
  double precision, allocatable :: all_err1(:,:), all_t1(:,:)
  double precision, allocatable :: err1(:,:), tmp_err1(:), tmp_t1(:)
  
  PROVIDE mo_two_e_integrals_in_map
  
  nO = dim_list_inact_orb
  nV = dim_list_virt_orb
  
  allocate(t2(nO,nO,nV,nV), r2(nO,nO,nV,nV), delta(nO,nO,nV,nV))
  allocate(tau(nO,nO,nV,nV))
  allocate(t1(nO,nV), r1(nO,nV))

  if (cc_update_method == 'diis') then
    allocate(all_err2(nO*nO*nV*nV,cc_diis_depth), all_t2(nO*nO*nV*nV,cc_diis_depth))
    all_err2 = 0d0
    all_t2   = 0d0
    allocate(all_err1(nO*nV,cc_diis_depth), all_t1(nO*nV,cc_diis_depth))
    all_err1 = 0d0
    all_t1   = 0d0
  endif

  if (elec_alpha_num /= elec_beta_num) then
    print*, 'Only for closed shell systems'
    print*, 'elec_alpha_num=',elec_alpha_num
    print*, 'elec_beta_num=',elec_beta_num
    print*, 'abort'
    call abort
  endif
  if (n_inact_orb == 0 .or. n_virt_orb == 0) then
    print*, 'Set the mo_class before the calculation'
    print*, 'for the occupied orbitals -> inactives'
    print*, 'for the virtual orbitals -> virtuals'
    print*, 'abort'
    call abort
  endif

  print*,'hf_energy', hf_energy

  ! Delta
  !do b = 1, nV
  !  do a = 1, nV
  !    do j = 1, nO
  !      do i = 1, nO
  !        delta(i,j,a,b) = fcc_v(a) + fcc_v(b) - fcc_o(i) - fcc_o(j)
  !      enddo
  !    enddo
  !  enddo
  !enddo

  ! Init
  call guess_t1(nO,nV,fcc_o,fcc_v,fcc_ov,t1)
  call guess_t2(nO,nV,fcc_o,fcc_v,vcc_oovv,t2)
  call update_tau_space(nO,nV,t1,t2,tau)
  
  nb_iter = 0
  not_converged = .True.
  max_r1 = 0d0
  max_r2 = 0d0
  
  do while (not_converged)
  
    ! Energy
    call e_ccsd(tau,t1,energy)
    print*,''
    print*,'Iter. n.:', nb_iter
    print*,'E(CCSD)= ', hf_energy + energy, energy
    print*,'r       :', max_r1, max_r2

    ! Residue
    call compute_r1(nO,nV,t1,t2,tau,r1,max_r1)
    call compute_r2(nO,nV,t1,t2,tau,r2,max_r2)
    max_r = max(max_r1,max_r2)

    ! Update
    call update_t_ccsd(nO,nV,nb_iter,fcc_o,fcc_v,r1,r2,t1,t2,all_err1,all_err2,all_t1,all_t2)
    call update_tau_space(nO,nV,t1,t2,tau)
    
    nb_iter = nb_iter + 1
    
    if (max_r < cc_thresh_conv .or. nb_iter > cc_max_iter) then
      not_converged = .False.
    endif
    
  enddo

  call e_ccsd(tau,t1,energy)
  print*,''
  print*,'E(CCSD)=', hf_energy + energy, energy

  !! CCSD(T)
  !double precision, allocatable :: W1(:,:,:,:,:,:)
  !double precision, allocatable :: V1(:,:,:,:,:,:)
  !double precision :: e_ccsdt

  !if (elec_alpha_num + elec_beta_num > 2) then 
  !  allocate(W1(dim_list_inact_orb, dim_list_inact_orb, dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb, dim_list_virt_orb))
  !  allocate(V1(dim_list_inact_orb, dim_list_inact_orb, dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb, dim_list_virt_orb))

  !  call form_w(t2,W1)
  !  call form_v(t1,w1,v1)
  !  call space_ccsd_par_t_energy(t1,t2,W1,V1,e_ccsdt)

  !  print*,''
  !  print*,"delta (T):", e_ccsdt
  !  print*,"E_CCSD(T):", hf_energy + energy + e_ccsdt

  !  deallocate(v1,w1)
  !endif

  ! Deallocation
  if (cc_update_method == 'diis') then
    deallocate(all_err1,all_err2,all_t1,all_t2)
  endif

  deallocate(t1,r1,t2,r2,delta,tau)

end
#+END_SRC

* Energy
#+BEGIN_SRC f90 :comments org :tangle ccsd.irp.f
subroutine e_ccsd(tau,t1,energy)

  implicit none

  double precision, intent(in)  :: tau(dim_list_inact_orb, dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb)
  double precision, intent(in)  :: t1(dim_list_inact_orb, dim_list_virt_orb)
  double precision, intent(out) :: energy

  ! internal
  integer :: nO, nV
  integer :: i,j,a,b

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb
  
  energy = 0d0
  do i = 1, nO
    do a = 1, nV
      energy = energy + 2d0 * fcc_vo(a,i) * t1(i,a)
    enddo
  enddo
  do b = 1, nV
    do a = 1, nV
      do j = 1, nO
        do i = 1, nO
          energy = energy + tau(i,j,a,b) * wcc_oovv(i,j,a,b)
       enddo
      enddo
    enddo
  enddo
  
end
#+END_SRC

* Residual equations
** R1
*** R1
#+BEGIN_SRC f90 :comments org :tangle ccsd.irp.f
subroutine compute_r1(nO,nV,t1,t2,tau,r1,max_r1)

  implicit none

  ! in
  integer, intent(in)           :: nO, nV
  double precision, intent(in)  :: t1(nO,nV), t2(nO,nO,nV,nV), tau(nO,nO,nV,nV)

  ! out
  double precision, intent(out) :: r1(nO,nV), max_r1
  
  ! internal
  double precision, allocatable :: H_oo(:,:), H_vv(:,:), H_vo(:,:)
  integer                       :: u,i,j,beta,a,b

  allocate(H_oo(nO,nO), H_vv(nV,nV), H_vo(nV,nO))
  
  call compute_H_oo(t1,t2,tau,H_oo)
  call compute_H_vv(t1,t2,tau,H_vv)
  call compute_H_vo(t1,t2,H_vo)

  do beta = 1, nV
    do u = 1, nO
      r1(u,beta) = fcc_ov(u,beta)
    enddo
  enddo

  ! r1(u,beta) = r1(u,beta) - 2d0 * fcc_vo(a,i) * t1(i,beta) * t1(u,a)
  ! fcc_vo(a,i) * t1(i,beta) -> X1(nV,nV), O(nV*nV*nO)
  ! X1(a,beta) * t1(u,a) -> O(nO*nV*nV)
  ! fcc_vo(a,i) * t1(u,a)    -> X1(nO,nO), O(nO*nO*nV)
  ! X1(i,u) * t1(i,beta) -> O(nO*nO*nV)  
  !do beta = 1, nV
  !  do u = 1, nO
  !    do i = 1, nO
  !      do a = 1, nV
  !        r1(u,beta) = r1(u,beta) - 2d0 * fcc_vo(a,i) * t1(i,beta) * t1(u,a)
  !      enddo
  !    enddo
  !  enddo
  !enddo
  double precision, allocatable :: X_oo(:,:)
  allocate(X_oo(nO,nO))
  call dgemm('N','N', nO, nO, nV, &
             -2d0, t1    , size(t1,1), &
                   fcc_vo, size(fcc_vo,1), &
              0d0, X_oo  , size(X_oo,1))

  call dgemm('T','N', nO, nV, nO, &
             1d0, X_oo, size(X_oo,2), &
                  t1  , size(t1,1), &
             1d0, r1  , size(r1,1)) 
  deallocate(X_oo)

  ! r1(u,beta) = r1(u,beta) + H_vv(a,beta) * t1(u,a)
  !do beta = 1, nV
  !  do u = 1, nO
  !    do a = 1, nV
  !      r1(u,beta) = r1(u,beta) + H_vv(a,beta) * t1(u,a)
  !    enddo
  !  enddo
  !enddo
  call dgemm('N','N', nO, nV, nV, &
             1d0, t1  , size(t1,1), &
                  H_vv, size(H_vv,1), &
             1d0, r1  , size(r1,1))

  ! r1(u,beta) = r1(u,beta) - H_oo(u,i) * t1(i,beta)
  !do beta = 1, nV
  !  do u = 1, nO
  !    do i = 1, nO
  !      r1(u,beta) = r1(u,beta) - H_oo(u,i) * t1(i,beta)
  !    enddo
  !  enddo
  !enddo
  call dgemm('N','N', nO, nV, nO, &
             -1d0, H_oo, size(H_oo,1), &
                   t1  , size(t1,1), &
              1d0, r1, size(r1,1))

  !r1(u,beta) = r1(u,beta) + H_vo(a,i) * (2d0 * t2(i,u,a,beta) - t2(u,i,a,beta) + t1(u,a) * t1(i,beta))
  ! <=>
  ! r1(u,beta) = r1(u,beta) + H_vo(a,i) * X(a,i,u,beta)
  !do beta = 1, nV
  !  do u = 1, nO
  !    do i = 1, nO
  !      do a = 1, nV
  !        r1(u,beta) = r1(u,beta) + H_vo(a,i) * &
  !        (2d0 * t2(i,u,a,beta) - t2(u,i,a,beta) + t1(u,a) * t1(i,beta))
  !      enddo
  !    enddo
  !  enddo
  !enddo
  double precision, allocatable :: X_voov(:,:,:,:)
  allocate(X_voov(nV, nO, nO, nV))

  do beta = 1, nV
    do u = 1, nO
      do i = 1, nO
        do a = 1, nV
          X_voov(a,i,u,beta) = 2d0 * t2(i,u,a,beta) - t2(u,i,a,beta) + t1(u,a) * t1(i,beta)
        enddo
      enddo
    enddo
  enddo
  
  call dgemv('T', nV*nO, nO*nV, &
             1d0, X_voov, size(X_voov,1) * size(X_voov,2), &
                  H_vo  , 1, &
             1d0, r1    , 1)
  
  deallocate(X_voov)

  ! r1(u,beta) = r1(u,beta) + (2d0 * vcc_voov(a,u,i,beta) - vcc_ovov(u,a,i,beta)) * t1(i,a)
  ! <=> 
  ! r1(u,beta) = r1(u,beta) + X(i,a,u,beta)
  !do beta = 1, nV
  !  do u = 1, nO
  !    do i = 1, nO
  !      do a = 1, nV
  !        r1(u,beta) = r1(u,beta) + (2d0 * vcc_voov(a,u,i,beta) - vcc_ovov(u,a,i,beta)) * t1(i,a)
  !      enddo
  !    enddo
  !  enddo
  !enddo
  double precision, allocatable :: X_ovov(:,:,:,:)
  allocate(X_ovov(nO, nV, nO, nV))

  do beta = 1, nV
    do u = 1, nO
      do a = 1, nv
        do i = 1, nO
          X_ovov(i,a,u,beta) = 2d0 * vcc_voov(a,u,i,beta) - vcc_ovov(u,a,i,beta)
        enddo
      enddo
    enddo
  enddo

  call dgemv('T', nO*nV, nO*nV, &
             1d0, X_ovov, size(X_ovov,1) * size(X_ovov,2), &
                  t1     , 1, &
             1d0, r1     , 1)
  
  deallocate(X_ovov)

  ! r1(u,beta) = r1(u,beta) + (2d0 * vcc_vvov(a,b,i,beta) - vcc_vvov(b,a,i,beta)) * tau(i,u,a,b)  
  ! r1(u,beta) = r1(u,beta) + W(a,b,i,beta) * T(u,a,b,i) 
  !do beta = 1, nV
  !  do u = 1, nO
  !    do i = 1, nO
  !      do a = 1, nV
  !        do b = 1, nV
  !          r1(u,beta) = r1(u,beta) + (2d0 * vcc_vvov(a,b,i,beta) - vcc_vvov(b,a,i,beta)) * tau(i,u,a,b)  
  !        enddo
  !      enddo
  !    enddo
  !  enddo
  !enddo
  double precision, allocatable :: W_vvov(:,:,:,:), T_vvoo(:,:,:,:)
  allocate(W_vvov(nV,nV,nO,nV), T_vvoo(nV,nV,nO,nO))

  do beta = 1, nV
    do i = 1, nO
      do b = 1, nV
        do a = 1, nV
          W_vvov(a,b,i,beta) = 2d0 * vcc_vvov(a,b,i,beta) - vcc_vvov(b,a,i,beta)  
        enddo
      enddo
    enddo
  enddo

  do i = 1, nO
    do b = 1, nV
      do a = 1, nV
        do u = 1, nO
          T_vvoo(a,b,i,u) = tau(i,u,a,b)  
        enddo
      enddo
    enddo
  enddo

  call dgemm('T','N',nO,nV,nO*nV*nV, &
             1d0, T_vvoo, size(T_vvoo,1) * size(T_vvoo,2) * size(T_vvoo,3), &
                  W_vvov, size(W_vvov,1) * size(W_vvov,2) * size(W_vvov,3), &
             1d0, r1    , size(r1,1))
  
  deallocate(W_vvov,T_vvoo)

  ! r1(u,beta) = r1(u,beta) - (2d0 * vcc_vooo(a,u,i,j) - vcc_vooo(a,u,j,i)) * tau(i,j,a,beta) 
  ! r1(u,beta) = r1(u,beta) - W(i,j,a,u) * tau(i,j,a,beta) 
  !do beta = 1, nV
  !  do u = 1, nO
  !    do i = 1, nO
  !      do j = 1, nO
  !        do a = 1, nV
  !          r1(u,beta) = r1(u,beta) - (2d0 * vcc_vooo(a,u,i,j) - vcc_vooo(a,u,j,i)) * tau(i,j,a,beta) 
  !        enddo
  !      enddo
  !    enddo
  !  enddo
  !enddo
  double precision, allocatable :: W_oovo(:,:,:,:)
  allocate(W_oovo(nO,nO,nV,nO))

  do u = 1, nO
    do a = 1, nV
      do j = 1, nO
        do i = 1, nO
          W_oovo(i,j,a,u) = 2d0 * vcc_vooo(a,u,i,j) - vcc_vooo(a,u,j,i)
        enddo
      enddo
    enddo
  enddo

  call dgemm('T','N', nO, nV, nO*nO*nV, &
             -1d0, W_oovo, size(W_oovo,1) * size(W_oovo,2) * size(W_oovo,3), &
                   tau   , size(tau,1) * size(tau,2) * size(tau,3), &
              1d0, r1    , size(r1,1))
  
  deallocate(W_oovo)

  max_r1 = 0d0
  do a = 1, nV
    do i = 1, nO
      if (dabs(r1(i,a)) > max_r1) then
        max_r1 = dabs(r1(i,a))
      endif
    enddo
  enddo

  deallocate(H_oo,H_vv,H_vo)

  ! Change the sign for consistency with the code in spin orbitals
  do a = 1, nV
    do i = 1, nO
      r1(i,a) = -r1(i,a)
    enddo
  enddo
  
end
#+end_src

*** Intermediates
**** H_oo
#+BEGIN_SRC f90 :comments org :tangle ccsd.irp.f
subroutine compute_H_oo(t1,t2,tau,H_oo)

  implicit none

  double precision, intent(in)  :: t1(dim_list_inact_orb, dim_list_virt_orb)
  double precision, intent(in)  :: t2(dim_list_inact_orb, dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb)
  double precision, intent(in)  :: tau(dim_list_inact_orb, dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb)
  double precision, intent(out) :: H_oo(dim_list_inact_orb, dim_list_inact_orb)

  integer :: a,tmp_a,k,b,l,c,d,tmp_c,tmp_d,i,j,u
  integer :: nO,nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  !H_oo = 0d0

  !do i = 1, nO
  !  do u = 1, nO
  !    H_oo(u,i) = fcc_oo(u,i)

  !    do j = 1, nO
  !      do a = 1, nV
  !        do b = 1, nV
  !          !H_oo(u,i) = H_oo(u,i) + (2d0 * vcc_vvoo(a,b,i,j) - vcc_vvoo(b,a,i,j)) * tau(u,j,a,b)
  !          !H_oo(u,i) = H_oo(u,i) + wcc_vvoo(a,b,i,j) * tau(u,j,a,b)
  !          H_oo(u,i) = H_oo(u,i) + wcc_oovv(i,j,a,b) * tau(u,j,a,b)
  !        enddo
  !      enddo
  !    enddo
  !    
  !  enddo
  !enddo

  ! H_oo(u,i) = fcc_oo(u,i)
  do i = 1, nO
    do u = 1, nO
      H_oo(u,i) = fcc_oo(u,i)
    enddo
  enddo

  ! H_oo(u,i) += wcc_oovv(i,j,a,b) * tau(u,j,a,b)
  ! H_oo(u,i) += tau(u,j,a,b) * wcc_oovv(i,j,a,b)
  call dgemm('N','T', nO, nO, nO*nV*nV,       &
             1d0, tau     , size(tau,1),      &
                  wcc_oovv, size(wcc_oovv,1), &
             1d0, H_oo    , size(H_oo,1))     
  
end
#+END_SRC

**** H_vv
#+BEGIN_SRC f90 :comments org :tangle ccsd.irp.f
subroutine compute_H_vv(t1,t2,tau,H_vv)

  implicit none

  double precision, intent(in)  :: t1(dim_list_inact_orb, dim_list_virt_orb)
  double precision, intent(in)  :: t2(dim_list_inact_orb, dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb)
  double precision, intent(in)  :: tau(dim_list_inact_orb, dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb)
  double precision, intent(out) :: H_vv(dim_list_virt_orb, dim_list_virt_orb)

  integer :: a,tmp_a,b,k,l,c,d,tmp_c,tmp_d,i,j,u, beta
  integer :: nO,nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  !H_vv = 0d0

  !do beta = 1, nV
  !  do a = 1, nV
  !    H_vv(a,beta) = fcc_vv(a,beta)

  !    do j = 1, nO
  !      do i = 1, nO
  !        do b = 1, nV
  !          !H_vv(a,beta) = H_vv(a,beta) - (2d0 * vcc_vvoo(a,b,i,j) - vcc_vvoo(a,b,j,i)) * tau(i,j,beta,b)
  !          H_vv(a,beta) = H_vv(a,beta) - wcc_vvoo(a,b,i,j) * tau(i,j,beta,b)
  !        enddo
  !      enddo
  !    enddo
  !    
  !  enddo
  !enddo

  double precision, allocatable :: tmp_tau(:,:,:,:)

  allocate(tmp_tau(nV,nO,nO,nV))

  ! H_vv(a,beta) = fcc_vv(a,beta)
  do beta = 1, nV
    do a = 1, nV
      H_vv(a,beta) = fcc_vv(a,beta)
    enddo
  enddo

  ! H_vv(a,beta) = H_vv(a,beta) - wcc_vvoo(a,b,i,j) * tau(i,j,beta,b)
  ! H_vv(a,beta) = H_vv(a,beta) - wcc_vvoo(a,b,i,j) * tmp_tau(b,i,j,beta)
  do beta = 1, nV
    do j = 1, nO
      do i = 1, nO
        do b = 1, nV
          tmp_tau(b,i,j,beta) = tau(i,j,beta,b) 
        enddo
      enddo
    enddo
  enddo

  call dgemm('N','N',nV,nV,nO*nO*nV,           &
             -1d0, wcc_vvoo, size(wcc_vvoo,1), &
                   tmp_tau , size(tmp_tau,1) * size(tmp_tau,2) * size(tmp_tau,3), &
              1d0, H_vv    , size(H_vv,1))

  deallocate(tmp_tau)
  
end
#+END_SRC

**** H_vo
#+BEGIN_SRC f90 :comments org :tangle ccsd.irp.f
subroutine compute_H_vo(t1,t2,H_vo)

  implicit none

  double precision, intent(in)  :: t1(dim_list_inact_orb, dim_list_virt_orb)
  double precision, intent(in)  :: t2(dim_list_inact_orb, dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb)
  double precision, intent(out) :: H_vo(dim_list_virt_orb, dim_list_inact_orb)

  integer :: a,tmp_a,b,k,l,c,d,tmp_c,tmp_d,i,j,u, beta
  integer :: nO,nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  !H_vo = 0d0

  !do i = 1, nO
  !  do a = 1, nV
  !    H_vo(a,i) = fcc_vo(a,i)

  !    do j = 1, nO
  !      do b = 1, nV
  !        !H_vo(a,i) = H_vo(a,i) + (2d0 * vcc_vvoo(a,b,i,j) - vcc_vvoo(b,a,i,j)) * t1(j,b)
  !        H_vo(a,i) = H_vo(a,i) + wcc_vvoo(a,b,i,j) * t1(j,b)
  !      enddo
  !    enddo
  !    
  !  enddo
  !enddo

  double precision, allocatable :: w(:,:,:,:)

  allocate(w(nV,nO,nO,nV))

  do i = 1, nO
    do a = 1, nV
      H_vo(a,i) = fcc_vo(a,i)
    enddo
  enddo

  ! H_vo(a,i) = H_vo(a,i) + wcc_vvoo(a,b,i,j) * t1(j,b)
  ! H_vo(a,i) = H_vo(a,i) + w(a,i,j,b) * t1(j,b)
  
  do b = 1, nV
    do j = 1, nO
      do i = 1, nO
        do a = 1, nV
          w(a,i,j,b) = wcc_vvoo(a,b,i,j)
        enddo
      enddo
    enddo
  enddo

  call dgemv('N',nV*nO, nO*nV, &
             1d0, w   , size(w,1) * size(w,2), &
                  t1  , 1, &
             1d0, H_vo, 1)

  deallocate(w)
  
end
#+END_SRC

** R2
*** R2
#+begin_src f90 :comments org :tangle ccsd.irp.f
subroutine compute_r2(nO,nV,t1,t2,tau,r2,max_r2)

  implicit none

  ! in
  integer, intent(in)           :: nO, nV
  double precision, intent(in)  :: t1(nO,nV), t2(nO,nO,nV,nV), tau(nO,nO,nV,nV)

  ! out
  double precision, intent(out) :: r2(nO,nO,nV,nV), max_r2

  ! internal
  double precision, allocatable :: g_occ(:,:), g_vir(:,:), J1(:,:,:,:), K1(:,:,:,:)
  double precision, allocatable :: A1(:,:,:,:), B1(:,:,:,:)
  double precision, allocatable :: H_oo(:,:), H_vv(:,:), H_vo(:,:)
  integer                       :: u,v,i,j,beta,gam,a,b

  allocate(g_occ(nO,nO), g_vir(nV,nV))
  allocate(J1(nO,nV,nV,nO), K1(nO,nV,nO,nV))
  allocate(A1(nO,nO,nO,nO), B1(nV,nV,nV,nV))
  allocate(H_oo(nO,nO), H_vv(nV,nV), H_vo(nV,nO))
  
  call compute_H_oo(t1,t2,tau,H_oo)
  call compute_H_vv(t1,t2,tau,H_vv)
  call compute_H_vo(t1,t2,H_vo)
  call compute_g_occ(t1,t2,H_oo,g_occ)
  call compute_g_vir(t1,t2,H_vv,g_vir)
  call compute_A1(t1,t2,tau,A1)
  call compute_B1(t1,t2,B1)
  call compute_J1(t1,t2,J1)
  call compute_K1(t1,t2,K1)

  ! Residual
  r2 = 0d0
  do gam = 1, nV
    do beta = 1, nV
      do v = 1, nO
        do u = 1, nO

         r2(u,v,beta,gam) = vcc_oovv(u,v,beta,gam)

         do j = 1, nO
           do i = 1, nO
             r2(u,v,beta,gam) = r2(u,v,beta,gam) &
             + A1(u,v,i,j) * tau(i,j,beta,gam)
           enddo
         enddo

         do a = 1, nV
           do b = 1, nv
             r2(u,v,beta,gam) = r2(u,v,beta,gam) &
             + B1(a,b,beta,gam) * tau(u,v,a,b)
           enddo
         enddo

         do a = 1, nV
           r2(u,v,beta,gam) = r2(u,v,beta,gam) &
           + g_vir(a,beta) * t2(u,v,a,gam) &
           + g_vir(a,gam)  * t2(v,u,a,beta) ! P
         enddo

         do i = 1, nO
           r2(u,v,beta,gam) = r2(u,v,beta,gam) &
           - g_occ(u,i) * t2(i,v,beta,gam) &
           - g_occ(v,i) * t2(i,u,gam,beta) ! P
         enddo

         do a = 1, nV
           r2(u,v,beta,gam) = r2(u,v,beta,gam) &
           + vcc_ovvv(u,a,beta,gam) * t1(v,a) &
           + vcc_ovvv(v,a,gam,beta) * t1(u,a) ! P
           do i = 1, nO
             r2(u,v,beta,gam) = r2(u,v,beta,gam) &
             - vcc_ovov(u,a,i,gam)  * t1(i,beta) * t1(v,a) &
             - vcc_ovov(v,a,i,beta) * t1(i,gam)  * t1(u,a) ! P
           enddo
         enddo

         do i = 1, nO
           r2(u,v,beta,gam) = r2(u,v,beta,gam) &
           - vcc_oovo(u,v,beta,i) * t1(i,gam) &
           - vcc_oovo(v,u,gam,i)  * t1(i,beta) ! P
           do a = 1, nV
             r2(u,v,beta,gam) = r2(u,v,beta,gam) &
             - vcc_ovvo(u,a,beta,i) * t1(v,a) * t1(i,gam) &
             - vcc_ovvo(v,a,gam,i)  * t1(u,a) * t1(i,beta) ! P
           enddo
         enddo

         do a = 1, nV
           do i = 1, nO
             r2(u,v,beta,gam) = r2(u,v,beta,gam) &
             + 0.5d0 * (2d0 * J1(u,a,beta,i) - K1(u,a,i,beta)) * &
               (2d0 * t2(i,v,a,gam) - t2(i,v,gam,a)) &
             + 0.5d0 * (2d0 * J1(v,a,gam,i)  - K1(v,a,i,gam)) * &
               (2d0 * t2(i,u,a,beta) - t2(i,u,beta,a)) & ! P
             - 0.5d0 * K1(u,a,i,beta) * t2(i,v,gam,a) &
             - 0.5d0 * K1(v,a,i,gam)  * t2(i,u,beta,a) & !P
             - K1(u,a,i,gam)  * t2(i,v,beta,a) &
             - K1(v,a,i,beta) * t2(i,u,gam,a) ! P
           enddo
         enddo

        enddo
      enddo
    enddo
  enddo
  
  ! Change the sign for consistency with the code in spin orbitals
  do b = 1, nV
    do a = 1, nV
      do j = 1, nO
        do i = 1, nO
          r2(i,j,a,b) = -r2(i,j,a,b)
        enddo
      enddo
    enddo
  enddo
  
  max_r2 = 0d0
  do b = 1, nV
    do a = 1, nV
      do j = 1, nO
        do i = 1, nO
          if (dabs(r2(i,j,a,b)) > max_r2) then
            max_r2 = dabs(r2(i,j,a,b))
          endif
        enddo
      enddo
    enddo
  enddo

  deallocate(g_occ,g_vir,J1,K1,A1,B1,H_oo,H_vv,H_vo)
  
end
#+end_src

*** Intermediates
**** A1
#+BEGIN_SRC f90 :comments org :tangle ccsd.irp.f
subroutine compute_A1(t1,t2,tau,A1)

  implicit none

  double precision, intent(in)  :: t1(dim_list_inact_orb, dim_list_virt_orb)
  double precision, intent(in)  :: t2(dim_list_inact_orb, dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb)
  double precision, intent(in)  :: tau(dim_list_inact_orb, dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb)
  double precision, intent(out) :: A1(dim_list_inact_orb, dim_list_inact_orb, dim_list_inact_orb, dim_list_inact_orb)

  integer :: a,tmp_a,b,k,l,c,d,tmp_c,tmp_d,i,j,u,v, beta
  integer :: nO,nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  !A1 = 0d0

  !do j = 1, nO
  !  do i = 1, nO
  !    do v = 1, nO
  !      do u = 1, nO
  !        A1(u,v,i,j) = vcc_oooo(u,v,i,j)

  !        do a = 1, nV
  !          A1(u,v,i,j) = A1(u,v,i,j) &
  !          + vcc_ovoo(u,a,i,j) * t1(v,a) &
  !          + vcc_vooo(a,v,i,j) * t1(u,a)
  !          
  !          do b = 1, nV
  !            A1(u,v,i,j) = A1(u,v,i,j) + vcc_vvoo(a,b,i,j) * tau(u,v,a,b)
  !          enddo  
  !        enddo
  !        
  !      enddo
  !    enddo
  !  enddo
  !enddo

  ! A1(u,v,i,j) = vcc_oooo(u,v,i,j)
  do j = 1, nO
    do i = 1, nO
      do v = 1, nO
        do u = 1, nO
          A1(u,v,i,j) = vcc_oooo(u,v,i,j)
        enddo
      enddo
    enddo
  enddo

  ! A1(u,v,i,j) += vcc_ovoo(u,a,i,j) * t1(v,a) &
  double precision, allocatable :: X_vooo(:,:,:,:), Y_oooo(:,:,:,:)
  allocate(X_vooo(nV,nO,nO,nO), Y_oooo(nO,nO,nO,nO))

  do j = 1, nO
    do i = 1, nO
      do u = 1, nO
        do a = 1, nV
          X_vooo(a,u,i,j) = vcc_ovoo(u,a,i,j)
        enddo
      enddo
    enddo
  enddo

  call dgemm('N','N', nO, nO*nO*nO, nV, &
             1d0, t1    , size(t1,1), &
                  X_vooo, size(X_vooo,1), &
             0d0, Y_oooo, size(Y_oooo,1))

  do j = 1, nO
    do i = 1, nO
      do v = 1, nO
        do u = 1, nO
          A1(u,v,i,j) = A1(u,v,i,j) + Y_oooo(v,u,i,j)
        enddo
      enddo
    enddo
  enddo
  
  deallocate(X_vooo,Y_oooo)

  ! A1(u,v,i,j) += vcc_vooo(a,v,i,j) * t1(u,a)
  call dgemm('N','N', nO, nO*nO*nO, nV, &
             1d0, t1      , size(t1,1), &
                  vcc_vooo, size(vcc_vooo,1), &
             1d0, A1      , size(A1,1))

  ! A1(u,v,i,j) += vcc_vvoo(a,b,i,j) * tau(u,v,a,b)
  call dgemm('N','N', nO*nO, nO*nO, nV*nV, &
             1d0, tau     , size(tau,1) * size(tau,2), &
                  vcc_vvoo, size(vcc_vvoo,1) * size(vcc_vvoo,2), &
             1d0, A1      , size(A1,1) * size(A1,2))
   
end
#+END_SRC

**** B1
#+BEGIN_SRC f90 :comments org :tangle ccsd.irp.f
subroutine compute_B1(t1,t2,B1)

  implicit none

  double precision, intent(in)  :: t1(dim_list_inact_orb, dim_list_virt_orb)
  double precision, intent(in)  :: t2(dim_list_inact_orb, dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb)
  double precision, intent(out) :: B1(dim_list_virt_orb, dim_list_virt_orb, dim_list_virt_orb, dim_list_virt_orb)

  integer :: a,tmp_a,b,k,l,c,d,tmp_c,tmp_d,i,j,u,v, beta, gam
  integer :: nO,nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  !B1 = 0d0

  !do gam = 1, nV
  !  do beta = 1, nV
  !    do b = 1, nV
  !      do a = 1, nV
  !        B1(a,b,beta,gam) = vcc_vvvv(a,b,beta,gam) 

  !        do i = 1, nO
  !          B1(a,b,beta,gam) = B1(a,b,beta,gam) &
  !          - vcc_vvvo(a,b,beta,i) * t1(i,gam) &
  !          - vcc_vvov(a,b,i,gam) * t1(i,beta)
  !        enddo
  !        
  !      enddo
  !    enddo
  !  enddo
  !enddo

  ! B1(a,b,beta,gam) = vcc_vvvv(a,b,beta,gam) 
  do gam = 1, nV
    do beta = 1, nV
      do b = 1, nV
        do a = 1, nV
          B1(a,b,beta,gam) = vcc_vvvv(a,b,beta,gam)
        enddo
      enddo
    enddo
  enddo
  
  ! B1(a,b,beta,gam) -= vcc_vvvo(a,b,beta,i) * t1(i,gam) &
  call dgemm('N','N', nV*nV*nV, nV, nO, &
             -1d0, vcc_vvvo, size(vcc_vvvo,1) * size(vcc_vvvo,2) * size(vcc_vvvo,3), &
                   t1      , size(t1,1), &
              1d0, B1      , size(B1,1) * size(B1,2) * size(B1,3))

  
  ! B1(a,b,beta,gam) -= vcc_vvov(a,b,i,gam) * t1(i,beta)
  double precision, allocatable :: X_vvvo(:,:,:,:), Y_vvvv(:,:,:,:)
  allocate(X_vvvo(nV,nV,nV,nO), Y_vvvv(nV,nV,nV,nV))

  do i = 1, nO
    do gam = 1, nV
      do b = 1, nV
        do a = 1, nV
          X_vvvo(a,b,gam,i) = vcc_vvov(a,b,i,gam)
        enddo
      enddo
    enddo
  enddo

  call dgemm('N','N', nV*nV*nV, nV, nO, &
             -1d0, X_vvvo, size(X_vvvo,1) * size(X_vvvo,2) * size(X_vvvo,3), &
                   t1    , size(t1,1), &
              0d0, Y_vvvv, size(Y_vvvv,1) * size(Y_vvvv,2) * size(Y_vvvv,3))

  do gam = 1, nV
    do beta = 1, nV
      do b = 1, nV
        do a = 1, nV
          B1(a,b,beta,gam) = B1(a,b,beta,gam) + Y_vvvv(a,b,gam,beta)
        enddo
      enddo
    enddo
  enddo
  
  deallocate(X_vvvo,Y_vvvv)
  
end
#+END_SRC

**** g_occ
#+BEGIN_SRC f90 :comments org :tangle ccsd.irp.f
subroutine compute_g_occ(t1,t2,H_oo,g_occ)

  implicit none

  double precision, intent(in)  :: t1(dim_list_inact_orb, dim_list_virt_orb), H_oo(dim_list_inact_orb, dim_list_inact_orb)
  double precision, intent(in)  :: t2(dim_list_inact_orb, dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb)
  double precision, intent(out) :: g_occ(dim_list_inact_orb, dim_list_inact_orb)

  integer :: a,tmp_a,b,k,l,c,d,tmp_c,tmp_d,i,j,u,v, beta, gam
  integer :: nO,nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  g_occ = 0d0

  do i = 1, nO
    do u = 1, nO
      g_occ(u,i) = H_oo(u,i)
      
      do a = 1, nV
        g_occ(u,i) = g_occ(u,i) + fcc_vo(a,i) * t1(u,a)
        
        do j = 1, nO
          g_occ(u,i) = g_occ(u,i) + (2d0 * vcc_ovoo(u,a,i,j) - vcc_ovoo(u,a,j,i)) * t1(j,a)
        enddo
           
      enddo
    enddo
  enddo
  
end
#+END_SRC

**** g_vir
#+BEGIN_SRC f90 :comments org :tangle ccsd.irp.f
subroutine compute_g_vir(t1,t2,H_vv,g_vir)

  implicit none

  double precision, intent(in)  :: t1(dim_list_inact_orb, dim_list_virt_orb), H_vv(dim_list_virt_orb, dim_list_virt_orb)
  double precision, intent(in)  :: t2(dim_list_inact_orb, dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb)
  double precision, intent(out) :: g_vir(dim_list_virt_orb, dim_list_virt_orb)

  integer :: a,tmp_a,b,k,l,c,d,tmp_c,tmp_d,i,j,u,v, beta, gam
  integer :: nO,nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  g_vir = 0d0

  do beta = 1, nV
    do a = 1, nV
      g_vir(a,beta) = H_vv(a,beta)
      
      do i = 1, nO
        g_vir(a,beta) = g_vir(a,beta) - fcc_vo(a,i) * t1(i,beta)
        
        do b = 1, nV
          g_vir(a,beta) = g_vir(a,beta) + (2d0 * vcc_vvvo(a,b,beta,i) - vcc_vvvo(b,a,beta,i)) * t1(i,b)
        enddo
           
      enddo
    enddo
  enddo
  
end
#+END_SRC

**** J1
#+BEGIN_SRC f90 :comments org :tangle ccsd.irp.f
subroutine compute_J1(t1,t2,J1)

  implicit none

  double precision, intent(in)  :: t1(dim_list_inact_orb, dim_list_virt_orb)
  double precision, intent(in)  :: t2(dim_list_inact_orb, dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb)
  double precision, intent(out) :: J1(dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb, dim_list_inact_orb)

  integer :: a,tmp_a,b,k,l,c,d,tmp_c,tmp_d,i,j,u,v, beta, gam
  integer :: nO,nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  J1 = 0d0

  do i = 1, nO
    do beta = 1, nV
      do a = 1, nV
        do u = 1, nO
          J1(u,a,beta,i) = vcc_ovvo(u,a,beta,i)

          do j = 1, nO
            J1(u,a,beta,i) = J1(u,a,beta,i) &
            - vcc_ovoo(u,a,j,i) * t1(j,beta)
          enddo

          do b = 1, nV
            J1(u,a,beta,i) = J1(u,a,beta,i) &
            + vcc_vvvo(b,a,beta,i) * t1(u,b)    
          enddo

          do j = 1, nO
            do b = 1, nV
             J1(u,a,beta,i) = J1(u,a,beta,i) &
             - vcc_vvoo(a,b,i,j) * (0.5d0 * t2(u,j,b,beta) + t1(u,b) * t1(j,beta)) &
             + 0.5d0 * (2d0 * vcc_vvoo(a,b,i,j) - vcc_vvoo(b,a,i,j)) * t2(u,j,beta,b)
            enddo
          enddo
          
        enddo
      enddo
    enddo
  enddo
  
end
#+END_SRC

**** K1
#+BEGIN_SRC f90 :comments org :tangle ccsd.irp.f
subroutine compute_K1(t1,t2,K1)

  implicit none

  double precision, intent(in)  :: t1(dim_list_inact_orb, dim_list_virt_orb)
  double precision, intent(in)  :: t2(dim_list_inact_orb, dim_list_inact_orb, dim_list_virt_orb, dim_list_virt_orb)
  double precision, intent(out) :: K1(dim_list_inact_orb, dim_list_virt_orb, dim_list_inact_orb, dim_list_virt_orb)

  integer :: a,tmp_a,b,k,l,c,d,tmp_c,tmp_d,i,j,u,v, beta, gam
  integer :: nO,nV

  nO = dim_list_inact_orb
  nV = dim_list_virt_orb

  K1 = 0d0

  do beta = 1, nV
    do i = 1, nO
      do a = 1, nV
        do u = 1, nO
          K1(u,a,i,beta) = vcc_ovov(u,a,i,beta)

          do j = 1, nO
            K1(u,a,i,beta) = K1(u,a,i,beta) &
            - vcc_ovoo(u,a,i,j) * t1(j,beta)
          enddo

          do b = 1, nV
            K1(u,a,i,beta) = K1(u,a,i,beta) &
            + vcc_vvov(b,a,i,beta) * t1(u,b)    
          enddo

          do j = 1, nO
            do b = 1, nV
             K1(u,a,i,beta) = K1(u,a,i,beta) &
             - vcc_vvoo(b,a,i,j) * (0.5d0 * t2(u,j,b,beta) + t1(u,b) * t1(j,beta))
            enddo
          enddo
          
        enddo
      enddo
    enddo
  enddo
  
end
#+END_SRC

