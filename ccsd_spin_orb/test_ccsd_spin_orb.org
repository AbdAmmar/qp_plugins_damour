* CCSD spin orb
** Prog
#+begin_src f90 :comments org :tangle test_ccsd_spin_orb.irp.f
program ccsd

  implicit none

  call run
  
end 
#+end_src

** Code
#+begin_src f90 :comments org :tangle test_ccsd_spin_orb.irp.f
subroutine run

  implicit none

  double precision, allocatable :: t1(:,:), t2(:,:,:,:), tau(:,:,:,:), tau_t(:,:,:,:)
  double precision, allocatable :: r1(:,:), r2(:,:,:,:)
  double precision, allocatable :: Foo(:,:), Fov(:,:), Fvv(:,:)
  !double precision, allocatable :: D_OV(:,:), D_oovv(:,:,:,:)
  double precision, allocatable :: cF_oo(:,:), cF_ov(:,:), cF_vv(:,:)
  double precision, allocatable :: cW_oooo(:,:,:,:), cW_ovvo(:,:,:,:), cW_vvvv(:,:,:,:)
  !double precision, allocatable :: oooo(:,:,:,:),ooov(:,:,:,:),oovo(:,:,:,:),oovv(:,:,:,:)
  !double precision, allocatable :: ovvo(:,:,:,:),ovvv(:,:,:,:),vovv(:,:,:,:),vvvv(:,:,:,:)
  
  logical                       :: not_converged
  integer                       :: nO,nV, nb_iter
  double precision              :: energy, max_r, max_r1, max_r2, cc

  PROVIDE oooo ooov oovo oovv ovvo ovvv vovv vvvv
  PROVIDE delta_OV delta_oovv
  
  if (n_core_orb > 0) then
     print*,'No frozen core only'
     call abort
  endif

  nO = spin_occ_num
  nV = spin_vir_num

  allocate(t1(nO,nV), t2(nO,nO,nV,nV), tau(nO,nO,nV,nV), tau_t(nO,nO,nV,nV))
  allocate(r1(nO,nV), r2(nO,nO,nV,nV))
  allocate(Foo(nO,nO), Fov(nO,nV), Fvv(nV,nV))
  allocate(cF_oo(nO,nO), cF_ov(nO,nV), cF_vv(nV,nV))
  allocate(cW_oooo(nO,nO,nV,nV), cW_ovvo(nO,nV,nV,nO), cW_vvvv(nV,nV,nV,nV))

  Foo = spin_fock_matrix_mo_oo
  Fov = spin_fock_matrix_mo_ov
  Fvv = spin_fock_matrix_mo_vv
  
  t1 = 0d0
  call guess_t2(nO,nV,oovv,delta_oovv,t2)
  call compute_tau(nO,nV,t1,t2,tau)
  call compute_tau_t(nO,nV,t1,t2,tau_t)
  
  r1 = 0d0
  r2 = 0d0

  cc = 1d-6
  nb_iter = 0
  not_converged = .True.
  
  do while (not_converged)

    call ccsd_energy(nO,nV,t1,t2,Fov,oovv,energy)
    print*,''
    print*,'Iter n. ',nb_iter
    print*,'E(CCSD)=', hf_energy + energy, energy
    print*,'r', max_r1, max_r2

    call compute_cF_oo(nO,nV,t1,tau_t,Foo,Fov,Fvv,ooov,oovv,ovvv,cF_oo)
    call compute_cF_ov(nO,nV,t1,tau_t,Foo,Fov,Fvv,ooov,oovv,ovvv,cF_ov)
    call compute_cF_vv(nO,nV,t1,tau_t,Foo,Fov,Fvv,ooov,oovv,ovvv,cF_vv)
    
    call compute_cW_oooo(nO,nV,t1,t2,tau,oooo,ooov,oovo,oovv,ovvo,ovvv,vovv,vvvv,cW_oooo)
    call compute_cW_ovvo(nO,nV,t1,t2,tau,oooo,ooov,oovo,oovv,ovvo,ovvv,vovv,vvvv,cW_ovvo)
    call compute_cW_vvvv(nO,nV,t1,t2,tau,oooo,ooov,oovo,oovv,ovvo,ovvv,vovv,vvvv,cW_vvvv)

    call compute_r1(nO,nV,t1,t2,delta_ov,Fov,cF_oo,cF_ov,cF_vv,oovo,OVOV,ovvv,r1)
    call compute_r2(nO,nV,t1,t2,tau,delta_oovv,cF_oo,cF_ov,cF_vv,cW_oooo,cW_vvvv,cW_ovvo,OVOO,oovv,ovvo,VVVO,r2)

    max_r1 = maxval(abs(r1(:,:)))
    max_r2 = maxval(abs(r2(:,:,:,:)))
    max_r  = max(max_r1,max_r2)

    call update_t1(nO,nV,r1,delta_ov,t1)
    call update_t2(nO,nV,r2,delta_oovv,t2)
    !t1(:,:)      = t1(:,:)     - r1(:,:)    /delta_OV  (:,:)
    !t2(:,:,:,:)  = t2(:,:,:,:) - r2(:,:,:,:)/delta_oovv(:,:,:,:)
    call compute_tau(nO,nV,t1,t2,tau)
    call compute_tau_t(nO,nV,t1,t2,tau_t)

    nb_iter = nb_iter + 1
     
    if (max_r < cc .or. nb_iter > 100) then
      not_converged = .False.
    endif

  enddo

  deallocate(t1,t2,tau,tau_t)
  deallocate(r1,r2)
  deallocate(Foo,Fov,Fvv)
  deallocate(cF_oo,cF_ov,cF_vv)
  deallocate(cW_oooo,cW_ovvo,cW_vvvv)
  
end
#+end_src

* Energy
#+begin_src f90 :comments org :tangle test_ccsd_spin_orb.irp.f
subroutine ccsd_energy(nO,nV,t1,t2,Fov,v_oovv,energy)

  implicit none

  integer,intent(in)            :: nO,nV
  double precision,intent(in)   :: t1(nO,nV)
  double precision,intent(in)   :: t2(nO,nO,nV,nV)
  double precision,intent(in)   :: Fov(nO,nV)
  double precision,intent(in)   :: v_oovv(nO,nO,nV,nV)

  double precision,intent(out)  :: energy

  integer                       :: i,j,a,b


  energy = 0d0

  do i=1,nO
      do a=1,nV
     
      energy = energy + Fov(i,a)*t1(i,a)

    end do
  end do

  do i=1,nO
    do j=1,nO
      do a=1,nV
        do b=1,nV
     
          energy = energy                              & 
                 + 0.5d0*v_oovv(i,j,a,b)*t1(i,a)*t1(j,b) &
                 + 0.25d0*v_oovv(i,j,a,b)*t2(i,j,a,b)

        end do
      end do
    end do
  end do

end
#+end_src

* T
** Guess
*** T2
#+begin_src f90 :comments org :tangle test_ccsd_spin_orb.irp.f
subroutine guess_t2(nO,nV,v_oovv,d_oovv,t2)

  implicit none

  integer, intent(in)           :: nO,nV
  double precision, intent(in)  :: v_oovv(nO,nO,nV,nV), d_oovv(nO,nO,nV,nV)
  
  double precision, intent(out) :: t2(nO,nO,nV,nV)

  integer :: i,j,a,b

  do b = 1, nV
    do a = 1, nV
      do j = 1, nO
        do i = 1, nO
          t2(i,j,a,b) = v_oovv(i,j,a,b) / d_oovv(i,j,a,b)
        enddo
      enddo
    enddo
  enddo

end
#+end_src

** Update
*** T1
#+begin_src f90 :comments org :tangle test_ccsd_spin_orb.irp.f
subroutine update_t1(nO,nV,r1,d_ov,t1)

  implicit none

  integer, intent(in)           :: nO,nV
  double precision, intent(in)  :: r1(nO,nV), d_ov(nO,nV)
  
  double precision, intent(out) :: t1(nO,nV)

  integer :: i,a

  do a = 1, nV
    do i = 1, nO
      t1(i,a) = t1(i,a) - r1(i,a) / d_ov(i,a)
    enddo
  enddo

end
#+end_src

*** T2
#+begin_src f90 :comments org :tangle test_ccsd_spin_orb.irp.f
subroutine update_t2(nO,nV,r2,d_oovv,t2)

  implicit none

  integer, intent(in)           :: nO,nV
  double precision, intent(in)  :: r2(nO,nO,nV,nV), d_oovv(nO,nO,nV,nV)
  
  double precision, intent(out) :: t2(nO,nO,nV,nV)

  integer :: i,j,a,b

  do b = 1, nV
    do a = 1, nV
      do j = 1, nO
        do i = 1, nO
          t2(i,j,a,b) = t2(i,j,a,b) - r2(i,j,a,b) / d_oovv(i,j,a,b)
        enddo
      enddo
    enddo
  enddo

end
#+end_src

*** Tau
#+begin_src f90 :comments org :tangle test_ccsd_spin_orb.irp.f
subroutine compute_tau(nO,nV,t1,t2,tau)

  implicit none

  integer,intent(in)            :: nO,nV
  double precision,intent(in)   :: t1(nO,nV)
  double precision,intent(in)   :: t2(nO,nO,nV,nV)

  double precision,intent(out)  :: tau(nO,nO,nV,nV)
  
  integer                       :: i,j,k,l
  integer                       :: a,b,c,d

  do i=1,nO
    do j=1,nO
      do a=1,nV
        do b=1,nV

          tau(i,j,a,b) = t2(i,j,a,b) + t1(i,a)*t1(j,b) - t1(i,b)*t1(j,a)

        enddo
      enddo
    enddo
  enddo

end
#+end_src

*** Tau_t
#+begin_src f90 :comments org :tangle test_ccsd_spin_orb.irp.f
subroutine compute_tau_t(nO,nV,t1,t2,tau_t)

  implicit none

  integer,intent(in)            :: nO,nV
  double precision,intent(in)   :: t1(nO,nV)
  double precision,intent(in)   :: t2(nO,nO,nV,nV)

  double precision,intent(out)  :: tau_t(nO,nO,nV,nV)

  integer                       :: i,j,k,l
  integer                       :: a,b,c,d

  do i=1,nO
    do j=1,nO
      do a=1,nV
        do b=1,nV

          tau_t(i,j,a,b) = t2(i,j,a,b) + 0.5d0*(t1(i,a)*t1(j,b) - t1(i,b)*t1(j,a))

        enddo
      enddo
    enddo
  enddo

end
#+end_src

* R
** R1
#+begin_src f90 :comments org :tangle test_ccsd_spin_orb.irp.f
subroutine compute_r1(nO,nV,t1,t2,D_ov,Fov,cF_oo,cF_ov,cF_vv,v_oovo,v_OVOV,v_ovvv,r1)

  implicit none

  integer,intent(in)            :: nO,nV
  double precision,intent(in)   :: t1(nO,nV)
  double precision,intent(in)   :: t2(nO,nO,nV,nV)
  double precision,intent(in)   :: D_ov(nO,nV)
  double precision,intent(in)   :: Fov(nO,nV)
  double precision,intent(in)   :: cF_oo(nO,nO)
  double precision,intent(in)   :: cF_ov(nO,nV)
  double precision,intent(in)   :: cF_vv(nV,nV)
  double precision,intent(in)   :: v_oovo(nO,nO,nV,nO)
  double precision,intent(in)   :: v_OVOV(nO,nV,nO,nV)
  double precision,intent(in)   :: v_ovvv(nO,nV,nV,nV)

  double precision,intent(out)  :: r1(nO,nV)

  integer                       :: i,j,m,n
  integer                       :: a,b,e,f

  do a = 1, nV
    do i = 1, nO
      r1(i,a) = Fov(i,a)
    enddo
  enddo

  !do a=1,nV
  !  do i=1,nO
  !    do e=1,nV
  !      r1(i,a) = r1(i,a) + t1(i,e)*cF_vv(a,e)
  !    end do
  !  end do
  !end do
  call dgemm('N','T', nO, nV, nV, &
             1d0, t1   , size(t1,1), &
                  cF_vv, size(cF_vv,1), &
             1d0, r1   , size(r1,1))

  !do a=1,nV
  !  do i=1,nO
  !    do m=1,nO
  !      r1(i,a) = r1(i,a) - t1(m,a)*cF_oo(m,i)
  !    end do
  !  end do
  !end do
  call dgemm('T','N', nO, nV, nO, &
             -1d0, cF_oo, size(cF_oo,1), &
                   t1   , size(t1,1), &
              1d0, r1   , size(r1,1))

  do a=1,nV
    do i=1,nO
      do e=1,nV
        do m=1,nO
          r1(i,a) = r1(i,a) + t2(i,m,a,e)*cF_ov(m,e)
        end do
      end do
    end do
  end do

  do a=1,nV
    do i=1,nO
      do f=1,nV
        do n=1,nO
          r1(i,a) = r1(i,a) - t1(n,f)*v_OVOV(n,a,i,f)
        end do
      end do
    end do
  end do

  !do a=1,nV
  !  do i=1,nO
  !    do f=1,nV
  !      do e=1,nV
  !        do m=1,nO
  !          r1(i,a) = r1(i,a) - 0.5d0*t2(i,m,e,f)*v_ovvv(m,a,e,f)
  !        end do
  !      end do
  !    end do
  !  end do
  !end do
  double precision, allocatable :: X_vovv(:,:,:,:)
  allocate(X_vovv(nV,nO,nV,nV))
  do f = 1, nV
    do e = 1, nV
       do m = 1, nO
         do a = 1, nV
           X_vovv(a,m,e,f) = v_ovvv(m,a,e,f)
        enddo
      enddo
    enddo
  enddo
  call dgemm('N','T', nO, nV, nO*nV*nV, &
             -0.5d0, t2    , size(t2,1), &
                     X_vovv, size(X_vovv,1), &
              1d0  , r1    , size(r1,1))
  
  deallocate(X_vovv)

  !do a=1,nV
  !  do i=1,nO
  !    do e=1,nV
  !      do m=1,nO
  !        do n=1,nO
  !          r1(i,a) = r1(i,a) - 0.5d0*t2(m,n,a,e)*v_oovo(n,m,e,i)
  !        end do
  !      end do
  !    end do
  !  end do
  !end do
  double precision, allocatable :: X_oovv(:,:,:,:)
  allocate(X_oovv(nO,nO,nV,nV))
  do a = 1, nV
    do e = 1, nV
      do m = 1, nO
        do n = 1, nO
          X_oovv(n,m,e,a) = t2(m,n,a,e)
        enddo
      enddo
    enddo
  enddo
  call dgemm('T','N', nO, nV, nO*nO*nV, &
             -0.5d0, v_oovo, size(v_oovo,1) * size(v_oovo,2) * size(v_oovo,3), &
                     X_oovv, size(X_oovv,1) * size(X_oovv,2) * size(X_oovv,3), &
             1d0   , r1    , size(r1,1))
  
  deallocate(X_oovv)

  do a = 1, nV
    do i = 1, nO
      r1(i,a) = D_ov(i,a)*t1(i,a) - r1(i,a)
    enddo
  enddo

end
#+end_src

** R2
#+begin_src f90 :comments org :tangle test_ccsd_spin_orb.irp.f
subroutine compute_r2(nO,nV,t1,t2,tau,D_oovv,cF_oo,cF_ov,cF_vv,cW_oooo,cW_vvvv,cW_ovvo,v_OVOO,v_oovv,v_ovvo,v_VVVO,r2)

  implicit none

  integer,intent(in)            :: nO,nV
  double precision,intent(in)   :: cF_oo(nO,nO)
  double precision,intent(in)   :: cF_ov(nO,nV)
  double precision,intent(in)   :: cF_vv(nV,nV)
  double precision,intent(in)   :: D_oovv(nO,nO,nV,nV)
  double precision,intent(in)   :: cW_oooo(nO,nO,nO,nO)
  double precision,intent(in)   :: cW_vvvv(nV,nV,nV,nV)
  double precision,intent(in)   :: cW_ovvo(nO,nV,nV,nO)
  double precision,intent(in)   :: t1(nO,nV)
  double precision,intent(in)   :: t2(nO,nO,nV,nV)
  double precision,intent(in)   :: tau(nO,nO,nV,nV)
  double precision,intent(in)   :: v_OVOO(nO,nV,nO,nO)
  double precision,intent(in)   :: v_oovv(nO,nO,nV,nV)
  double precision,intent(in)   :: v_ovvo(nO,nV,nV,nO)
  double precision,intent(in)   :: v_VVVO(nV,nV,nV,nO)

  double precision,intent(out)  :: r2(nO,nO,nV,nV)

  integer                       :: i,j,m,n
  integer                       :: a,b,e,f
  double precision, allocatable :: X_vvov(:,:,:,:), X_vvoo(:,:,:,:)
  double precision, allocatable :: A_vvov(:,:,:,:)
  double precision, allocatable :: X_oovv(:,:,:,:), Y_oovv(:,:,:,:)
  double precision, allocatable :: A_vvoo(:,:,:,:), B_ovoo(:,:,:,:), C_ovov(:,:,:,:)
  double precision, allocatable :: A_ovov(:,:,:,:), B_ovvo(:,:,:,:), X_ovvo(:,:,:,:)

  do b=1,nV
    do a=1,nV
      do j=1,nO
        do i=1,nO
          r2(i,j,a,b) = oovv(i,j,a,b)
        end do
      end do
    end do
  end do

  !do b=1,nV
  !  do a=1,nV
  !    do j=1,nO
  !      do i=1,nO

  !        do e=1,nV
  !          r2(i,j,a,b) = r2(i,j,a,b) + t2(i,j,a,e)*cF_vv(b,e)
  !          r2(i,j,a,b) = r2(i,j,a,b) - t2(i,j,b,e)*cF_vv(a,e)
  !        end do

  !      end do
  !    end do
  !  end do
  !end do
  allocate(X_oovv(nO,nO,nV,nV))
  call dgemm('N','T',nO*nO*nV, nV, nV, &
             1d0, t2    , size(t2,1) * size(t2,2) * size(t2,3), &
                  cF_VV , size(cF_vv,1), &
             0d0, X_oovv, size(X_oovv,1) * size(X_oovv,2) * size(X_oovv,3))

  do b=1,nV
    do a=1,nV
      do j=1,nO
        do i=1,nO
          r2(i,j,a,b) = r2(i,j,a,b) + X_oovv(i,j,a,b) - X_oovv(i,j,b,a)
        end do
      end do
    end do
  end do
  deallocate(X_oovv)

  !do b=1,nV
  !  do a=1,nV
  !    do j=1,nO
  !      do i=1,nO

  !        do e=1,nV
  !          do m=1,nO
  !            r2(i,j,a,b) = r2(i,j,a,b) - 0.5d0*t2(i,j,a,e)*t1(m,b)*cF_ov(m,e)
  !            r2(i,j,a,b) = r2(i,j,a,b) + 0.5d0*t2(i,j,b,e)*t1(m,a)*cF_ov(m,e)
  !          end do
  !        end do

  !      end do
  !    end do
  !  end do
  !end do
  double precision, allocatable :: A_vv(:,:)
  allocate(A_vv(nV,nV), X_oovv(nO,nO,nV,nV))
  call dgemm('T','N', nV, nV, nO, &
             1d0, t1   , size(t1,1), &
                  cF_ov, size(cF_ov,1), &
             0d0, A_vv , size(A_vv,1))

  call dgemm('N','T', nO*nO*nV, nV, nV, &
             0.5d0, t2    , size(t2,1) * size(t2,2) * size(t2,3), &
                    A_vv  , size(A_vv,1), &
             0d0  , X_oovv, size(X_oovv,1) * size(X_oovv,2) * size(X_oovv,3))
  
  do b=1,nV
    do a=1,nV
      do j=1,nO
        do i=1,nO
          r2(i,j,a,b) = r2(i,j,a,b) - X_oovv(i,j,a,b) + X_oovv(i,j,b,a) 
        end do
      end do
    end do
  end do
             
  deallocate(A_vv,X_oovv)

  !do b=1,nV
  !  do a=1,nV
  !    do j=1,nO
  !      do i=1,nO

  !        do m=1,nO
  !          r2(i,j,a,b) = r2(i,j,a,b) - t2(i,m,a,b)*cF_oo(m,j)
  !          r2(i,j,a,b) = r2(i,j,a,b) + t2(j,m,a,b)*cF_oo(m,i)
  !        end do

  !      end do
  !    end do
  !  end do
  !end do
  allocate(X_oovv(nO,nO,nV,nV), Y_oovv(nO,nO,nV,nV))
  do b=1,nV
    do a=1,nV
      do i=1,nO
        do m=1,nO
          X_oovv(m,i,a,b) = t2(i,m,a,b)
        end do
      end do
    end do
  end do

  call dgemm('T','N', nO, nO*nV*nV, nO, &
             1d0, cF_oo , size(cF_oo,1), &
                  X_oovv, size(X_oovv,1), &
             0d0, Y_oovv, size(Y_oovv,1))

  do b=1,nV
    do a=1,nV
      do j=1,nO
        do i=1,nO
          r2(i,j,a,b) = r2(i,j,a,b) - Y_oovv(j,i,a,b) + Y_oovv(i,j,a,b) 
        end do
      end do
    end do
  end do
  deallocate(X_oovv,Y_oovv)

  !do b=1,nV
  !  do a=1,nV
  !    do j=1,nO
  !      do i=1,nO

  !        do e=1,nV
  !          do m=1,nO
  !            r2(i,j,a,b) = r2(i,j,a,b) - 0.5d0*t2(i,m,a,b)*t1(j,e)*cF_ov(m,e)
  !            r2(i,j,a,b) = r2(i,j,a,b) + 0.5d0*t2(j,m,a,b)*t1(i,e)*cF_ov(m,e)
  !          end do
  !        end do

  !      end do
  !    end do
  !  end do
  !end do
  double precision, allocatable :: A_oo(:,:), B_oovv(:,:,:,:)
  allocate(A_oo(nO,nO),B_oovv(nO,nO,nV,nV),X_oovv(nO,nO,nV,nV))
  call dgemm('N','T', nO, nO, nV, &
        1d0, t1   , size(t1,1), &
             cF_ov, size(cF_ov,1), &
        0d0, A_oo , size(A_oo,1))
  do b = 1, nV
    do a = 1, nV
      do i = 1, nO
        do m = 1, nO
          B_oovv(m,i,a,b) = t2(i,m,a,b)
        enddo
      enddo
    enddo
  enddo
  call dgemm('N','N', nO, nO*nV*nV, nO, &
             0.5d0, A_oo, size(A_oo,1), &
                    B_oovv, size(B_oovv,1), &
             0d0  , X_oovv, size(X_oovv,1))
  do b=1,nV
    do a=1,nV
      do j=1,nO
        do i=1,nO
          r2(i,j,a,b) = r2(i,j,a,b) - X_oovv(j,i,a,b) + X_oovv(i,j,a,b)
        end do
      end do
    end do
  end do
  deallocate(A_oo,B_oovv,X_oovv)

  !do b=1,nV
  !  do a=1,nV
  !    do j=1,nO
  !      do i=1,nO

  !        do n=1,nO
  !          do m=1,nO
  !            r2(i,j,a,b) = r2(i,j,a,b) + 0.5d0*tau(m,n,a,b)*cW_oooo(m,n,i,j)
  !          end do
  !        end do

  !      end do
  !    end do
  !  end do
  !end do
  call dgemm('T','N', nO*nO, nV*nV, nO*nO, &
             0.5d0, cW_oooo, size(cW_oooo,1) * size(cW_oooo,2), &
                    tau    , size(tau,1) * size(tau,2), &
             1d0  , r2     , size(r2,1) * size(r2,2))
  
  !do b=1,nV
  !  do a=1,nV
  !    do j=1,nO
  !      do i=1,nO

  !        do f=1,nV
  !          do e=1,nV
  !            r2(i,j,a,b) = r2(i,j,a,b) + 0.5d0*tau(i,j,e,f)*cW_vvvv(a,b,e,f)
  !          end do
  !        end do

  !      end do
  !    end do
  !  end do
  !end do
  call dgemm('N','T', nO*nO, nV*nV, nV*nV, &
             0.5d0, tau    , size(tau,1) * size(tau,2), &
                    cW_vvvv, size(cW_vvvv,1) * size(cW_vvvv,2), &
             1d0  , r2     , size(r2,1) * size(r2,2))
  
  !do b=1,nV
  !  do a=1,nV
  !    do j=1,nO
  !      do i=1,nO

  !        do e=1,nV
  !          do m=1,nO
  !            r2(i,j,a,b) = r2(i,j,a,b)                                                 & 
  !                        + t2(i,m,a,e)*cW_ovvo(m,b,e,j) &
  !                        - t2(j,m,a,e)*cW_ovvo(m,b,e,i) &
  !                        - t2(i,m,b,e)*cW_ovvo(m,a,e,j) &
  !                        + t2(j,m,b,e)*cW_ovvo(m,a,e,i) &
  !                        - t1(i,e)*t1(m,a)*v_ovvo(m,b,e,j) &
  !                        + t1(j,e)*t1(m,a)*v_ovvo(m,b,e,i) &
  !                        + t1(i,e)*t1(m,b)*v_ovvo(m,a,e,j) &
  !                        - t1(j,e)*t1(m,b)*v_ovvo(m,a,e,i)
  !          end do
  !        end do

  !      end do
  !    end do
  !  end do
  !end do
  allocate(A_ovov(nO,nV,nO,nV), B_ovvo(nO,nV,nV,nO), X_ovvo(nO,nV,nV,nO))
  do a = 1, nV
    do i = 1, nO
      do e = 1, nV
        do m = 1, nO
          A_ovov(m,e,i,a) = t2(i,m,a,e)
        end do
      end do
    end do
  end do
  do j = 1, nO
    do b = 1, nV
      do e = 1, nV
        do m = 1, nO
          B_ovvo(m,e,b,j) = cW_ovvo(m,b,e,j) 
        enddo
      enddo
    enddo
  enddo
  
  call dgemm('T','N', nO*nV, nV*nO, nO*nV, &
             1d0, A_ovov, size(A_ovov,1) * size(A_ovov,2), &
                  B_ovvo, size(B_ovvo,1) * size(B_ovvo,2), &
             0d0, X_ovvo, size(X_ovvo,1) * size(X_ovvo,2))
  do b = 1, nV
    do a = 1, nV
      do j = 1, nO
        do i = 1, nO
          r2(i,j,a,b) = r2(i,j,a,b) + X_ovvo(i,a,b,j) - X_ovvo(j,a,b,i) &
                                    - X_ovvo(i,b,a,j) + X_ovvo(j,b,a,i)
        enddo
      enddo
    enddo
  enddo
  deallocate(A_ovov,B_ovvo,X_ovvo)
  allocate(A_vvoo(nV,nV,nO,nO), B_ovoo(nO,nV,nO,nO), C_ovov(nO,nV,nO,nV))
  do m = 1, nO
    do j = 1, nO
      do b = 1, nV
        do e = 1, nV
          A_vvoo(e,b,j,m) = v_ovvo(m,b,e,j)
        enddo
      enddo
    enddo
  enddo
  call dgemm('N','N', nO, nV*nO*nO, nV, &
             1d0, t1    , size(t1,1), &
                  A_vvoo, size(A_vvoo,1), &
             0d0, B_ovoo, size(B_ovoo,1))
  call dgemm('N','N', nO*nV*nO, nV, nO, &
             1d0, B_ovoo, size(B_ovoo,1) * size(B_ovoo,2) * size(B_ovoo,3), &
                  t1    , size(t1,1), &
             0d0, C_ovov, size(C_ovov,1) * size(C_ovov,2) * size(C_ovov,3))
  do b=1,nV
    do a=1,nV
      do j=1,nO
        do i=1,nO
          r2(i,j,a,b) = r2(i,j,a,b) - C_ovov(i,b,j,a) + C_ovov(j,b,i,a) &
                                    + C_ovov(i,a,j,b) - C_ovov(j,a,i,b)
        end do
      end do
    end do
  end do
  deallocate(A_vvoo, B_ovoo, C_ovov)
                  
  !do b=1,nV
  !  do a=1,nV
  !    do j=1,nO
  !      do i=1,nO

  !        do e=1,nV
  !          r2(i,j,a,b) = r2(i,j,a,b) + t1(i,e)*v_VVVO(a,b,e,j) - t1(j,e)*v_VVVO(a,b,e,i)
  !        end do

  !      end do
  !    end do
  !  end do
  !end do
  allocate(A_vvov(nV,nV,nO,nV), X_vvoo(nV,nV,nO,nO))
  do e = 1, nV
    do j = 1, nO
      do b = 1, nV
        do a = 1, nV
          A_vvov(a,b,j,e) = v_vvvo(a,b,e,j)
        enddo
      enddo
    enddo
  enddo

  call dgemm('N','T', nV*nV*nO, nO, nV, &
             1d0, A_vvov, size(A_vvov,1) * size(A_vvov,2) * size(A_vvov,3), &
                  t1    , size(t1,1), &
             0d0, X_vvoo, size(X_vvoo,1) * size(X_vvoo,2) * size(X_vvoo,3))

  do b = 1, nV
    do a = 1, nV
      do j = 1, nO
        do i = 1, NO
           r2(i,j,a,b ) = r2(i,j,a,b) + X_vvoo(a,b,j,i) - X_vvoo(a,b,i,j)
        enddo
      enddo
    enddo
  enddo
  deallocate(A_vvov,X_vvoo)

  !do b=1,nV
  !  do a=1,nV
  !    do j=1,nO
  !      do i=1,nO

  !        do m=1,nO
  !          r2(i,j,a,b) = r2(i,j,a,b) - t1(m,a)*v_OVOO(m,b,i,j) + t1(m,b)*v_OVOO(m,a,i,j)
  !        end do

  !      end do
  !    end do
  !  end do
  !end do
  allocate(X_vvoo(nV,nV,nO,nO))
  call dgemm('T','N', nV, nV*nO*nO, nO, &
             1d0, t1    , size(t1,1), &
                  v_ovoo, size(v_ovoo,1), &
             0d0, X_vvoo, size(X_vvoo,1))

  do b=1,nV
    do a=1,nV
      do j=1,nO
        do i=1,nO
          r2(i,j,a,b) = r2(i,j,a,b) - X_vvoo(a,b,i,j) + X_vvoo(b,a,i,j)
        end do
      end do
    end do
  end do
  deallocate(X_vvoo)

  do b=1,nV
    do a=1,nV
      do j=1,nO
        do i=1,nO
          r2(i,j,a,b) = D_oovv(i,j,a,b)*t2(i,j,a,b) - r2(i,j,a,b)
        end do
      end do
    end do
  end do

end
#+end_src

* Intermediates
** cF
*** cF_oo
#+begin_src f90 :comments org :tangle test_ccsd_spin_orb.irp.f
subroutine compute_cF_oo(nO,nV,t1,tau_t,Foo,Fov,Fvv,v_ooov,v_oovv,v_ovvv,cF_oo)

  implicit none

  integer,intent(in)            :: nO,nV
  double precision,intent(in)   :: t1(nO,nV)
  double precision,intent(in)   :: tau_t(nO,nO,nV,nV)
  double precision,intent(in)   :: Foo(nO,nO)
  double precision,intent(in)   :: Fov(nO,nV)
  double precision,intent(in)   :: Fvv(nV,nV)
  double precision,intent(in)   :: v_ooov(nO,nO,nO,nV)
  double precision,intent(in)   :: v_oovv(nO,nO,nV,nV)
  double precision,intent(in)   :: v_ovvv(nO,nV,nV,nV)

  double precision,intent(out)  :: cF_oo(nO,nO)

  integer                       :: i,j,m,n
  integer                       :: a,b,e,f
  double precision,external     :: Kronecker_Delta

  do i=1,nO
    do m=1,nO
      cF_oo(m,i) = (1d0 - Kronecker_delta(m,i))*Foo(m,i) 
    end do
  end do

  !do i=1,nO
  !  do m=1,nO
  !    do e=1,nV
  !      cF_oo(m,i) = cF_oo(m,i) + 0.5d0*t1(i,e)*Fov(m,e)
  !    end do
  !  end do
  !end do
  call dgemm('N','T', nO, nO, nV,&
             0.5d0, Fov  , size(Fov,1), &
                    t1   , size(t1,1), &
             1d0  , cF_oo, size(cF_oo,1))

  do i=1,nO
    do m=1,nO
      do e=1,nV
        do n=1,nO
          cF_oo(m,i) = cF_oo(m,i) + t1(n,e)*v_ooov(m,n,i,e)
        end do
      end do
    end do
  end do

  !do i=1,nO
  !  do m=1,nO
  !    do f=1,nV
  !      do e=1,nV
  !        do n=1,nO
  !          cF_oo(m,i) = cF_oo(m,i) + 0.5d0*tau_t(i,n,e,f)*v_oovv(m,n,e,f)
  !        end do
  !      end do
  !    end do
  !  end do
  !end do
  call dgemm('N','T', nO, nO, nO*nV*nV, &
             0.5d0, v_oovv, size(v_oovv,1), &
                    tau_t , size(tau_t,1), &
             1d0  , cF_oo , size(cF_oo,1)) 
  
end
#+end_src

*** cF_ov
#+begin_src f90 :comments org :tangle test_ccsd_spin_orb.irp.f
subroutine compute_cF_ov(nO,nV,t1,tau_t,Foo,Fov,Fvv,v_ooov,v_oovv,v_ovvv,cF_ov)

  implicit none

  integer,intent(in)            :: nO,nV
  double precision,intent(in)   :: t1(nO,nV)
  double precision,intent(in)   :: tau_t(nO,nO,nV,nV)
  double precision,intent(in)   :: Foo(nO,nO)
  double precision,intent(in)   :: Fov(nO,nV)
  double precision,intent(in)   :: Fvv(nV,nV)
  double precision,intent(in)   :: v_ooov(nO,nO,nO,nV)
  double precision,intent(in)   :: v_oovv(nO,nO,nV,nV)
  double precision,intent(in)   :: v_ovvv(nO,nV,nV,nV)

  double precision,intent(out)  :: cF_ov(nO,nV)

  integer                       :: i,j,m,n
  integer                       :: a,b,e,f
  double precision,external     :: Kronecker_Delta

  cF_ov(:,:) = Fov(:,:)

  do e=1,nV
    do m=1,nO
      do f=1,nV
        do n=1,nO
          cF_ov(m,e) = cF_ov(m,e) + t1(n,f)*v_oovv(m,n,e,f)
        end do
      end do
    end do
  end do
  
end
#+end_src

*** cF_vv
#+begin_src f90 :comments org :tangle test_ccsd_spin_orb.irp.f
subroutine compute_cF_vv(nO,nV,t1,tau_t,Foo,Fov,Fvv,v_ooov,v_oovv,v_ovvv,cF_vv)

  implicit none

  integer,intent(in)            :: nO,nV
  double precision,intent(in)   :: t1(nO,nV)
  double precision,intent(in)   :: tau_t(nO,nO,nV,nV)
  double precision,intent(in)   :: Foo(nO,nO)
  double precision,intent(in)   :: Fov(nO,nV)
  double precision,intent(in)   :: Fvv(nV,nV)
  double precision,intent(in)   :: v_ooov(nO,nO,nO,nV)
  double precision,intent(in)   :: v_oovv(nO,nO,nV,nV)
  double precision,intent(in)   :: v_ovvv(nO,nV,nV,nV)

  double precision,intent(out)  :: cF_vv(nV,nV)

  integer                       :: i,j,m,n
  integer                       :: a,b,e,f
  double precision,external     :: Kronecker_Delta
  ! Virtual-virtual block

  do e=1,nV
    do a=1,nV
      cF_vv(a,e) = (1d0 - Kronecker_delta(a,e))*Fvv(a,e) 
    end do
  end do
 
  !do e=1,nV
  !  do a=1,nV
  !    do m=1,nO
  !      cF_vv(a,e) = cF_vv(a,e) - 0.5d0*t1(m,a)*Fov(m,e)
  !    end do
  !  end do
  !end do
  call dgemm('T','N', nV, nV, nO, &
             -0.5d0, t1   , size(t1,1), &
                     Fov  , size(Fov,1), &
              1d0  , cF_vv, size(cF_vv,1))

  !do e=1,nV
  !  do a=1,nV
  !    do m=1,nO
  !      do f=1,nV
  !        cF_vv(a,e) = cF_vv(a,e) + t1(m,f)*v_ovvv(m,a,f,e)
  !      end do
  !    end do
  !  end do
  !end do
  do f = 1, nV
    call dgemv('T', nO, nV*nV, &
               1d0, v_ovvv(:,:,f,:), size(v_ovvv,1), &
                    t1(:,f), 1, &
               1d0, cF_vv, 1)
  enddo

  !do e=1,nV
  !  do a=1,nV
  !    do f=1,nV
  !      do n=1,nO
  !        do m=1,nO
  !          cF_vv(a,e) = cF_vv(a,e) - 0.5d0*tau_t(m,n,a,f)*v_oovv(m,n,e,f)
  !        end do
  !      end do
  !    end do
  !  end do
  !end do
  do f = 1, nV
     call dgemm('T','N', nV, nV, nO*nO,&
                -0.5d0, tau_t(:,:,:,f) , size(tau_t,1) * size(tau_t,2), &
                        v_oovv(:,:,:,f), size(v_oovv,1) * size(v_oovv,2), &
                1d0   , cF_vv, size(cF_vv,1))
  enddo

end
#+end_src

** cW
*** cW_oooo
#+begin_src f90 :comments org :tangle test_ccsd_spin_orb.irp.f
subroutine compute_cW_oooo(nO,nV,t1,t2,tau,v_oooo,v_ooov,v_oovo,v_oovv,v_ovvo,v_ovvv,v_vovv,v_vvvv,cW_oooo)

  implicit none

  integer,intent(in)            :: nO,nV
  double precision,intent(in)   :: t1(nO,nV)
  double precision,intent(in)   :: t2(nO,nO,nV,nV)
  double precision,intent(in)   :: tau(nO,nO,nV,nV)
  double precision,intent(in)   :: v_oooo(nO,nO,nO,nO)
  double precision,intent(in)   :: v_ooov(nO,nO,nO,nV)
  double precision,intent(in)   :: v_oovo(nO,nO,nV,nO)
  double precision,intent(in)   :: v_oovv(nO,nO,nV,nV)
  double precision,intent(in)   :: v_ovvo(nO,nV,nV,nO)
  double precision,intent(in)   :: v_ovvv(nO,nV,nV,nV)
  double precision,intent(in)   :: v_vovv(nV,nO,nV,nV)
  double precision,intent(in)   :: v_vvvv(nV,nV,nV,nV)

  double precision,intent(out)  :: cW_oooo(nO,nO,nO,nO)

  integer                       :: i,j,m,n
  integer                       :: a,b,e,f
  double precision,external     :: Kronecker_Delta

  ! oooo block  

  cW_oooo(:,:,:,:) = oooo(:,:,:,:)

  !do j=1,nO
  !  do i=1,nO
  !    do n=1,nO
  !      do m=1,nO

  !        do e=1,nV
  !          cW_oooo(m,n,i,j) = cW_oooo(m,n,i,j) + t1(j,e)*v_ooov(m,n,i,e) - t1(i,e)*v_ooov(m,n,j,e)
  !        end do

  !      end do
  !    end do
  !  end do
  !end do
  double precision, allocatable :: X_oooo(:,:,:,:)
  allocate(X_oooo(nO,nO,nO,nO))
  call dgemm('N','T', nO*nO*nO, nO, nV, &
             1d0, v_ooov, size(v_ooov,1) * size(v_ooov,2) * size(v_ooov,3), &
                  t1    , size(t1,1), &
             0d0, X_oooo, size(X_oooo,1) * size(X_oooo,1) * size(X_oooo,3))
  do j=1,nO
    do i=1,nO
      do n=1,nO
        do m=1,nO
          cW_oooo(m,n,i,j) = cW_oooo(m,n,i,j) + X_oooo(m,n,i,j) - X_oooo(m,n,j,i)
        end do
      end do
    end do
  end do
  
  deallocate(X_oooo)
  
  !do m=1,nO
  !  do n=1,nO
  !    do i=1,nO
  !      do j=1,nO
  !         
  !        do e=1,nV
  !          do f=1,nV
  !            cW_oooo(m,n,i,j) = cW_oooo(m,n,i,j) + 0.25d0*tau(i,j,e,f)*v_oovv(m,n,e,f)
  !          end do
  !        end do

  !      end do
  !    end do
  !  end do
  !end do

  call dgemm('N','T', nO*nO, nO*nO, nV*nV, &
             0.25d0, v_oovv , size(v_oovv,1) * size(v_oovv,2), &
                     tau    , size(tau,1) * size(tau,2), &
             1.d0  , cW_oooo, size(cW_oooo,1) * size(cW_oooo,2))
  
end
#+end_src

*** cW_ovvo
#+begin_src f90 :comments org :tangle test_ccsd_spin_orb.irp.f
subroutine compute_cW_ovvo(nO,nV,t1,t2,tau,v_oooo,v_ooov,v_oovo,v_oovv,v_ovvo,v_ovvv,v_vovv,v_vvvv,cW_ovvo)

  implicit none

  integer,intent(in)            :: nO,nV
  double precision,intent(in)   :: t1(nO,nV)
  double precision,intent(in)   :: t2(nO,nO,nV,nV)
  double precision,intent(in)   :: tau(nO,nO,nV,nV)
  double precision,intent(in)   :: v_oooo(nO,nO,nO,nO)
  double precision,intent(in)   :: v_ooov(nO,nO,nO,nV)
  double precision,intent(in)   :: v_oovo(nO,nO,nV,nO)
  double precision,intent(in)   :: v_oovv(nO,nO,nV,nV)
  double precision,intent(in)   :: v_ovvo(nO,nV,nV,nO)
  double precision,intent(in)   :: v_ovvv(nO,nV,nV,nV)
  double precision,intent(in)   :: v_vovv(nV,nO,nV,nV)
  double precision,intent(in)   :: v_vvvv(nV,nV,nV,nV)

  double precision,intent(out)  :: cW_ovvo(nO,nV,nV,nO)

  integer                       :: i,j,m,n
  integer                       :: a,b,e,f
  double precision,external     :: Kronecker_Delta
  ! ovvo block

  cW_ovvo(:,:,:,:) = v_ovvo(:,:,:,:)

  !do m=1,nO
  !  do b=1,nV
  !    do e=1,nV
  !      do j=1,nO
  !       
  !        do f=1,nV
  !          cW_ovvo(m,b,e,j) = cW_ovvo(m,b,e,j) + t1(j,f)*v_ovvv(m,b,e,f)
  !        end do
  !        
  !      end do
  !    end do
  !  end do
  !end do
  call dgemm('N','T', nO*nV*nV, nO, nV, &
             1.d0, v_ovvv , size(v_ovvv,1) * size(v_ovvv,2) * size(ovvv,3), &
                   t1     , size(t1,1), &
             1.d0, cW_ovvo, size(cW_ovvo,1) * size(cW_ovvo,2) * size(cW_ovvo,3))

  do j=1,nO
    do e=1,nV
      do b=1,nV
        do m=1,nO
          do n=1,nO
            cW_ovvo(m,b,e,j) = cW_ovvo(m,b,e,j) - t1(n,b)*v_oovo(m,n,e,j)
          end do
        end do
      end do
    end do
  end do

  do j=1,nO
    do e=1,nV
      do b=1,nV
        do m=1,nO
          do f=1,nV
            do n=1,nO
              cW_ovvo(m,b,e,j) = cW_ovvo(m,b,e,j) &
                              - ( 0.5d0*t2(j,n,f,b) + t1(j,f)*t1(n,b) )*v_oovv(m,n,e,f)
            end do
          end do
        end do
      end do
    end do
  end do

end
#+end_src

*** cW_vvvv
#+begin_src f90 :comments org :tangle test_ccsd_spin_orb.irp.f
subroutine compute_cW_vvvv(nO,nV,t1,t2,tau,v_oooo,v_ooov,v_oovo,v_oovv,v_ovvo,v_ovvv,v_vovv,v_vvvv,cW_vvvv)

  implicit none

  integer,intent(in)            :: nO,nV
  double precision,intent(in)   :: t1(nO,nV)
  double precision,intent(in)   :: t2(nO,nO,nV,nV)
  double precision,intent(in)   :: tau(nO,nO,nV,nV)
  double precision,intent(in)   :: v_oooo(nO,nO,nO,nO)
  double precision,intent(in)   :: v_ooov(nO,nO,nO,nV)
  double precision,intent(in)   :: v_oovo(nO,nO,nV,nO)
  double precision,intent(in)   :: v_oovv(nO,nO,nV,nV)
  double precision,intent(in)   :: v_ovvo(nO,nV,nV,nO)
  double precision,intent(in)   :: v_ovvv(nO,nV,nV,nV)
  double precision,intent(in)   :: v_vovv(nV,nO,nV,nV)
  double precision,intent(in)   :: v_vvvv(nV,nV,nV,nV)

  double precision,intent(out)  :: cW_vvvv(nV,nV,nV,nV)

  integer                       :: i,j,m,n
  integer                       :: a,b,e,f
  double precision,external     :: Kronecker_Delta
  ! vvvv block

  cW_vvvv(:,:,:,:) = v_vvvv(:,:,:,:)

  do f=1,nV
    do e=1,nV
      do b=1,nV
        do a=1,nV

          do m=1,nO
            cW_vvvv(a,b,e,f) = cW_vvvv(a,b,e,f) - t1(m,b)*v_vovv(a,m,e,f) + t1(m,a)*v_vovv(b,m,e,f)
          end do
          
        end do
      end do
    end do
  end do

  !do a=1,nV
  !  do b=1,nV
  !    do e=1,nV
  !      do f=1,nV
  !         
  !        do m=1,nO
  !          do n=1,nO
  !            cW_vvvv(a,b,e,f) = cW_vvvv(a,b,e,f) + 0.25d0*tau(m,n,a,b)*v_oovv(m,n,e,f)
  !          end do
  !        end do

  !      end do
  !    end do
  !  end do
  !end do
  call dgemm('T','N', nV*nV, nV*nV, nO*nO, &
             0.25d0, tau    , size(tau,1) * size(tau,2), &
                     v_OOVV , size(v_oovv,1) * size(v_oovv,2), &
             1.d0  , cW_vvvv, size(cW_vvvv,1) * size(cW_vvvv,2))

end
#+end_src



* Utils
#+begin_src f90 :comments org :tangle test_ccsd_spin_orb.irp.f
function Kronecker_delta(i,j) result(delta)

  implicit none

  integer,intent(in)            :: i,j

  double precision              :: delta

  if(i == j) then
    delta = 1d0
  else
    delta = 0d0
  endif

end
#+end_src
