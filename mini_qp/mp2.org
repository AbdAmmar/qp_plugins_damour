#+begin_src f90 :comments org :tangle mp2.irp.f
program mp2

  implicit none

  call run_mp2()
  call run_mp2_ont_det()

end
#+end_src

#+begin_src f90 :comments org :tangle mp2.irp.f
subroutine run_mp2()

  implicit none

  double precision              :: E, mo_two_e_integral
  integer                       :: i,j,a,b,tmp_i,tmp_j,tmp_a,tmp_b
  integer                       :: nI, nV

  nI = n_inact_orb
  nV = n_virt_orb

  print*,'n_inact_orb =', n_inact_orb
  print*,'n_virt_orb  =', n_virt_orb
  
  E = 0d0

  do tmp_b = 1, nV
    b = list_virt(tmp_b)
    do tmp_a = 1, nV
      a = list_virt(tmp_a)
      do tmp_j = 1, nI
        j = list_inact(tmp_j)
        do tmp_i = 1, nI
           i = list_inact(tmp_i)
           E = E - ( mo_two_e_integral(i,j,a,b) &
               ,* (2d0 * mo_two_e_integral(i,j,a,b) - mo_two_e_integral(i,j,b,a))) &
              / (fock_matrix_mo(a,a) + fock_matrix_mo(b,b)     &
               - fock_matrix_mo(i,i) - fock_matrix_mo(j,j))
        enddo
      enddo
    enddo
  enddo
  
  print*,'E(SCF)=', hf_energy
  print*,'E(MP2)=', E
  print*,'Total =', E+hf_energy
  
end
#+end_src

#+begin_src f90 :comments org :tangle mp2.irp.f
subroutine run_mp2_ont_det()

  use bitmasks
  implicit none

  double precision              :: E, mo_two_e_integral, div
  integer                       :: i,j,a,b,tmp_i,tmp_j,tmp_a,tmp_b
  integer                       :: nI, nV, nA

  integer(bit_kind), allocatable :: det(:,:), res(:,:)
  logical, allocatable :: act_p(:,:)
  integer :: s1,s2,h1,tmp_h
  logical :: is_p

  nI = n_inact_orb
  nA = n_act_orb
  nV = n_virt_orb

  print*,'n_inact_orb =', n_inact_orb
  print*,'n_act_orb   =', n_act_orb
  print*,'n_virt_orb  =', n_virt_orb
  
  allocate(det(N_int,2), res(N_int,2), act_p(2,nA))
  
  det(:,:) = psi_det(:,:,1)

  ! List of occupied
  !call bitstring_to_list(det(:,1), occ_a, mo_num, N_int)
  !call bitstring_to_list(det(:,2), occ_b, mo_num , N_int)
  !print*,'occ a', occ_a

  do s1 = 1, 2
    do h1 = 1, nA
      tmp_h = list_act(h1)
      call apply_hole(det,s1,tmp_h,res,is_p,N_int)
      act_p(s1,h1) = is_p
    enddo
  enddo

  print*,'act_p'
  print*,act_p(1,:)
  print*,act_p(2,:)
  
  ! Inact -> virt
  ! sum_i^inact sum_j^inact
  E = 0d0
  do tmp_b = 1, nV
    b = list_virt(tmp_b)
    do tmp_a = 1, nV
      a = list_virt(tmp_a)
      do tmp_j = 1, nI
        j = list_inact(tmp_j)
        do tmp_i = 1, nI
           i = list_inact(tmp_i)
           E = E - ( 2d0 * (mo_two_e_integral(i,j,a,b) - mo_two_e_integral(i,j,b,a))**2 &
                     + 2d0 * mo_two_e_integral(i,j,a,b)**2                              &
                     + 2d0 * mo_two_e_integral(i,j,b,a)**2 )                            &
              / (fock_matrix_mo(a,a) + fock_matrix_mo(b,b)                              &
               - fock_matrix_mo(i,i) - fock_matrix_mo(j,j))
        enddo
      enddo
    enddo
  enddo

  ! Act -> virt

  ! sum_i^occ sum_j^occ = sum_i^inact sum_j^inact
  !                     + sum_i^act,occ sum_j^act,occ
  !                     + sum_i^inact sum_j^act,occ
  !                     + sum_i^act,occ sum_j^inact

  ! sum_i^act sum_j^act
  ! sum_a^vir sum_b^vir
  do tmp_b = 1, nV
    b = list_virt(tmp_b)
    do tmp_a = 1, nV
      a = list_virt(tmp_a)
      do tmp_j = 1, nA
         
        do s2 = 1, 2
          j = list_act(tmp_j)
          if (act_p(s2,tmp_j)) then
             
            do tmp_i = 1, nA
              do s1 = 1, 2
                i = list_act(tmp_i)
                if (act_p(s1,tmp_i)) then
                   
                  div = 1d0 / (fock_matrix_mo(a,a) + fock_matrix_mo(b,b)  &
                               - fock_matrix_mo(i,i) - fock_matrix_mo(j,j))
                  if (s1 == s2) then
                     E = E - (mo_two_e_integral(i,j,a,b) - mo_two_e_integral(i,j,b,a))**2 * div
                  else
                     E = E - (mo_two_e_integral(i,j,a,b)**2 + mo_two_e_integral(i,j,b,a)**2) * div
                  endif
                  
                endif
              enddo
            enddo
          endif
        enddo
      enddo
    enddo
  enddo
  

  ! Inact -> act

  ! Act -> act

  ! Final energy
  E = E * 0.25d0
  
  print*,'E(SCF)=', hf_energy
  print*,'E(MP2)=', E
  print*,'Total =', E+hf_energy
  
  deallocate(det,res,act_p)
  
end
#+end_src

#+begin_src f90 :comments org :tangle mp2.irp.f
subroutine import_eri(v)

  implicit none

  double precision, intent(out) :: v(mo_num, mo_num, mo_num, mo_num)
  double precision              :: mo_two_e_integral
  integer                       :: i,j,a,b,tmp_i,tmp_j,tmp_a,tmp_b
  integer                       :: nI, nV

  nI = dim_list_inact_orb
  nV = dim_list_virt_orb
  
  do tmp_b = 1, nV
    b = list_virt(tmp_b)
    do tmp_a = 1, nV
      a = list_virt(tmp_a)
      do tmp_j = 1, nI
        j = list_inact(tmp_j)
        do tmp_i = 1, nI
          i = list_inact(tmp_i)
          v(i,j,a,b) = mo_two_e_integral(i,j,a,b)
        enddo
      enddo
    enddo
  enddo

end
#+end_src


** Test
MP perturbation theory
\begin{align*}
E^{(0)} + E^{(1)} &= \sum_i^\text{elec} \varepsilon_i - \frac{1}{2} \sum_{ij}^\text{elec} <ij||ij> \\
&= \sum_i^\text{elec} \left(h_{ii} + \sum_j^\text{elec} <ij||ij> \right) - \frac{1}{2} \sum_{ij}^\text{elec} <ij||ij> \\
&= \sum_i^\text{elec} h_{ii} + \frac{1}{2} \sum_{ij}^\text{elec} <ij||ij> \\
&= <0|\hat{H}|0>
\end{align*}
#+begin_src f90 :comments org :tangle mp2.irp.f
subroutine test_E_mono_det()
  implicit none

  ! Only for seniority 0 determinants

  double precision :: E, E0, E1, mo_two_e_integral
  integer :: i,j,tmp_i,tmp_j
 
  ! With Fock 
  E0 = 0d0
  do i = 1, elec_alpha_num
    E0 = E0 + 2d0 * fock_matrix_mo(i,i)
  enddo
  
  E1 = 0d0
  do i = 1, elec_alpha_num
    do j = 1, elec_alpha_num
      E1 = E1 - 0.5d0 * (mo_two_e_integral(i,j,i,j) - mo_two_e_integral(i,j,j,i)) &
              - 0.5d0 * (mo_two_e_integral(i,j,i,j) - mo_two_e_integral(i,j,j,i)) &
              - 0.5d0 * (mo_two_e_integral(i,j,i,j))                              &  
              - 0.5d0 * (mo_two_e_integral(i,j,i,j))
    enddo
  enddo

  print*, "E", E0 + E1 + nuclear_repulsion

  ! As <H>
  E = 0d0
  do i = 1, elec_alpha_num
    E = E + 2d0 * mo_one_e_integrals(i,i)
  enddo

  do i = 1, elec_alpha_num
    do j = 1, elec_alpha_num
      E = E + 0.5d0 * (mo_two_e_integral(i,j,i,j) - mo_two_e_integral(i,j,j,i)) &
            + 0.5d0 * (mo_two_e_integral(i,j,i,j) - mo_two_e_integral(i,j,j,i)) &
            + 0.5d0 * (mo_two_e_integral(i,j,i,j))                              &
            + 0.5d0 * (mo_two_e_integral(i,j,i,j))
    enddo
  enddo

  print*, "E", E + nuclear_repulsion

  ! With Fock
  double precision, allocatable :: fock_diag_tmp(:,:)
  allocate(fock_diag_tmp(2,mo_num+1))

  call build_fock_tmp(fock_diag_tmp,psi_det(N_int,:,2),N_int)
  call print_det(psi_det(N_int,:,2),N_int)
 
  do i = 1, mo_num
    write(*,'(10F12.3)') fock_matrix_mo(i,:)
  enddo
 
  do i = 1, mo_num
    write(*,'(10F12.3)') fock_diag_tmp(:,i)
  enddo
 
  E0 = 0d0
  do i = 1, elec_alpha_num
    !E0 = E0 + 2d0 * fock_diag_tmp(1,i)
    !E0 = E0 + 2d0 * fock_diag_tmp(2,i)
  enddo

  fock_diag_tmp = 0d0
  do tmp_i = 1, elec_alpha_num
    i = list_inact(tmp_i)
    fock_diag_tmp(1,tmp_i) = fock_diag_tmp(1,tmp_i) + mo_one_e_integrals(i,i)
    fock_diag_tmp(2,tmp_i) = fock_diag_tmp(1,tmp_i)
  enddo 

  do tmp_i = 1, elec_alpha_num
    i = list_inact(tmp_i)
    do tmp_j = 1, elec_alpha_num
      j = list_inact(tmp_j)
        fock_diag_tmp(1,tmp_i) = fock_diag_tmp(1,tmp_i)             &       
        + (mo_two_e_integral(i,j,i,j) - mo_two_e_integral(i,j,j,i)) &
        + (mo_two_e_integral(i,j,i,j)) 
        fock_diag_tmp(2,tmp_i) = fock_diag_tmp(1,tmp_i)
    enddo
  enddo

  do i = 1, mo_num
    write(*,'(10F12.3)') fock_diag_tmp(:,i)
    E0 = E0 + fock_diag_tmp(1,i) + fock_diag_tmp(2,i)
  enddo
 
  E1 = 0d0
  do tmp_j = 1, elec_alpha_num
    j = list_inact(tmp_j)
    do tmp_i = 1, elec_alpha_num
      i = list_inact(tmp_i)
      E1 = E1 - 0.5d0 * (mo_two_e_integral(i,j,i,j) - mo_two_e_integral(i,j,j,i)) &
              - 0.5d0 * (mo_two_e_integral(i,j,i,j) - mo_two_e_integral(i,j,j,i)) &
              - 0.5d0 * (mo_two_e_integral(i,j,i,j))                              &
              - 0.5d0 * (mo_two_e_integral(i,j,i,j))
    enddo
  enddo

  print*, "E", E0 + E1 + nuclear_repulsion

  deallocate(fock_diag_tmp)

  ! As <H>
  E = 0d0
  do tmp_i = 1, elec_alpha_num
    i = list_inact(tmp_i)
    E = E + 2d0 * mo_one_e_integrals(i,i)
  enddo

  do tmp_i = 1, elec_alpha_num
    i = list_inact(tmp_i)
    do tmp_j = 1, elec_alpha_num
      j = list_inact(tmp_j)
      E = E + 0.5d0 * (mo_two_e_integral(i,j,i,j) - mo_two_e_integral(i,j,j,i)) &
            + 0.5d0 * (mo_two_e_integral(i,j,i,j) - mo_two_e_integral(i,j,j,i)) &
            + 0.5d0 * (mo_two_e_integral(i,j,i,j))                              &
            + 0.5d0 * (mo_two_e_integral(i,j,i,j))
    enddo
  enddo

  print*, "E", E + nuclear_repulsion

end
#+end_src
